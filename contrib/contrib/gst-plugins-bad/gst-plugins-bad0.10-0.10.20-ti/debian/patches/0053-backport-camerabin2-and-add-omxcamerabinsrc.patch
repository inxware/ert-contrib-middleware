From 8b2e778aea1143c354500710176347ba6bde686f Mon Sep 17 00:00:00 2001
From: Alessandro Decina <alessandro.decina@collabora.co.uk>
Date: Fri, 6 May 2011 01:36:41 +0200
Subject: [PATCH 3/6] backport camerabin2 and add omxcamerabinsrc

---
 configure.ac                                       |    4 +
 gst-libs/gst/Makefile.am                           |    5 +-
 gst-libs/gst/basecamerabinsrc/Makefile.am          |   28 +
 gst-libs/gst/basecamerabinsrc/gstbasecamerasrc.c   |  639 ++++++++
 gst-libs/gst/basecamerabinsrc/gstbasecamerasrc.h   |  145 ++
 gst-libs/gst/basecamerabinsrc/gstcamerabin-enum.c  |   39 +
 gst-libs/gst/basecamerabinsrc/gstcamerabin-enum.h  |   57 +
 .../gst/basecamerabinsrc/gstcamerabinpreview.c     |  226 +++
 .../gst/basecamerabinsrc/gstcamerabinpreview.h     |   44 +
 gst/camerabin2/Makefile.am                         |   31 +
 gst/camerabin2/PORTING                             |   22 +
 gst/camerabin2/camerabingeneral.c                  |  278 ++++
 gst/camerabin2/camerabingeneral.h                  |   39 +
 gst/camerabin2/gstcamerabin2.c                     | 1651 ++++++++++++++++++++
 gst/camerabin2/gstcamerabin2.h                     |  113 ++
 gst/camerabin2/gstimagecapturebin.c                |  352 +++++
 gst/camerabin2/gstimagecapturebin.h                |   63 +
 gst/camerabin2/gstomxcamerabinsrc.c                |  766 +++++++++
 gst/camerabin2/gstomxcamerabinsrc.h                |  106 ++
 gst/camerabin2/gstplugin.c                         |   52 +
 gst/camerabin2/gstviewfinderbin.c                  |  305 ++++
 gst/camerabin2/gstviewfinderbin.h                  |   58 +
 gst/camerabin2/gstwrappercamerabinsrc.c            | 1158 ++++++++++++++
 gst/camerabin2/gstwrappercamerabinsrc.h            |  129 ++
 tests/check/Makefile.am                            |   25 +-
 tests/check/elements/camerabin2.c                  | 1367 ++++++++++++++++
 tests/examples/Makefile.am                         |    2 +-
 tests/examples/camerabin2/.gitignore               |    5 +
 tests/examples/camerabin2/Makefile.am              |   51 +
 tests/examples/camerabin2/gst-camera2.c            |  186 +++
 tests/examples/camerabin2/gst-camera2.h            |   48 +
 tests/examples/camerabin2/gst-camera2.ui           |  109 ++
 tests/examples/camerabin2/gst-camerabin2-test.c    |  858 ++++++++++
 33 files changed, 8955 insertions(+), 6 deletions(-)
 create mode 100644 gst-libs/gst/basecamerabinsrc/Makefile.am
 create mode 100644 gst-libs/gst/basecamerabinsrc/gstbasecamerasrc.c
 create mode 100644 gst-libs/gst/basecamerabinsrc/gstbasecamerasrc.h
 create mode 100644 gst-libs/gst/basecamerabinsrc/gstcamerabin-enum.c
 create mode 100644 gst-libs/gst/basecamerabinsrc/gstcamerabin-enum.h
 create mode 100644 gst-libs/gst/basecamerabinsrc/gstcamerabinpreview.c
 create mode 100644 gst-libs/gst/basecamerabinsrc/gstcamerabinpreview.h
 create mode 100644 gst/camerabin2/Makefile.am
 create mode 100644 gst/camerabin2/PORTING
 create mode 100644 gst/camerabin2/camerabingeneral.c
 create mode 100644 gst/camerabin2/camerabingeneral.h
 create mode 100644 gst/camerabin2/gstcamerabin2.c
 create mode 100644 gst/camerabin2/gstcamerabin2.h
 create mode 100644 gst/camerabin2/gstimagecapturebin.c
 create mode 100644 gst/camerabin2/gstimagecapturebin.h
 create mode 100644 gst/camerabin2/gstomxcamerabinsrc.c
 create mode 100644 gst/camerabin2/gstomxcamerabinsrc.h
 create mode 100644 gst/camerabin2/gstplugin.c
 create mode 100644 gst/camerabin2/gstviewfinderbin.c
 create mode 100644 gst/camerabin2/gstviewfinderbin.h
 create mode 100644 gst/camerabin2/gstwrappercamerabinsrc.c
 create mode 100644 gst/camerabin2/gstwrappercamerabinsrc.h
 create mode 100644 tests/check/elements/camerabin2.c
 create mode 100644 tests/examples/camerabin2/.gitignore
 create mode 100644 tests/examples/camerabin2/Makefile.am
 create mode 100644 tests/examples/camerabin2/gst-camera2.c
 create mode 100644 tests/examples/camerabin2/gst-camera2.h
 create mode 100644 tests/examples/camerabin2/gst-camera2.ui
 create mode 100644 tests/examples/camerabin2/gst-camerabin2-test.c

diff --git a/configure.ac b/configure.ac
index ff2439b..c105394 100644
--- a/configure.ac
+++ b/configure.ac
@@ -269,6 +269,7 @@ AG_GST_CHECK_PLUGIN(audioparsers)
 AG_GST_CHECK_PLUGIN(autoconvert)
 AG_GST_CHECK_PLUGIN(bayer)
 AG_GST_CHECK_PLUGIN(camerabin)
+AG_GST_CHECK_PLUGIN(camerabin2)
 AG_GST_CHECK_PLUGIN(cdxaparse)
 AG_GST_CHECK_PLUGIN(coloreffects)
 AG_GST_CHECK_PLUGIN(dataurisrc)
@@ -1682,6 +1683,7 @@ gst/audioparsers/Makefile
 gst/autoconvert/Makefile
 gst/bayer/Makefile
 gst/camerabin/Makefile
+gst/camerabin2/Makefile
 gst/cdxaparse/Makefile
 gst/coloreffects/Makefile
 gst/dataurisrc/Makefile
@@ -1735,6 +1737,7 @@ gst/videosignal/Makefile
 gst/vmnc/Makefile
 gst-libs/Makefile
 gst-libs/gst/Makefile
+gst-libs/gst/basecamerabinsrc/Makefile
 gst-libs/gst/interfaces/Makefile
 gst-libs/gst/signalprocessor/Makefile
 gst-libs/gst/video/Makefile
@@ -1764,6 +1767,7 @@ tests/Makefile
 tests/check/Makefile
 tests/examples/Makefile
 tests/examples/camerabin/Makefile
+tests/examples/camerabin2/Makefile
 tests/examples/directfb/Makefile
 tests/examples/mxf/Makefile
 tests/examples/scaletempo/Makefile
diff --git a/gst-libs/gst/Makefile.am b/gst-libs/gst/Makefile.am
index 75e73a5..1304801 100644
--- a/gst-libs/gst/Makefile.am
+++ b/gst-libs/gst/Makefile.am
@@ -1,5 +1,4 @@
-
-SUBDIRS = interfaces signalprocessor video camerasrc
+SUBDIRS = interfaces signalprocessor video camerasrc basecamerabinsrc
 
 noinst_HEADERS = gst-i18n-plugin.h gettext.h
-DIST_SUBDIRS = interfaces signalprocessor video camerasrc
+DIST_SUBDIRS = interfaces signalprocessor video camerasrc basecamerabinsrc
diff --git a/gst-libs/gst/basecamerabinsrc/Makefile.am b/gst-libs/gst/basecamerabinsrc/Makefile.am
new file mode 100644
index 0000000..7aaf706
--- /dev/null
+++ b/gst-libs/gst/basecamerabinsrc/Makefile.am
@@ -0,0 +1,28 @@
+
+lib_LTLIBRARIES = libgstbasecamerabinsrc-@GST_MAJORMINOR@.la
+
+CLEANFILES = $(BUILT_SOURCES)
+
+libgstbasecamerabinsrc_@GST_MAJORMINOR@_la_SOURCES = \
+        gstcamerabin-enum.c \
+        gstcamerabinpreview.c \
+	gstbasecamerasrc.c
+
+libgstbasecamerabinsrc_@GST_MAJORMINOR@includedir = $(includedir)/gstreamer-@GST_MAJORMINOR@/gst/basecamerabinsrc
+libgstbasecamerabinsrc_@GST_MAJORMINOR@include_HEADERS = \
+	gstcamerabin-enum.h \
+	gstcamerabinpreview.h \
+	gstbasecamerasrc.h
+
+libgstbasecamerabinsrc_@GST_MAJORMINOR@_la_CFLAGS = \
+	$(GST_PLUGINS_BAD_CFLAGS) \
+	$(GST_PLUGINS_BASE_CFLAGS) \
+	-DGST_USE_UNSTABLE_API \
+	$(GST_CFLAGS)
+libgstbasecamerabinsrc_@GST_MAJORMINOR@_la_LIBADD = \
+        $(top_builddir)/gst-libs/gst/interfaces/libgstphotography-@GST_MAJORMINOR@.la \
+	$(GST_PLUGINS_BASE_LIBS) -lgstinterfaces-$(GST_MAJORMINOR) \
+	-lgstapp-$(GST_MAJORMINOR) $(GST_BASE_LIBS) $(GST_LIBS)
+
+libgstbasecamerabinsrc_@GST_MAJORMINOR@_la_LDFLAGS = $(GST_LIB_LDFLAGS) $(GST_ALL_LDFLAGS) $(GST_LT_LDFLAGS)
+
diff --git a/gst-libs/gst/basecamerabinsrc/gstbasecamerasrc.c b/gst-libs/gst/basecamerabinsrc/gstbasecamerasrc.c
new file mode 100644
index 0000000..b2ae992
--- /dev/null
+++ b/gst-libs/gst/basecamerabinsrc/gstbasecamerasrc.c
@@ -0,0 +1,639 @@
+/*
+ * GStreamer
+ * Copyright (C) 2010 Texas Instruments, Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+
+
+/**
+ * SECTION:element-basecamerasrc
+ *
+ * Base class for the camera source bin used by camerabin for capture. 
+ * Sophisticated camera hardware can derive from this baseclass and map the
+ * features to this interface.
+ *
+ * The design mandates that the subclasses implement the following features and
+ * behaviour:
+ * <itemizedlist>
+ *   <listitem><para>
+ *     3 pads: viewfinder, image capture, video capture
+ *   </para></listitem>
+ *   <listitem><para>
+ *   </para></listitem>
+ * </itemizedlist>
+ *
+ * During construct_pipeline() vmethod a subclass can add several elements into
+ * the bin and expose 3 srcs pads as ghostpads implementing the 3 pad templates.
+ *
+ * It is also possible to add regular pads from the subclass and implement the
+ * dataflow methods on these pads. This way all functionality can be implemneted
+ * directly in the subclass without extra elements.
+ *
+ * The src will receive the capture mode from #GstCameraBin2 on the 
+ * #GstBaseCameraSrc:mode property. Possible capture modes are defined in
+ * #GstCameraBinMode.
+ */
+
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#include "gstbasecamerasrc.h"
+
+enum
+{
+  PROP_0,
+  PROP_MODE,
+  PROP_ZOOM,
+  PROP_MAX_ZOOM,
+  PROP_READY_FOR_CAPTURE,
+  PROP_POST_PREVIEW,
+  PROP_PREVIEW_CAPS,
+  PROP_PREVIEW_FILTER
+};
+
+enum
+{
+  /* action signals */
+  START_CAPTURE_SIGNAL,
+  STOP_CAPTURE_SIGNAL,
+  /* emit signals */
+  LAST_SIGNAL
+};
+
+#define DEFAULT_POST_PREVIEW TRUE
+
+static guint basecamerasrc_signals[LAST_SIGNAL];
+
+GST_DEBUG_CATEGORY (base_camera_src_debug);
+#define GST_CAT_DEFAULT base_camera_src_debug
+
+GST_BOILERPLATE (GstBaseCameraSrc, gst_base_camera_src, GstBin, GST_TYPE_BIN);
+
+static GstStaticPadTemplate vfsrc_template =
+GST_STATIC_PAD_TEMPLATE (GST_BASE_CAMERA_SRC_VIEWFINDER_PAD_NAME,
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS_ANY);
+
+static GstStaticPadTemplate imgsrc_template =
+GST_STATIC_PAD_TEMPLATE (GST_BASE_CAMERA_SRC_IMAGE_PAD_NAME,
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS_ANY);
+
+static GstStaticPadTemplate vidsrc_template =
+GST_STATIC_PAD_TEMPLATE (GST_BASE_CAMERA_SRC_VIDEO_PAD_NAME,
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS_ANY);
+
+/* NOTE: we could provide a vmethod for derived class to overload to provide
+ * it's own implementation of interface..  but in all cases I can think of at
+ * moment, either the camerasrc itself, or some element within the bin, will
+ * be implementing the interface..
+ */
+
+/**
+ * gst_base_camera_src_get_photography:
+ * @self: the camerasrc bin
+ *
+ * Get object implementing photography interface, if there is one.  Otherwise
+ * returns NULL.
+ */
+GstPhotography *
+gst_base_camera_src_get_photography (GstBaseCameraSrc * self)
+{
+  GstElement *elem;
+
+  if (GST_IS_PHOTOGRAPHY (self)) {
+    elem = GST_ELEMENT (self);
+  } else {
+    elem = gst_bin_get_by_interface (GST_BIN (self), GST_TYPE_PHOTOGRAPHY);
+  }
+
+  if (elem) {
+    return GST_PHOTOGRAPHY (elem);
+  }
+
+  return NULL;
+}
+
+
+/**
+ * gst_base_camera_src_get_colorbalance:
+ * @self: the camerasrc bin
+ *
+ * Get object implementing colorbalance interface, if there is one.  Otherwise
+ * returns NULL.
+ */
+GstColorBalance *
+gst_base_camera_src_get_color_balance (GstBaseCameraSrc * self)
+{
+  GstElement *elem;
+
+  if (GST_IS_COLOR_BALANCE (self)) {
+    elem = GST_ELEMENT (self);
+  } else {
+    elem = gst_bin_get_by_interface (GST_BIN (self), GST_TYPE_COLOR_BALANCE);
+  }
+
+  if (elem) {
+    return GST_COLOR_BALANCE (self);
+  }
+
+  return NULL;
+}
+
+/**
+ * gst_base_camera_src_set_mode:
+ * @self: the camerasrc bin
+ * @mode: the mode
+ *
+ * Set the chosen #GstCameraBinMode capture mode.
+ */
+gboolean
+gst_base_camera_src_set_mode (GstBaseCameraSrc * self, GstCameraBinMode mode)
+{
+  GstBaseCameraSrcClass *bclass = GST_BASE_CAMERA_SRC_GET_CLASS (self);
+
+  g_return_val_if_fail (bclass->set_mode, FALSE);
+
+  if (bclass->set_mode (self, mode)) {
+    self->mode = mode;
+    return TRUE;
+  }
+  return FALSE;
+}
+
+/**
+ * gst_base_camera_src_setup_zoom:
+ * @self: camerasrc object
+ *
+ * Apply zoom configured to camerabin to capture.
+ */
+void
+gst_base_camera_src_setup_zoom (GstBaseCameraSrc * self)
+{
+  GstBaseCameraSrcClass *bclass = GST_BASE_CAMERA_SRC_GET_CLASS (self);
+
+  g_return_if_fail (self->zoom);
+  g_return_if_fail (bclass->set_zoom);
+
+  bclass->set_zoom (self, self->zoom);
+}
+
+/**
+ * gst_base_camera_src_setup_preview:
+ * @self: camerasrc bin
+ * @preview_caps: preview caps to set
+ *
+ * Apply preview caps to preview pipeline and to video source.
+ */
+void
+gst_base_camera_src_setup_preview (GstBaseCameraSrc * self,
+    GstCaps * preview_caps)
+{
+  GstBaseCameraSrcClass *bclass = GST_BASE_CAMERA_SRC_GET_CLASS (self);
+
+  if (self->preview_pipeline) {
+    GST_DEBUG_OBJECT (self,
+        "Setting preview pipeline caps %" GST_PTR_FORMAT, self->preview_caps);
+    gst_camerabin_preview_set_caps (self->preview_pipeline, preview_caps);
+  }
+
+  if (bclass->set_preview)
+    bclass->set_preview (self, preview_caps);
+}
+
+/**
+ * gst_base_camera_src_get_allowed_input_caps:
+ * @self: the camerasrc bin
+ *
+ * Retrieve caps from videosrc describing formats it supports
+ *
+ * Returns: caps object from videosrc
+ */
+GstCaps *
+gst_base_camera_src_get_allowed_input_caps (GstBaseCameraSrc * self)
+{
+  GstBaseCameraSrcClass *bclass = GST_BASE_CAMERA_SRC_GET_CLASS (self);
+
+  g_return_val_if_fail (bclass->get_allowed_input_caps, NULL);
+
+  return bclass->get_allowed_input_caps (self);
+}
+
+static void
+gst_base_camera_src_start_capture (GstBaseCameraSrc * src)
+{
+  GstBaseCameraSrcClass *klass = GST_BASE_CAMERA_SRC_GET_CLASS (src);
+
+  g_return_if_fail (klass->start_capture != NULL);
+
+  GST_DEBUG_OBJECT (src, "Starting capture");
+
+  g_mutex_lock (src->capturing_mutex);
+  if (src->capturing) {
+    GST_WARNING_OBJECT (src, "Capturing already ongoing");
+    g_mutex_unlock (src->capturing_mutex);
+
+    /* post a warning to notify camerabin2 that the capture failed */
+    GST_ELEMENT_WARNING (src, RESOURCE, BUSY, (NULL), (NULL));
+    return;
+  }
+
+  src->capturing = TRUE;
+  g_object_notify (G_OBJECT (src), "ready-for-capture");
+  if (klass->start_capture (src)) {
+    GST_DEBUG_OBJECT (src, "Capture started");
+  } else {
+    src->capturing = FALSE;
+    g_object_notify (G_OBJECT (src), "ready-for-capture");
+    GST_WARNING_OBJECT (src, "Failed to start capture");
+  }
+  g_mutex_unlock (src->capturing_mutex);
+}
+
+static void
+gst_base_camera_src_stop_capture (GstBaseCameraSrc * src)
+{
+  GstBaseCameraSrcClass *klass = GST_BASE_CAMERA_SRC_GET_CLASS (src);
+
+  g_return_if_fail (klass->stop_capture != NULL);
+
+  g_mutex_lock (src->capturing_mutex);
+  if (!src->capturing) {
+    GST_DEBUG_OBJECT (src, "No ongoing capture");
+    g_mutex_unlock (src->capturing_mutex);
+    return;
+  }
+  klass->stop_capture (src);
+  g_mutex_unlock (src->capturing_mutex);
+}
+
+void
+gst_base_camera_src_finish_capture (GstBaseCameraSrc * self)
+{
+  GST_DEBUG_OBJECT (self, "Finishing capture");
+  g_return_if_fail (self->capturing);
+  self->capturing = FALSE;
+  g_object_notify (G_OBJECT (self), "ready-for-capture");
+}
+
+static void
+gst_base_camera_src_dispose (GObject * object)
+{
+  GstBaseCameraSrc *src = GST_BASE_CAMERA_SRC_CAST (object);
+
+  g_mutex_free (src->capturing_mutex);
+
+  if (src->preview_pipeline) {
+    gst_camerabin_destroy_preview_pipeline (src->preview_pipeline);
+    src->preview_pipeline = NULL;
+  }
+
+  if (src->preview_caps)
+    gst_caps_replace (&src->preview_caps, NULL);
+
+  if (src->preview_filter) {
+    gst_object_unref (src->preview_filter);
+    src->preview_filter = NULL;
+  }
+
+  G_OBJECT_CLASS (parent_class)->dispose (object);
+}
+
+static void
+gst_base_camera_src_finalize (GstBaseCameraSrc * self)
+{
+  G_OBJECT_CLASS (parent_class)->finalize ((GObject *) (self));
+}
+
+static void
+gst_base_camera_src_set_property (GObject * object,
+    guint prop_id, const GValue * value, GParamSpec * pspec)
+{
+  GstBaseCameraSrc *self = GST_BASE_CAMERA_SRC (object);
+
+  switch (prop_id) {
+    case PROP_MODE:
+      gst_base_camera_src_set_mode (GST_BASE_CAMERA_SRC (self),
+          g_value_get_enum (value));
+      break;
+    case PROP_ZOOM:{
+      self->zoom = g_value_get_float (value);
+      /* limit to max-zoom */
+      if (self->zoom > self->max_zoom) {
+        GST_DEBUG_OBJECT (self, "Clipping zoom %f to max-zoom %f", self->zoom,
+            self->max_zoom);
+        self->zoom = self->max_zoom;
+      }
+      /* does not set it if in NULL, the src is not created yet */
+      if (GST_STATE (self) != GST_STATE_NULL)
+        gst_base_camera_src_setup_zoom (self);
+      break;
+    }
+    case PROP_POST_PREVIEW:
+      self->post_preview = g_value_get_boolean (value);
+      break;
+    case PROP_PREVIEW_CAPS:{
+      GstCaps *new_caps = NULL;
+      new_caps = (GstCaps *) gst_value_get_caps (value);
+      if (!gst_caps_is_equal (self->preview_caps, new_caps)) {
+        gst_caps_replace (&self->preview_caps, new_caps);
+        gst_base_camera_src_setup_preview (self, new_caps);
+      } else {
+        GST_DEBUG_OBJECT (self, "New preview caps equal current preview caps");
+      }
+    }
+      break;
+    case PROP_PREVIEW_FILTER:
+      if (self->preview_filter)
+        gst_object_unref (self->preview_filter);
+      self->preview_filter = g_value_dup_object (value);
+      self->preview_filter_changed = TRUE;
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (self, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_base_camera_src_get_property (GObject * object,
+    guint prop_id, GValue * value, GParamSpec * pspec)
+{
+  GstBaseCameraSrc *self = GST_BASE_CAMERA_SRC (object);
+
+  switch (prop_id) {
+    case PROP_MODE:
+      g_value_set_enum (value, self->mode);
+      break;
+    case PROP_READY_FOR_CAPTURE:
+      g_value_set_boolean (value, !self->capturing);
+      break;
+    case PROP_ZOOM:
+      g_value_set_float (value, self->zoom);
+      break;
+    case PROP_MAX_ZOOM:
+      g_value_set_float (value, self->max_zoom);
+      break;
+    case PROP_POST_PREVIEW:
+      g_value_set_boolean (value, self->post_preview);
+      break;
+    case PROP_PREVIEW_CAPS:
+      if (self->preview_caps)
+        gst_value_set_caps (value, self->preview_caps);
+      break;
+    case PROP_PREVIEW_FILTER:
+      if (self->preview_filter)
+        g_value_set_object (value, self->preview_filter);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (self, prop_id, pspec);
+      break;
+  }
+}
+
+static gboolean
+construct_pipeline (GstBaseCameraSrc * self)
+{
+  GstBaseCameraSrcClass *bclass = GST_BASE_CAMERA_SRC_GET_CLASS (self);
+
+  if (bclass->construct_pipeline) {
+    if (!bclass->construct_pipeline (self)) {
+      GST_ERROR_OBJECT (self, "pipeline construction failed");
+      return FALSE;
+    }
+  }
+
+  return TRUE;
+}
+
+static gboolean
+setup_pipeline (GstBaseCameraSrc * self)
+{
+  GstBaseCameraSrcClass *bclass = GST_BASE_CAMERA_SRC_GET_CLASS (self);
+  if (bclass->setup_pipeline)
+    return bclass->setup_pipeline (self);
+  return TRUE;
+}
+
+static GstStateChangeReturn
+gst_base_camera_src_change_state (GstElement * element,
+    GstStateChange transition)
+{
+  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
+  GstBaseCameraSrc *self = GST_BASE_CAMERA_SRC (element);
+
+  GST_DEBUG_OBJECT (self, "%d -> %d",
+      GST_STATE_TRANSITION_CURRENT (transition),
+      GST_STATE_TRANSITION_NEXT (transition));
+
+  switch (transition) {
+    case GST_STATE_CHANGE_NULL_TO_READY:
+      if (!construct_pipeline (self))
+        return GST_STATE_CHANGE_FAILURE;
+
+      /* recreate the preview pipeline */
+      if (self->preview_pipeline && self->preview_filter_changed) {
+        gst_camerabin_destroy_preview_pipeline (self->preview_pipeline);
+        self->preview_pipeline = NULL;
+      }
+
+      if (self->preview_pipeline == NULL)
+        self->preview_pipeline =
+            gst_camerabin_create_preview_pipeline (GST_ELEMENT_CAST (self),
+            self->preview_filter);
+
+      g_assert (self->preview_pipeline != NULL);
+      self->preview_filter_changed = FALSE;
+      if (self->preview_caps) {
+        GST_DEBUG_OBJECT (self,
+            "Setting preview pipeline caps %" GST_PTR_FORMAT,
+            self->preview_caps);
+        gst_camerabin_preview_set_caps (self->preview_pipeline,
+            self->preview_caps);
+      }
+      break;
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      if (!setup_pipeline (self))
+        return GST_STATE_CHANGE_FAILURE;
+      gst_element_set_state (self->preview_pipeline->pipeline,
+          GST_STATE_PLAYING);
+      break;
+    default:
+      break;
+  }
+
+  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      gst_element_set_state (self->preview_pipeline->pipeline, GST_STATE_NULL);
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+}
+
+static void
+gst_base_camera_src_base_init (gpointer g_class)
+{
+  GstElementClass *gstelement_class = GST_ELEMENT_CLASS (g_class);
+
+  GST_DEBUG_CATEGORY_INIT (base_camera_src_debug, "base_camera_src", 0,
+      "Base camera src");
+
+  gst_element_class_set_details_simple (gstelement_class,
+      "Base class for camerabin src bin", "Source/Video",
+      "Abstracts capture device for camerabin2", "Rob Clark <rob@ti.com>");
+
+  gst_element_class_add_pad_template (gstelement_class,
+      gst_static_pad_template_get (&vfsrc_template));
+
+  gst_element_class_add_pad_template (gstelement_class,
+      gst_static_pad_template_get (&imgsrc_template));
+
+  gst_element_class_add_pad_template (gstelement_class,
+      gst_static_pad_template_get (&vidsrc_template));
+}
+
+static void
+gst_base_camera_src_class_init (GstBaseCameraSrcClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *gstelement_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gstelement_class = GST_ELEMENT_CLASS (klass);
+
+  gobject_class->dispose = gst_base_camera_src_dispose;
+  gobject_class->finalize = (GObjectFinalizeFunc) gst_base_camera_src_finalize;
+  gobject_class->set_property = gst_base_camera_src_set_property;
+  gobject_class->get_property = gst_base_camera_src_get_property;
+
+  g_object_class_install_property (gobject_class, PROP_MODE,
+      g_param_spec_enum ("mode", "Mode",
+          "The capture mode (still image capture or video recording)",
+          GST_TYPE_CAMERABIN_MODE, MODE_IMAGE,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class, PROP_ZOOM,
+      g_param_spec_float ("zoom", "Zoom",
+          "Digital zoom factor (e.g. 1.5 means 1.5x)", MIN_ZOOM, G_MAXFLOAT,
+          DEFAULT_ZOOM, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class, PROP_MAX_ZOOM,
+      g_param_spec_float ("max-zoom", "Maximum zoom level (note: may change "
+          "depending on resolution/implementation)",
+          "Digital zoom factor (e.g. 1.5 means 1.5x)", MIN_ZOOM, G_MAXFLOAT,
+          MAX_ZOOM, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstBaseCameraSrc:post-previews:
+   *
+   * When %TRUE, preview images should be posted to the bus when
+   * captures are made
+   */
+  g_object_class_install_property (gobject_class, PROP_POST_PREVIEW,
+      g_param_spec_boolean ("post-previews", "Post Previews",
+          "If capture preview images should be posted to the bus",
+          DEFAULT_POST_PREVIEW, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class, PROP_PREVIEW_CAPS,
+      g_param_spec_boxed ("preview-caps", "Preview caps",
+          "The caps of the preview image to be posted",
+          GST_TYPE_CAPS, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class, PROP_PREVIEW_FILTER,
+      g_param_spec_object ("preview-filter", "Preview filter",
+          "A custom preview filter to process preview image data",
+          GST_TYPE_ELEMENT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstBaseCameraSrc:ready-for-capture:
+   *
+   * When TRUE new capture can be prepared. If FALSE capturing is ongoing
+   * and starting a new capture immediately is not possible.
+   *
+   * Note that calling start-capture from the notify callback of this property
+   * will cause a deadlock. If you need to react like this on the notify
+   * function, please schedule a new thread to do it. If you're using glib's
+   * mainloop you can use g_idle_add() for example.
+   */
+  g_object_class_install_property (gobject_class, PROP_READY_FOR_CAPTURE,
+      g_param_spec_boolean ("ready-for-capture", "Ready for capture",
+          "Informs this element is ready for starting another capture",
+          TRUE, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+
+
+  /* Signals */
+  basecamerasrc_signals[START_CAPTURE_SIGNAL] =
+      g_signal_new ("start-capture",
+      G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+      G_STRUCT_OFFSET (GstBaseCameraSrcClass, private_start_capture),
+      NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
+
+  basecamerasrc_signals[STOP_CAPTURE_SIGNAL] =
+      g_signal_new ("stop-capture",
+      G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+      G_STRUCT_OFFSET (GstBaseCameraSrcClass, private_stop_capture),
+      NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
+
+  /* TODO these should be moved to a private struct
+   * that is allocated sequentially to the main struct as said at:
+   * http://library.gnome.org/devel/gobject/unstable/gobject-Type-Information.html#g-type-add-class-private
+   */
+  klass->private_start_capture = gst_base_camera_src_start_capture;
+  klass->private_stop_capture = gst_base_camera_src_stop_capture;
+
+  gstelement_class->change_state = gst_base_camera_src_change_state;
+}
+
+static void
+gst_base_camera_src_init (GstBaseCameraSrc * self,
+    GstBaseCameraSrcClass * klass)
+{
+  self->width = DEFAULT_WIDTH;
+  self->height = DEFAULT_HEIGHT;
+  self->zoom = DEFAULT_ZOOM;
+  self->max_zoom = MAX_ZOOM;
+  self->mode = MODE_IMAGE;
+
+  self->capturing = FALSE;
+  self->capturing_mutex = g_mutex_new ();
+
+  self->post_preview = DEFAULT_POST_PREVIEW;
+}
+
+void
+gst_base_camera_src_post_preview (GstBaseCameraSrc * self, GstBuffer * buf)
+{
+  if (self->post_preview) {
+    gst_camerabin_preview_pipeline_post (self->preview_pipeline, buf);
+  } else {
+    GST_DEBUG_OBJECT (self, "Previews not enabled, not posting");
+  }
+}
diff --git a/gst-libs/gst/basecamerabinsrc/gstbasecamerasrc.h b/gst-libs/gst/basecamerabinsrc/gstbasecamerasrc.h
new file mode 100644
index 0000000..c433b66
--- /dev/null
+++ b/gst-libs/gst/basecamerabinsrc/gstbasecamerasrc.h
@@ -0,0 +1,145 @@
+/*
+ * GStreamer
+ * Copyright (C) 2010 Texas Instruments, Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+
+#ifndef __GST_BASE_CAMERA_SRC_H__
+#define __GST_BASE_CAMERA_SRC_H__
+
+#include <gst/gst.h>
+#include <gst/gstbin.h>
+#include <gst/interfaces/photography.h>
+#include <gst/interfaces/colorbalance.h>
+#include "gstcamerabin-enum.h"
+#include "gstcamerabinpreview.h"
+
+G_BEGIN_DECLS
+#define GST_TYPE_BASE_CAMERA_SRC \
+  (gst_base_camera_src_get_type())
+#define GST_BASE_CAMERA_SRC(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_BASE_CAMERA_SRC,GstBaseCameraSrc))
+#define GST_BASE_CAMERA_SRC_GET_CLASS(obj) \
+  (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_BASE_CAMERA_SRC, GstBaseCameraSrcClass))
+#define GST_BASE_CAMERA_SRC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_BASE_CAMERA_SRC,GstBaseCameraSrcClass))
+#define GST_IS_BASE_CAMERA_SRC(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_BASE_CAMERA_SRC))
+#define GST_IS_BASE_CAMERA_SRC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_BASE_CAMERA_SRC))
+#define GST_BASE_CAMERA_SRC_CAST(obj) \
+  ((GstBaseCameraSrc *) (obj))
+GType gst_base_camera_src_get_type (void);
+
+typedef struct _GstBaseCameraSrc GstBaseCameraSrc;
+typedef struct _GstBaseCameraSrcClass GstBaseCameraSrcClass;
+
+#define GST_BASE_CAMERA_SRC_VIEWFINDER_PAD_NAME "vfsrc"
+#define GST_BASE_CAMERA_SRC_IMAGE_PAD_NAME "imgsrc"
+#define GST_BASE_CAMERA_SRC_VIDEO_PAD_NAME "vidsrc"
+
+#define GST_BASE_CAMERA_SRC_PREVIEW_MESSAGE_NAME "preview-image"
+
+/**
+ * GstBaseCameraSrc:
+ */
+struct _GstBaseCameraSrc
+{
+  GstBin parent;
+
+  GstCameraBinMode mode;
+
+  gboolean capturing;
+  GMutex *capturing_mutex;
+
+  /* Preview convert pipeline */
+  GstCaps *preview_caps;
+  gboolean post_preview;
+  GstElement *preview_filter;
+  GstCameraBinPreviewPipelineData *preview_pipeline;
+  gboolean preview_filter_changed;
+
+  /* Resolution of the buffers configured to camerabin */
+  gint width;
+  gint height;
+
+  gfloat zoom;
+  gfloat max_zoom;
+
+  gpointer _gst_reserved[GST_PADDING_LARGE];
+};
+
+
+/**
+ * GstBaseCameraSrcClass:
+ * @construct_pipeline: construct pipeline must be implemented by derived class
+ * @setup_pipeline: configure pipeline for the chosen settings
+ * @set_zoom: set the zoom
+ * @set_mode: set the mode
+ */
+struct _GstBaseCameraSrcClass
+{
+  GstBinClass parent;
+
+  /* construct pipeline must be implemented by derived class */
+  gboolean    (*construct_pipeline)  (GstBaseCameraSrc *self);
+
+  /* optional */
+  gboolean    (*setup_pipeline)      (GstBaseCameraSrc *self);
+
+  /* set the zoom */
+  void        (*set_zoom)            (GstBaseCameraSrc *self, gfloat zoom);
+
+  /* set the mode */
+  gboolean    (*set_mode)            (GstBaseCameraSrc *self,
+                                      GstCameraBinMode mode);
+
+  /* set preview caps */
+  gboolean    (*set_preview)         (GstBaseCameraSrc *self,
+                                      GstCaps *preview_caps);
+
+  /* */
+  GstCaps *   (*get_allowed_input_caps) (GstBaseCameraSrc * self);
+
+  void (*private_start_capture) (GstBaseCameraSrc * src);
+  void (*private_stop_capture) (GstBaseCameraSrc * src);
+  gboolean (*start_capture) (GstBaseCameraSrc * src);
+  void (*stop_capture) (GstBaseCameraSrc * src);
+
+  gpointer _gst_reserved[GST_PADDING_LARGE];
+};
+
+
+#define MIN_ZOOM 1.0f
+#define MAX_ZOOM 10.0f
+#define ZOOM_1X MIN_ZOOM
+
+GstPhotography * gst_base_camera_src_get_photography (GstBaseCameraSrc *self);
+GstColorBalance * gst_base_camera_src_get_color_balance (GstBaseCameraSrc *self);
+
+gboolean gst_base_camera_src_set_mode (GstBaseCameraSrc *self, GstCameraBinMode mode);
+void gst_base_camera_src_setup_zoom (GstBaseCameraSrc * self);
+void gst_base_camera_src_setup_preview (GstBaseCameraSrc * self, GstCaps * preview_caps);
+GstCaps * gst_base_camera_src_get_allowed_input_caps (GstBaseCameraSrc * self);
+void gst_base_camera_src_finish_capture (GstBaseCameraSrc *self);
+
+
+void gst_base_camera_src_post_preview (GstBaseCameraSrc *self, GstBuffer * buf);
+// XXX add methods to get/set img capture and vid capture caps..
+
+#endif /* __GST_BASE_CAMERA_SRC_H__ */
diff --git a/gst-libs/gst/basecamerabinsrc/gstcamerabin-enum.c b/gst-libs/gst/basecamerabinsrc/gstcamerabin-enum.c
new file mode 100644
index 0000000..ba09dcf
--- /dev/null
+++ b/gst-libs/gst/basecamerabinsrc/gstcamerabin-enum.c
@@ -0,0 +1,39 @@
+/*
+ * GStreamer
+ * Copyright (C) 2009 Nokia Corporation <multimedia@maemo.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "gstcamerabin-enum.h"
+
+GType
+gst_camerabin_mode_get_type (void)
+{
+  static GType gtype = 0;
+
+  if (gtype == 0) {
+    static const GEnumValue values[] = {
+      /* {MODE_PREVIEW, "Preview mode (should be default?)", "mode-preview"}, */
+      {MODE_IMAGE, "Still image capture (default)", "mode-image"},
+      {MODE_VIDEO, "Video recording", "mode-video"},
+      {0, NULL, NULL}
+    };
+
+    gtype = g_enum_register_static ("GstCameraBin2Mode", values);
+  }
+  return gtype;
+}
diff --git a/gst-libs/gst/basecamerabinsrc/gstcamerabin-enum.h b/gst-libs/gst/basecamerabinsrc/gstcamerabin-enum.h
new file mode 100644
index 0000000..590cb68
--- /dev/null
+++ b/gst-libs/gst/basecamerabinsrc/gstcamerabin-enum.h
@@ -0,0 +1,57 @@
+/*
+ * GStreamer
+ * Copyright (C) 2009 Nokia Corporation <multimedia@maemo.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_CAMERABIN_ENUM_H__
+#define __GST_CAMERABIN_ENUM_H__
+
+#include <gst/gst.h>
+
+G_BEGIN_DECLS
+
+#define DEFAULT_WIDTH 640
+#define DEFAULT_HEIGHT 480
+#define DEFAULT_CAPTURE_WIDTH 800
+#define DEFAULT_CAPTURE_HEIGHT 600
+#define DEFAULT_FPS_N 0         /* makes it use the default */
+#define DEFAULT_FPS_D 1
+#define DEFAULT_ZOOM MIN_ZOOM
+
+
+/**
+ * GstCameraBinMode:
+ * @MODE_IMAGE: image capture
+ * @MODE_VIDEO: video capture
+ *
+ * Capture mode to use.
+ */
+typedef enum
+{
+  /* MODE_PREVIEW = 0, No use for this */
+  MODE_IMAGE = 1,
+  MODE_VIDEO = 2,
+} GstCameraBinMode;
+
+
+#define GST_TYPE_CAMERABIN_MODE (gst_camerabin_mode_get_type ())
+GType gst_camerabin_mode_get_type (void);
+
+G_END_DECLS
+
+#endif                          /* #ifndef __GST_CAMERABIN_ENUM_H__ */
diff --git a/gst-libs/gst/basecamerabinsrc/gstcamerabinpreview.c b/gst-libs/gst/basecamerabinsrc/gstcamerabinpreview.c
new file mode 100644
index 0000000..6e223dc
--- /dev/null
+++ b/gst-libs/gst/basecamerabinsrc/gstcamerabinpreview.c
@@ -0,0 +1,226 @@
+/*
+ * GStreamer
+ * Copyright (C) 2008 Nokia Corporation <multimedia@maemo.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/**
+ * SECTION:camerabingeneral
+ * @short_description: helper functions for #GstCameraBin and it's modules
+ *
+ * Common helper functions for #GstCameraBin, #GstCameraBinImage and
+ * #GstCameraBinVideo.
+ *
+ */
+#include <gst/app/gstappsrc.h>
+#include <gst/app/gstappsink.h>
+#include "gstcamerabinpreview.h"
+#include "gstbasecamerasrc.h"
+
+static GstFlowReturn
+gst_camerabin_preview_pipeline_new_preroll (GstAppSink * appsink,
+    gpointer user_data)
+{
+  GstBuffer *buffer;
+
+  buffer = gst_app_sink_pull_preroll (appsink);
+  gst_buffer_unref (buffer);
+
+  return GST_FLOW_OK;
+}
+
+static GstFlowReturn
+gst_camerabin_preview_pipeline_new_buffer (GstAppSink * appsink,
+    gpointer user_data)
+{
+  GstBuffer *buffer;
+  GstStructure *s;
+  GstMessage *msg;
+  GstCameraBinPreviewPipelineData *data;
+
+  data = user_data;
+
+  buffer = gst_app_sink_pull_buffer (appsink);
+  s = gst_structure_new (GST_BASE_CAMERA_SRC_PREVIEW_MESSAGE_NAME,
+      "buffer", GST_TYPE_BUFFER, buffer, NULL);
+  gst_buffer_unref (buffer);
+  msg = gst_message_new_element (GST_OBJECT (data->element), s);
+
+  GST_DEBUG_OBJECT (data->element, "sending message with preview image");
+  if (gst_element_post_message (data->element, msg) == FALSE) {
+    GST_WARNING_OBJECT (data->element,
+        "This element has no bus, therefore no message sent!");
+  }
+
+  return GST_FLOW_OK;
+}
+
+/**
+ * gst_camerabin_create_preview_pipeline:
+ * @element: Owner of this pipeline
+ * @filter: Custom filter to process preview data (an extra ref is taken)
+ *
+ * Creates a new previewing pipeline that can receive buffers
+ * to be posted as camerabin preview messages for @element
+ *
+ * Returns: The newly created #GstCameraBinPreviewPipelineData
+ */
+GstCameraBinPreviewPipelineData *
+gst_camerabin_create_preview_pipeline (GstElement * element,
+    GstElement * filter)
+{
+  GstCameraBinPreviewPipelineData *data;
+  GstElement *csp;
+  GstElement *csp2;
+  GstElement *vscale;
+  gboolean added = FALSE;
+  GstAppSinkCallbacks callbacks = { 0, };
+
+  data = g_new (GstCameraBinPreviewPipelineData, 1);
+
+  data->pipeline = gst_pipeline_new ("preview-pipeline");
+  data->appsrc = gst_element_factory_make ("appsrc", "preview-appsrc");
+  data->capsfilter = gst_element_factory_make ("capsfilter",
+      "preview-capsfilter");
+  data->appsink = gst_element_factory_make ("appsink", "preview-appsink");
+  csp = gst_element_factory_make ("ffmpegcolorspace", "preview-csp0");
+  csp2 = gst_element_factory_make ("ffmpegcolorspace", "preview-csp1");
+  vscale = gst_element_factory_make ("videoscale", "preview-vscale");
+
+  if (!data->appsrc || !data->capsfilter || !data->appsink || !csp ||
+      !csp2 || !vscale) {
+    goto error;
+  }
+
+  gst_bin_add_many (GST_BIN (data->pipeline), data->appsrc, data->capsfilter,
+      data->appsink, csp, csp2, vscale, NULL);
+  if (filter)
+    gst_bin_add (GST_BIN (data->pipeline), gst_object_ref (filter));
+  added = TRUE;
+
+  if (filter) {
+    if (!gst_element_link_many (data->appsrc, filter, csp, vscale, csp2,
+            data->capsfilter, data->appsink, NULL))
+      goto error;
+  } else {
+    if (!gst_element_link_many (data->appsrc, csp, vscale, csp2,
+            data->capsfilter, data->appsink, NULL))
+      goto error;
+  }
+
+  callbacks.new_preroll = gst_camerabin_preview_pipeline_new_preroll;
+  callbacks.new_buffer = gst_camerabin_preview_pipeline_new_buffer;
+  gst_app_sink_set_callbacks ((GstAppSink *) data->appsink, &callbacks, data,
+      NULL);
+
+  g_object_set (data->appsink, "sync", FALSE, NULL);
+
+  data->element = element;
+  data->filter = filter;
+
+  return data;
+error:
+  GST_WARNING ("Failed to create camerabin's preview pipeline");
+  if (!added) {
+    if (csp)
+      gst_object_unref (csp);
+    if (csp2)
+      gst_object_unref (csp2);
+    if (vscale)
+      gst_object_unref (vscale);
+    if (data->appsrc)
+      gst_object_unref (data->appsrc);
+    if (data->capsfilter)
+      gst_object_unref (data->capsfilter);
+    if (data->appsink)
+      gst_object_unref (data->appsink);
+  }
+  gst_camerabin_destroy_preview_pipeline (data);
+  return NULL;
+}
+
+/**
+ * gst_camerabin_destroy_preview_pipeline:
+ * @preview: the #GstCameraBinPreviewPipelineData
+ *
+ * Frees a #GstCameraBinPreviewPipelineData
+ */
+void
+gst_camerabin_destroy_preview_pipeline (GstCameraBinPreviewPipelineData *
+    preview)
+{
+  if (preview->pipeline) {
+    gst_element_set_state (preview->pipeline, GST_STATE_NULL);
+    gst_object_unref (preview->pipeline);
+  }
+  g_free (preview);
+}
+
+/**
+ * gst_camerabin_preview_pipeline_post:
+ * @preview: the #GstCameraBinPreviewPipelineData
+ * @buffer: the buffer to be posted as a preview
+ *
+ * Converts the @buffer to the desired format and posts the preview
+ * message to the bus.
+ *
+ * Returns: %TRUE on success
+ */
+gboolean
+gst_camerabin_preview_pipeline_post (GstCameraBinPreviewPipelineData * preview,
+    GstBuffer * buffer)
+{
+  g_return_val_if_fail (preview != NULL, FALSE);
+  g_return_val_if_fail (preview->pipeline != NULL, FALSE);
+  g_return_val_if_fail (buffer, FALSE);
+
+  gst_app_src_push_buffer ((GstAppSrc *) preview->appsrc,
+      gst_buffer_ref (buffer));
+
+  return TRUE;
+}
+
+/**
+ * gst_camerabin_preview_set_caps:
+ * @preview: the #GstCameraBinPreviewPipelineData
+ * @caps: the #GstCaps to be set
+ *
+ * The caps that preview buffers should have when posted
+ * on the bus 
+ */
+void
+gst_camerabin_preview_set_caps (GstCameraBinPreviewPipelineData * preview,
+    GstCaps * caps)
+{
+  GstState state, pending;
+  GstStateChangeReturn ret;
+
+  g_return_if_fail (preview != NULL);
+
+  ret = gst_element_get_state (preview->pipeline, &state, &pending, 0);
+  if (ret == GST_STATE_CHANGE_FAILURE) {
+    /* make it try again */
+    state = GST_STATE_PLAYING;
+    pending = GST_STATE_VOID_PENDING;
+  }
+
+  gst_element_set_state (preview->pipeline, GST_STATE_NULL);
+  g_object_set (preview->capsfilter, "caps", caps, NULL);
+  if (pending != GST_STATE_VOID_PENDING)
+    state = pending;
+  gst_element_set_state (preview->pipeline, state);
+}
diff --git a/gst-libs/gst/basecamerabinsrc/gstcamerabinpreview.h b/gst-libs/gst/basecamerabinsrc/gstcamerabinpreview.h
new file mode 100644
index 0000000..b9df7a2
--- /dev/null
+++ b/gst-libs/gst/basecamerabinsrc/gstcamerabinpreview.h
@@ -0,0 +1,44 @@
+/*
+ * GStreamer
+ * Copyright (C) 2008 Nokia Corporation <multimedia@maemo.org>
+ * Copyright (C) 2010 Thiago Santos <thiago.sousa.santos@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __CAMERABIN_PREVIEW_H_
+#define __CAMERABIN_PREVIEW_H_
+
+#include <gst/gst.h>
+
+typedef struct
+{
+  GstElement *pipeline;
+
+  GstElement *appsrc;
+  GstElement *filter;
+  GstElement *capsfilter;
+  GstElement *appsink;
+
+  GstElement *element;
+} GstCameraBinPreviewPipelineData;
+
+GstCameraBinPreviewPipelineData *gst_camerabin_create_preview_pipeline (GstElement * element, GstElement * filter);
+void gst_camerabin_destroy_preview_pipeline (GstCameraBinPreviewPipelineData * preview);
+gboolean gst_camerabin_preview_pipeline_post (GstCameraBinPreviewPipelineData * preview, GstBuffer * buffer);
+void gst_camerabin_preview_set_caps (GstCameraBinPreviewPipelineData * preview, GstCaps * caps);
+
+#endif /* #ifndef __CAMERABIN_PREVIEW_H_ */
diff --git a/gst/camerabin2/Makefile.am b/gst/camerabin2/Makefile.am
new file mode 100644
index 0000000..9dbc019
--- /dev/null
+++ b/gst/camerabin2/Makefile.am
@@ -0,0 +1,31 @@
+plugin_LTLIBRARIES = libgstcamerabin2.la
+
+libgstcamerabin2_la_SOURCES = gstviewfinderbin.c \
+				gstimagecapturebin.c \
+				camerabingeneral.c \
+				gstwrappercamerabinsrc.c \
+				gstomxcamerabinsrc.c \
+				gstcamerabin2.c \
+				gstplugin.c
+
+libgstcamerabin2_la_CFLAGS = \
+	$(GST_PLUGINS_BAD_CFLAGS) \
+	$(GST_PLUGINS_BASE_CFLAGS) \
+	$(GST_BASE_CFLAGS) $(GST_CFLAGS) \
+	-DGST_USE_UNSTABLE_API
+
+libgstcamerabin2_la_LIBADD = \
+	$(top_builddir)/gst-libs/gst/interfaces/libgstphotography-$(GST_MAJORMINOR).la \
+	$(top_builddir)/gst-libs/gst/basecamerabinsrc/libgstbasecamerabinsrc-$(GST_MAJORMINOR).la \
+	$(GST_PLUGINS_BASE_LIBS) -lgstinterfaces-$(GST_MAJORMINOR) -lgsttag-$(GST_MAJORMINOR) -lgstapp-$(GST_MAJORMINOR) -lgstpbutils-$(GST_MAJORMINOR) \
+	$(GST_BASE_LIBS) $(GST_LIBS)
+
+libgstcamerabin2_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
+libgstcamerabin2_la_LIBTOOLFLAGS = --tag=disable-static
+
+noinst_HEADERS = gstviewfinderbin.h \
+		gstimagecapturebin.h \
+		camerabingeneral.h \
+		gstwrappercamerabinsrc.h \
+		gstomxcamerabinsrc.h \
+		gstcamerabin2.h
diff --git a/gst/camerabin2/PORTING b/gst/camerabin2/PORTING
new file mode 100644
index 0000000..c9b6dd8
--- /dev/null
+++ b/gst/camerabin2/PORTING
@@ -0,0 +1,22 @@
+This document lists the differenced between camerabin and camerabin2 from
+the API point of view and should be used to help on porting applications
+from camerabin to camerabin2.
+
+* Setting the location for the captures:
+camerabin requires that the path of the file to save the captures is set before
+each capture. Camerabin2 allows the application to use a multifilesink-like
+approach, the application can set a file with a '%d' marker, this marker
+will be automatically replaced by a number and be autoincremented after each
+capture.
+
+* Capture signals
+The signals were renamed from capture-start/stop to start/stop-capture as
+this is the usual naming on actions.
+
+* image-done
+In camerabin, image-done is a signal, in camerabin2, it is a bus message
+
+* video recording encoder/muxer
+In camerabin, video/audio encoder/muxer are selected by passing GstElements to
+camerabin properties. In camerabin2, a GstEncodingProfile is passed as a 
+property and encodebin manages to instantiate the elements for the format.
diff --git a/gst/camerabin2/camerabingeneral.c b/gst/camerabin2/camerabingeneral.c
new file mode 100644
index 0000000..f57d6e9
--- /dev/null
+++ b/gst/camerabin2/camerabingeneral.c
@@ -0,0 +1,278 @@
+/*
+ * GStreamer
+ * Copyright (C) 2008 Nokia Corporation <multimedia@maemo.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/**
+ * SECTION:camerabingeneral
+ * @short_description: helper functions for #GstCameraBin and it's modules
+ *
+ * Common helper functions for #GstCameraBin, #GstCameraBinImage and
+ * #GstCameraBinVideo.
+ *
+ */
+#include <string.h>
+
+#include <glib.h>
+#include <gst/basecamerabinsrc/gstbasecamerasrc.h>
+#include "camerabingeneral.h"
+
+/**
+ * gst_camerabin_add_element:
+ * @bin: add an element to this bin
+ * @new_elem: new element to be added
+ *
+ * Adds given element to given @bin. Looks for an unconnected src pad
+ * from the @bin and links the element to it.  Raises an error if adding
+ * or linking failed. Unrefs the element in the case of an error.
+ *
+ * Returns: %TRUE if adding and linking succeeded, %FALSE otherwise.
+ */
+gboolean
+gst_camerabin_add_element (GstBin * bin, GstElement * new_elem)
+{
+  return gst_camerabin_add_element_full (bin, NULL, new_elem, NULL);
+}
+
+/**
+ * gst_camerabin_add_element_full:
+ * @bin: add an element to this bin
+ * @srcpad:  src pad name, or NULL for any
+ * @new_elem: new element to be added
+ * @dstpad:  dst pad name, or NULL for any
+ *
+ * Adds given element to given @bin. Looks for an unconnected src pad
+ * (with name @srcpad, if specified) from the @bin and links the element
+ * to it.  Raises an error if adding or linking failed. Unrefs the element
+ * in the case of an error.
+ *
+ * Returns: %TRUE if adding and linking succeeded, %FALSE otherwise.
+ */
+gboolean
+gst_camerabin_add_element_full (GstBin * bin, const gchar * srcpad,
+    GstElement * new_elem, const gchar * dstpad)
+{
+  gboolean ret;
+
+  g_return_val_if_fail (bin, FALSE);
+  g_return_val_if_fail (new_elem, FALSE);
+
+  ret = gst_camerabin_try_add_element (bin, srcpad, new_elem, dstpad);
+
+  if (!ret) {
+    gchar *elem_name = gst_element_get_name (new_elem);
+    GST_ELEMENT_ERROR (bin, CORE, NEGOTIATION, (NULL),
+        ("linking %s failed", elem_name));
+    g_free (elem_name);
+    gst_object_unref (new_elem);
+  }
+
+  return ret;
+}
+
+/**
+ * gst_camerabin_try_add_element:
+ * @bin: tries adding an element to this bin
+ * @srcpad:  src pad name, or NULL for any
+ * @new_elem: new element to be added
+ * @dstpad:  dst pad name, or NULL for any
+ *
+ * Adds given element to given @bin. Looks for an unconnected src pad
+ * (with name @srcpad, if specified) from the @bin and links the element to
+ * it.
+ *
+ * Returns: %TRUE if adding and linking succeeded, %FALSE otherwise.
+ */
+gboolean
+gst_camerabin_try_add_element (GstBin * bin, const gchar * srcpad,
+    GstElement * new_elem, const gchar * dstpad)
+{
+  GstPad *bin_pad;
+  GstElement *bin_elem;
+  gboolean ret = TRUE;
+
+  g_return_val_if_fail (bin, FALSE);
+  g_return_val_if_fail (new_elem, FALSE);
+
+  /* Get pads for linking */
+  bin_pad = gst_bin_find_unlinked_pad (bin, GST_PAD_SRC);
+  /* Add to bin */
+  gst_bin_add (GST_BIN (bin), new_elem);
+  /* Link, if unconnected pad was found, otherwise just add it to bin */
+  if (bin_pad) {
+    GST_DEBUG_OBJECT (bin, "linking %s to %s:%s", GST_OBJECT_NAME (new_elem),
+        GST_DEBUG_PAD_NAME (bin_pad));
+    bin_elem = gst_pad_get_parent_element (bin_pad);
+    gst_object_unref (bin_pad);
+    if (!gst_element_link_pads (bin_elem, srcpad, new_elem, dstpad)) {
+      gst_object_ref (new_elem);
+      gst_bin_remove (bin, new_elem);
+      ret = FALSE;
+    }
+    gst_object_unref (bin_elem);
+  } else {
+    GST_INFO_OBJECT (bin, "no unlinked source pad in bin");
+  }
+
+  return ret;
+}
+
+/**
+ * gst_camerabin_create_and_add_element:
+ * @bin: tries adding an element to this bin
+ * @elem_name: name of the element to be created
+ * @instance_name: name of the instance of the element to be created
+ *
+ * Creates an element according to given name and
+ * adds it to given @bin. Looks for an unconnected src pad
+ * from the @bin and links the element to it.
+ *
+ * Returns: pointer to the new element if successful, NULL otherwise.
+ */
+GstElement *
+gst_camerabin_create_and_add_element (GstBin * bin, const gchar * elem_name,
+    const gchar * instance_name)
+{
+  GstElement *new_elem;
+
+  g_return_val_if_fail (bin, FALSE);
+  g_return_val_if_fail (elem_name, FALSE);
+
+  new_elem = gst_element_factory_make (elem_name, instance_name);
+  if (!new_elem) {
+    GST_ELEMENT_ERROR (bin, CORE, MISSING_PLUGIN, (NULL),
+        ("could not create \"%s\" element.", elem_name));
+  } else if (!gst_camerabin_add_element (bin, new_elem)) {
+    new_elem = NULL;
+  }
+
+  return new_elem;
+}
+
+/* try to change the state of an element. This function returns the element when
+ * the state change could be performed. When this function returns NULL an error
+ * occured and the element is unreffed if @unref is TRUE. */
+static GstElement *
+try_element (GstElement * bin, GstElement * element, gboolean unref)
+{
+  GstStateChangeReturn ret;
+
+  if (element) {
+    ret = gst_element_set_state (element, GST_STATE_READY);
+    if (ret == GST_STATE_CHANGE_FAILURE) {
+      GST_DEBUG_OBJECT (bin, "failed state change..");
+      gst_element_set_state (element, GST_STATE_NULL);
+      if (unref)
+        gst_object_unref (element);
+      element = NULL;
+    }
+  }
+  return element;
+}
+
+GstElement *
+gst_camerabin_setup_default_element (GstBin * bin, GstElement * user_elem,
+    const gchar * auto_elem_name, const gchar * default_elem_name,
+    const gchar * instance_name)
+{
+  GstElement *elem;
+
+  if (user_elem) {
+    GST_DEBUG_OBJECT (bin, "trying configured element");
+    elem = try_element (GST_ELEMENT_CAST (bin), user_elem, FALSE);
+  } else {
+    /* only try fallback if no specific sink was chosen */
+    GST_DEBUG_OBJECT (bin, "trying %s", auto_elem_name);
+    elem = gst_element_factory_make (auto_elem_name, instance_name);
+    elem = try_element (GST_ELEMENT_CAST (bin), elem, TRUE);
+    if (elem == NULL) {
+      /* if default sink from config.h is different then try it too */
+      if (strcmp (default_elem_name, auto_elem_name)) {
+        GST_DEBUG_OBJECT (bin, "trying %s", default_elem_name);
+        elem = gst_element_factory_make (default_elem_name, instance_name);
+        elem = try_element (GST_ELEMENT_CAST (bin), elem, TRUE);
+      }
+    }
+  }
+  return elem;
+}
+
+/**
+ * gst_camerabin_remove_elements_from_bin:
+ * @bin: removes all elements from this bin
+ *
+ * Removes all elements from this @bin.
+ */
+void
+gst_camerabin_remove_elements_from_bin (GstBin * bin)
+{
+  GstIterator *iter = NULL;
+  gpointer data = NULL;
+  GstElement *elem = NULL;
+  gboolean done = FALSE;
+
+  iter = gst_bin_iterate_elements (bin);
+  while (!done) {
+    switch (gst_iterator_next (iter, &data)) {
+      case GST_ITERATOR_OK:
+        elem = GST_ELEMENT (data);
+        gst_bin_remove (bin, elem);
+        gst_element_set_state (GST_ELEMENT (elem), GST_STATE_NULL);
+        /* Iterator increased the element refcount, so unref */
+        gst_object_unref (elem);
+        break;
+      case GST_ITERATOR_RESYNC:
+        gst_iterator_resync (iter);
+        break;
+      case GST_ITERATOR_ERROR:
+        GST_WARNING_OBJECT (bin, "error in iterating elements");
+        done = TRUE;
+        break;
+      case GST_ITERATOR_DONE:
+        done = TRUE;
+        break;
+    }
+  }
+  gst_iterator_free (iter);
+}
+
+/**
+ * gst_camerabin_drop_eos_probe:
+ * @pad: pad receiving the event
+ * @event: received event
+ * @u_data: not used
+ *
+ * Event probe that drop all eos events.
+ *
+ * Returns: FALSE to drop the event, TRUE otherwise
+ */
+gboolean
+gst_camerabin_drop_eos_probe (GstPad * pad, GstEvent * event, gpointer u_data)
+{
+  gboolean ret = TRUE;
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_EOS:
+      GST_DEBUG ("dropping eos in %s:%s", GST_DEBUG_PAD_NAME (pad));
+      ret = FALSE;
+      break;
+    default:
+      break;
+  }
+  return ret;
+}
diff --git a/gst/camerabin2/camerabingeneral.h b/gst/camerabin2/camerabingeneral.h
new file mode 100644
index 0000000..5c08154
--- /dev/null
+++ b/gst/camerabin2/camerabingeneral.h
@@ -0,0 +1,39 @@
+/*
+ * GStreamer
+ * Copyright (C) 2008 Nokia Corporation <multimedia@maemo.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __CAMERABIN_GENERAL_H_
+#define __CAMERABIN_GENERAL_H_
+
+#include <gst/gst.h>
+
+gboolean gst_camerabin_try_add_element (GstBin * bin, const gchar * srcpad, GstElement * new_elem, const gchar * dstpad);
+gboolean gst_camerabin_add_element (GstBin * bin, GstElement * new_elem);
+gboolean gst_camerabin_add_element_full (GstBin * bin, const gchar * srcpad, GstElement * new_elem, const gchar * dstpad);
+
+GstElement *gst_camerabin_create_and_add_element (GstBin * bin, const gchar * elem_name, const gchar * instance_name);
+
+GstElement * gst_camerabin_setup_default_element (GstBin * bin, GstElement *user_elem, const gchar *auto_elem_name, const gchar *default_elem_name,
+    const gchar * instance_elem_name);
+
+void gst_camerabin_remove_elements_from_bin (GstBin * bin);
+
+gboolean gst_camerabin_drop_eos_probe (GstPad * pad, GstEvent * event, gpointer u_data);
+
+#endif /* #ifndef __CAMERABIN_GENERAL_H_ */
diff --git a/gst/camerabin2/gstcamerabin2.c b/gst/camerabin2/gstcamerabin2.c
new file mode 100644
index 0000000..95a5aad
--- /dev/null
+++ b/gst/camerabin2/gstcamerabin2.c
@@ -0,0 +1,1651 @@
+/* GStreamer
+ * Copyright (C) 2010 Thiago Santos <thiago.sousa.santos@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+/**
+ * SECTION:element-gstcamerabin2
+ *
+ * The gstcamerabin2 element does FIXME stuff.
+ *
+ * Note that camerabin2 is still UNSTABLE, EXPERIMENTAL and under heavy
+ * development.
+ */
+
+/*
+ * Detail Topics:
+ *
+ * videorecordingbin state management (for now on called 'videobin')
+ * - The problem: keeping videobin state in sync with camerabin will make it
+ *                go to playing when it might not be used, causing its internal
+ *                filesink to open a file that might be left blank.
+ * - The solution: videobin state is set to locked upon its creation and camerabin
+ *                 registers itself on the notify::ready-for-capture of the src.
+ *                 Whenever the src readyness goes to FALSE it means a new
+ *                 capture is starting. If we are on video mode, the videobin's
+ *                 state is set to NULL and then PLAYING (in between this we
+ *                 have room to set the destination filename).
+ *                 There is no problem to leave it on playing after an EOS, so
+ *                 no action is taken on stop-capture.
+ *
+ * - TODO: What happens when an error pops?
+ * - TODO: Should we split properties in image/video variants? We already do so
+ *         for some of them
+ *
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+
+#include <gst/basecamerabinsrc/gstbasecamerasrc.h>
+#include "gstcamerabin2.h"
+
+#define GST_CAMERA_BIN_PROCESSING_INC(c)                                \
+{                                                                       \
+  gint bef = g_atomic_int_exchange_and_add (&c->processing_counter, 1); \
+  if (bef == 0)                                                         \
+    g_object_notify (G_OBJECT (c), "idle");                             \
+  GST_DEBUG_OBJECT ((c), "Processing counter incremented to: %d",       \
+      bef + 1);                                                         \
+}
+
+#define GST_CAMERA_BIN_PROCESSING_DEC(c)                                \
+{                                                                       \
+  if (g_atomic_int_dec_and_test (&c->processing_counter))               \
+    g_object_notify (G_OBJECT (c), "idle");                             \
+  GST_DEBUG_OBJECT ((c), "Processing counter decremented");             \
+}
+
+#define GST_CAMERA_BIN_RESET_PROCESSING_COUNTER(c)                      \
+{                                                                       \
+  g_atomic_int_set (&c->processing_counter, 0);                         \
+  GST_DEBUG_OBJECT ((c), "Processing counter reset");                   \
+}
+
+GST_DEBUG_CATEGORY_STATIC (gst_camera_bin_debug);
+#define GST_CAT_DEFAULT gst_camera_bin_debug
+
+/* prototypes */
+
+enum
+{
+  PROP_0,
+  PROP_MODE,
+  PROP_LOCATION,
+  PROP_CAMERA_SRC,
+  PROP_IMAGE_CAPTURE_SUPPORTED_CAPS,
+  PROP_VIDEO_CAPTURE_SUPPORTED_CAPS,
+  PROP_IMAGE_CAPTURE_CAPS,
+  PROP_VIDEO_CAPTURE_CAPS,
+  PROP_POST_PREVIEWS,
+  PROP_PREVIEW_CAPS,
+  PROP_VIDEO_ENCODING_PROFILE,
+  PROP_IMAGE_FILTER,
+  PROP_VIDEO_FILTER,
+  PROP_VIEWFINDER_FILTER,
+  PROP_PREVIEW_FILTER,
+  PROP_VIEWFINDER_SINK,
+  PROP_VIEWFINDER_SUPPORTED_CAPS,
+  PROP_VIEWFINDER_CAPS,
+  PROP_AUDIO_SRC,
+  PROP_MUTE_AUDIO,
+  PROP_AUDIO_CAPTURE_SUPPORTED_CAPS,
+  PROP_AUDIO_CAPTURE_CAPS,
+  PROP_ZOOM,
+  PROP_MAX_ZOOM,
+  PROP_IMAGE_ENCODING_PROFILE,
+  PROP_IDLE
+};
+
+enum
+{
+  /* action signals */
+  START_CAPTURE_SIGNAL,
+  STOP_CAPTURE_SIGNAL,
+  /* emit signals */
+  LAST_SIGNAL
+};
+static guint camerabin_signals[LAST_SIGNAL];
+
+#define DEFAULT_MODE MODE_IMAGE
+#define DEFAULT_VID_LOCATION "vid_%d"
+#define DEFAULT_IMG_LOCATION "img_%d"
+#define DEFAULT_POST_PREVIEWS TRUE
+#define DEFAULT_MUTE_AUDIO FALSE
+#define DEFAULT_IDLE TRUE
+
+#define DEFAULT_AUDIO_SRC "autoaudiosrc"
+
+/********************************
+ * Standard GObject boilerplate *
+ * and GObject types            *
+ ********************************/
+
+static GstPipelineClass *parent_class;
+static void gst_camera_bin_class_init (GstCameraBinClass * klass);
+static void gst_camera_bin_base_init (gpointer klass);
+static void gst_camera_bin_init (GstCameraBin * camera);
+static void gst_camera_bin_dispose (GObject * object);
+static void gst_camera_bin_finalize (GObject * object);
+
+static void gst_camera_bin_handle_message (GstBin * bin, GstMessage * message);
+
+GType
+gst_camera_bin_get_type (void)
+{
+  static GType gst_camera_bin_type = 0;
+  static const GInterfaceInfo camerabin_tagsetter_info = {
+    NULL,
+    NULL,
+    NULL,
+  };
+
+  if (!gst_camera_bin_type) {
+    static const GTypeInfo gst_camera_bin_info = {
+      sizeof (GstCameraBinClass),
+      (GBaseInitFunc) gst_camera_bin_base_init,
+      NULL,
+      (GClassInitFunc) gst_camera_bin_class_init,
+      NULL,
+      NULL,
+      sizeof (GstCameraBin),
+      0,
+      (GInstanceInitFunc) gst_camera_bin_init,
+      NULL
+    };
+
+    gst_camera_bin_type =
+        g_type_register_static (GST_TYPE_PIPELINE, "GstCameraBin2",
+        &gst_camera_bin_info, 0);
+
+    g_type_add_interface_static (gst_camera_bin_type, GST_TYPE_TAG_SETTER,
+        &camerabin_tagsetter_info);
+  }
+
+  return gst_camera_bin_type;
+}
+
+/* GObject class functions */
+static void gst_camera_bin_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec);
+static void gst_camera_bin_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec);
+
+/* Element class functions */
+static GstStateChangeReturn
+gst_camera_bin_change_state (GstElement * element, GstStateChange trans);
+
+
+/* Camerabin functions */
+
+static GstEvent *
+gst_camera_bin_new_event_renegotiate (void)
+{
+  return gst_event_new_custom (GST_EVENT_CUSTOM_BOTH,
+      gst_structure_new ("renegotiate", NULL));
+}
+
+static void
+gst_camera_bin_start_capture (GstCameraBin * camerabin)
+{
+  const GstTagList *taglist;
+
+  GST_DEBUG_OBJECT (camerabin, "Received start-capture");
+  GST_CAMERA_BIN_PROCESSING_INC (camerabin);
+
+  taglist = gst_tag_setter_get_tag_list (GST_TAG_SETTER (camerabin));
+  if (taglist) {
+    GstPad *active_pad;
+
+    GST_DEBUG_OBJECT (camerabin, "Pushing tags from application: %"
+        GST_PTR_FORMAT, taglist);
+
+    if (camerabin->mode == MODE_IMAGE) {
+      active_pad = gst_element_get_static_pad (camerabin->src,
+          GST_BASE_CAMERA_SRC_IMAGE_PAD_NAME);
+    } else {
+      active_pad = gst_element_get_static_pad (camerabin->src,
+          GST_BASE_CAMERA_SRC_VIDEO_PAD_NAME);
+    }
+
+    gst_pad_push_event (active_pad,
+        gst_event_new_tag (gst_tag_list_copy (taglist)));
+    gst_object_unref (active_pad);
+  }
+
+  if (camerabin->mode == MODE_VIDEO && camerabin->audio_src) {
+    gst_element_set_state (camerabin->audio_src, GST_STATE_READY);
+    /* need to reset eos status (pads could be flushing) */
+    gst_element_set_state (camerabin->audio_queue, GST_STATE_READY);
+    gst_element_set_state (camerabin->audio_convert, GST_STATE_READY);
+    gst_element_set_state (camerabin->audio_capsfilter, GST_STATE_READY);
+    gst_element_set_state (camerabin->audio_volume, GST_STATE_READY);
+
+    gst_element_sync_state_with_parent (camerabin->audio_queue);
+    gst_element_sync_state_with_parent (camerabin->audio_convert);
+    gst_element_sync_state_with_parent (camerabin->audio_capsfilter);
+    gst_element_sync_state_with_parent (camerabin->audio_volume);
+  }
+
+  g_signal_emit_by_name (camerabin->src, "start-capture", NULL);
+  if (camerabin->mode == MODE_VIDEO && camerabin->audio_src)
+    gst_element_set_state (camerabin->audio_src, GST_STATE_PLAYING);
+}
+
+static void
+gst_camera_bin_stop_capture (GstCameraBin * camerabin)
+{
+  GST_DEBUG_OBJECT (camerabin, "Received stop-capture");
+  if (camerabin->src)
+    g_signal_emit_by_name (camerabin->src, "stop-capture", NULL);
+
+  if (camerabin->mode == MODE_VIDEO && camerabin->audio_src) {
+    gst_element_send_event (camerabin->audio_src, gst_event_new_eos ());
+  }
+}
+
+static void
+gst_camera_bin_change_mode (GstCameraBin * camerabin, gint mode)
+{
+  if (mode == camerabin->mode)
+    return;
+
+  GST_DEBUG_OBJECT (camerabin, "Changing mode to %d", mode);
+
+  /* stop any ongoing capture */
+  gst_camera_bin_stop_capture (camerabin);
+  camerabin->mode = mode;
+  if (camerabin->src)
+    g_object_set (camerabin->src, "mode", mode, NULL);
+}
+
+static void
+gst_camera_bin_src_notify_readyforcapture (GObject * obj, GParamSpec * pspec,
+    gpointer user_data)
+{
+  GstCameraBin *camera = GST_CAMERA_BIN_CAST (user_data);
+  gboolean ready;
+
+  g_object_get (camera->src, "ready-for-capture", &ready, NULL);
+  if (!ready) {
+    gchar *location = NULL;
+
+    if (camera->mode == MODE_VIDEO) {
+      /* a video recording is about to start, we reset the videobin to clear eos/flushing state
+       * also need to clean the queue ! capsfilter before it */
+      gst_element_set_state (camera->video_encodebin, GST_STATE_NULL);
+      gst_element_set_state (camera->videosink, GST_STATE_NULL);
+      gst_element_set_state (camera->videobin_queue, GST_STATE_NULL);
+      gst_element_set_state (camera->videobin_capsfilter, GST_STATE_NULL);
+      location =
+          g_strdup_printf (camera->video_location, camera->video_index++);
+      GST_DEBUG_OBJECT (camera, "Switching videobin location to %s", location);
+      g_object_set (camera->videosink, "location", location, NULL);
+      g_free (location);
+      gst_element_set_state (camera->video_encodebin, GST_STATE_PLAYING);
+      gst_element_set_state (camera->videosink, GST_STATE_PLAYING);
+      gst_element_set_state (camera->videobin_capsfilter, GST_STATE_PLAYING);
+      gst_element_set_state (camera->videobin_queue, GST_STATE_PLAYING);
+    } else if (camera->mode == MODE_IMAGE) {
+      gst_element_set_state (camera->image_encodebin, GST_STATE_NULL);
+      gst_element_set_state (camera->imagesink, GST_STATE_NULL);
+      gst_element_set_state (camera->imagebin_queue, GST_STATE_NULL);
+      gst_element_set_state (camera->imagebin_capsfilter, GST_STATE_NULL);
+      GST_DEBUG_OBJECT (camera, "Switching imagebin location to %s", location);
+      g_object_set (camera->imagesink, "location", camera->image_location,
+          NULL);
+      gst_element_set_state (camera->image_encodebin, GST_STATE_PLAYING);
+      gst_element_set_state (camera->imagesink, GST_STATE_PLAYING);
+      gst_element_set_state (camera->imagebin_capsfilter, GST_STATE_PLAYING);
+      gst_element_set_state (camera->imagebin_queue, GST_STATE_PLAYING);
+    }
+
+  }
+}
+
+static void
+gst_camera_bin_dispose (GObject * object)
+{
+  GstCameraBin *camerabin = GST_CAMERA_BIN_CAST (object);
+
+  g_free (camerabin->image_location);
+  g_free (camerabin->video_location);
+
+  if (camerabin->src_capture_notify_id)
+    g_signal_handler_disconnect (camerabin->src,
+        camerabin->src_capture_notify_id);
+  if (camerabin->src)
+    gst_object_unref (camerabin->src);
+  if (camerabin->user_src)
+    gst_object_unref (camerabin->user_src);
+
+  if (camerabin->audio_src)
+    gst_object_unref (camerabin->audio_src);
+  if (camerabin->user_audio_src)
+    gst_object_unref (camerabin->user_audio_src);
+
+  if (camerabin->audio_capsfilter)
+    gst_object_unref (camerabin->audio_capsfilter);
+  if (camerabin->audio_queue)
+    gst_object_unref (camerabin->audio_queue);
+  if (camerabin->audio_convert)
+    gst_object_unref (camerabin->audio_convert);
+  if (camerabin->audio_volume)
+    gst_object_unref (camerabin->audio_volume);
+
+  if (camerabin->viewfinderbin)
+    gst_object_unref (camerabin->viewfinderbin);
+  if (camerabin->viewfinderbin_queue)
+    gst_object_unref (camerabin->viewfinderbin_queue);
+  if (camerabin->viewfinderbin_capsfilter)
+    gst_object_unref (camerabin->viewfinderbin_capsfilter);
+
+  if (camerabin->video_encodebin_signal_id)
+    g_signal_handler_disconnect (camerabin->video_encodebin,
+        camerabin->video_encodebin_signal_id);
+
+  if (camerabin->videosink_probe) {
+    GstPad *pad = gst_element_get_static_pad (camerabin->videosink, "sink");
+    gst_pad_remove_data_probe (pad, camerabin->videosink_probe);
+    gst_object_unref (pad);
+  }
+
+  if (camerabin->videosink)
+    gst_object_unref (camerabin->videosink);
+  if (camerabin->video_encodebin)
+    gst_object_unref (camerabin->video_encodebin);
+  if (camerabin->videobin_queue)
+    gst_object_unref (camerabin->videobin_queue);
+  if (camerabin->videobin_capsfilter)
+    gst_object_unref (camerabin->videobin_capsfilter);
+
+  if (camerabin->image_encodebin_signal_id)
+    g_signal_handler_disconnect (camerabin->image_encodebin,
+        camerabin->image_encodebin_signal_id);
+  if (camerabin->imagesink)
+    gst_object_unref (camerabin->imagesink);
+  if (camerabin->image_encodebin)
+    gst_object_unref (camerabin->image_encodebin);
+  if (camerabin->imagebin_queue)
+    gst_object_unref (camerabin->imagebin_queue);
+  if (camerabin->imagebin_capsfilter)
+    gst_object_unref (camerabin->imagebin_capsfilter);
+
+  if (camerabin->video_filter)
+    gst_object_unref (camerabin->video_filter);
+  if (camerabin->image_filter)
+    gst_object_unref (camerabin->image_filter);
+  if (camerabin->viewfinder_filter)
+    gst_object_unref (camerabin->viewfinder_filter);
+
+  if (camerabin->user_video_filter)
+    gst_object_unref (camerabin->user_video_filter);
+  if (camerabin->user_image_filter)
+    gst_object_unref (camerabin->user_image_filter);
+  if (camerabin->user_viewfinder_filter)
+    gst_object_unref (camerabin->user_viewfinder_filter);
+
+  if (camerabin->video_profile)
+    gst_encoding_profile_unref (camerabin->video_profile);
+  if (camerabin->image_profile)
+    gst_encoding_profile_unref (camerabin->image_profile);
+
+  if (camerabin->preview_caps)
+    gst_caps_replace (&camerabin->preview_caps, NULL);
+  if (camerabin->preview_filter) {
+    gst_object_unref (camerabin->preview_filter);
+    camerabin->preview_filter = NULL;
+  }
+
+  G_OBJECT_CLASS (parent_class)->dispose (object);
+}
+
+static void
+gst_camera_bin_finalize (GObject * object)
+{
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static void
+gst_camera_bin_base_init (gpointer g_class)
+{
+  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
+
+  gst_element_class_set_details_simple (element_class, "CameraBin2",
+      "Generic/Bin/Camera", "CameraBin2",
+      "Thiago Santos <thiago.sousa.santos@collabora.co.uk>");
+}
+
+static void
+gst_camera_bin_class_init (GstCameraBinClass * klass)
+{
+  GObjectClass *object_class;
+  GstElementClass *element_class;
+  GstBinClass *bin_class;
+
+  parent_class = g_type_class_peek_parent (klass);
+  object_class = G_OBJECT_CLASS (klass);
+  element_class = GST_ELEMENT_CLASS (klass);
+  bin_class = GST_BIN_CLASS (klass);
+
+  object_class->dispose = gst_camera_bin_dispose;
+  object_class->finalize = gst_camera_bin_finalize;
+  object_class->set_property = gst_camera_bin_set_property;
+  object_class->get_property = gst_camera_bin_get_property;
+
+  element_class->change_state = GST_DEBUG_FUNCPTR (gst_camera_bin_change_state);
+
+  bin_class->handle_message = gst_camera_bin_handle_message;
+
+  klass->start_capture = gst_camera_bin_start_capture;
+  klass->stop_capture = gst_camera_bin_stop_capture;
+
+  /**
+   * GstCameraBin:mode:
+   *
+   * Set the mode of operation: still image capturing or video recording.
+   */
+  g_object_class_install_property (object_class, PROP_MODE,
+      g_param_spec_enum ("mode", "Mode",
+          "The capture mode (still image capture or video recording)",
+          GST_TYPE_CAMERABIN_MODE, DEFAULT_MODE,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (object_class, PROP_LOCATION,
+      g_param_spec_string ("location", "Location",
+          "Location to save the captured files. A %d might be used on the"
+          "filename as a placeholder for a numeric index of the capture."
+          "Default for images is img_%d and vid_%d for videos",
+          DEFAULT_IMG_LOCATION, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (object_class, PROP_CAMERA_SRC,
+      g_param_spec_object ("camera-src", "Camera source",
+          "The camera source element to be used",
+          GST_TYPE_ELEMENT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (object_class, PROP_AUDIO_SRC,
+      g_param_spec_object ("audio-src", "Audio source",
+          "The audio source element to be used on video recordings",
+          GST_TYPE_ELEMENT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (object_class, PROP_MUTE_AUDIO,
+      g_param_spec_boolean ("mute", "Mute",
+          "If the audio recording should be muted. Note that this still "
+          "saves audio data to the resulting file, but they are silent. Use "
+          "a video-profile without audio to disable audio completely",
+          DEFAULT_MUTE_AUDIO, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (object_class,
+      PROP_AUDIO_CAPTURE_SUPPORTED_CAPS,
+      g_param_spec_boxed ("audio-capture-supported-caps",
+          "Audio capture supported caps",
+          "Formats supported for capturing audio represented as GstCaps",
+          GST_TYPE_CAPS, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (object_class,
+      PROP_AUDIO_CAPTURE_CAPS,
+      g_param_spec_boxed ("audio-capture-caps",
+          "Audio capture caps",
+          "Format to capture audio for video recording represented as GstCaps",
+          GST_TYPE_CAPS, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (object_class,
+      PROP_IMAGE_CAPTURE_SUPPORTED_CAPS,
+      g_param_spec_boxed ("image-capture-supported-caps",
+          "Image capture supported caps",
+          "Formats supported for capturing images represented as GstCaps",
+          GST_TYPE_CAPS, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (object_class,
+      PROP_VIDEO_CAPTURE_SUPPORTED_CAPS,
+      g_param_spec_boxed ("video-capture-supported-caps",
+          "Video capture supported caps",
+          "Formats supported for capturing videos represented as GstCaps",
+          GST_TYPE_CAPS, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (object_class,
+      PROP_IMAGE_CAPTURE_CAPS,
+      g_param_spec_boxed ("image-capture-caps",
+          "Image capture caps",
+          "Caps for image capture",
+          GST_TYPE_CAPS, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (object_class,
+      PROP_VIDEO_CAPTURE_CAPS,
+      g_param_spec_boxed ("video-capture-caps",
+          "Video capture caps",
+          "Caps for video capture",
+          GST_TYPE_CAPS, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (object_class, PROP_POST_PREVIEWS,
+      g_param_spec_boolean ("post-previews", "Post Previews",
+          "If capture preview images should be posted to the bus",
+          DEFAULT_POST_PREVIEWS, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (object_class, PROP_PREVIEW_CAPS,
+      g_param_spec_boxed ("preview-caps", "Preview caps",
+          "The caps of the preview image to be posted",
+          GST_TYPE_CAPS, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (object_class, PROP_VIDEO_ENCODING_PROFILE,
+      gst_param_spec_mini_object ("video-profile", "Video Profile",
+          "The GstEncodingProfile to use for video recording. Audio is enabled "
+          "when this profile supports audio.", GST_TYPE_ENCODING_PROFILE,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (object_class, PROP_IMAGE_FILTER,
+      g_param_spec_object ("image-filter", "Image filter",
+          "The element that will process captured image frames. (Should be"
+          " set on NULL state)",
+          GST_TYPE_ELEMENT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (object_class, PROP_VIDEO_FILTER,
+      g_param_spec_object ("video-filter", "Video filter",
+          "The element that will process captured video frames. (Should be"
+          " set on NULL state)",
+          GST_TYPE_ELEMENT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (object_class, PROP_VIEWFINDER_FILTER,
+      g_param_spec_object ("viewfinder-filter", "Viewfinder filter",
+          "The element that will process frames going to the viewfinder."
+          " (Should be set on NULL state)",
+          GST_TYPE_ELEMENT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (object_class, PROP_PREVIEW_FILTER,
+      g_param_spec_object ("preview-filter", "Preview filter",
+          "The element that will process preview buffers."
+          " (Should be set on NULL state)",
+          GST_TYPE_ELEMENT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (object_class, PROP_VIEWFINDER_SINK,
+      g_param_spec_object ("viewfinder-sink", "Viewfinder sink",
+          "The video sink of the viewfinder.",
+          GST_TYPE_ELEMENT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (object_class,
+      PROP_VIEWFINDER_CAPS,
+      g_param_spec_boxed ("viewfinder-caps",
+          "Viewfinder caps",
+          "Restricts the caps that can be used on the viewfinder",
+          GST_TYPE_CAPS, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (object_class, PROP_ZOOM,
+      g_param_spec_float ("zoom", "Zoom",
+          "Digital zoom factor (e.g. 1.5 means 1.5x)", MIN_ZOOM, MAX_ZOOM,
+          DEFAULT_ZOOM, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (object_class, PROP_MAX_ZOOM,
+      g_param_spec_float ("max-zoom", "Maximum zoom level (note: may change "
+          "depending on resolution/implementation)",
+          "Digital zoom factor (e.g. 1.5 means 1.5x)", MIN_ZOOM, G_MAXFLOAT,
+          MAX_ZOOM, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+
+  /* TODO
+   * Review before stable
+   * - We use a profile for video recording properties and here we have
+   *   elements for image capture. This is slightly inconsistent.
+   * - One problem with using encodebin for images here is how jifmux
+   *   autoplugging works. We need to give it a higher rank and fix its
+   *   caps (it has image/jpeg on sink and src pads). Preliminary tests
+   *   show that jifmux is picked if image/jpeg is the caps of a container
+   *   profile. So this could work.
+   * - There seems to be a problem with encodebin for images currently as
+   *   it autoplugs a videorate that ony starts outputing buffers after
+   *   getting the 2nd buffer.
+   */
+  g_object_class_install_property (object_class, PROP_IMAGE_ENCODING_PROFILE,
+      gst_param_spec_mini_object ("image-profile", "Image Profile",
+          "The GstEncodingProfile to use for image captures.",
+          GST_TYPE_ENCODING_PROFILE,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+
+  g_object_class_install_property (object_class, PROP_IDLE,
+      g_param_spec_boolean ("idle", "Idle",
+          "If camerabin2 is idle (not doing captures).", DEFAULT_IDLE,
+          G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+
+  /* TODO review before going stable
+   * We have viewfinder-supported-caps that returns the caps that the
+   * camerasrc can produce on its viewfinder pad, this could easily be
+   * confused with what the viewfinder-sink accepts.
+   *
+   * Do we want to add a 'viewfinder-sink-supported-caps' or maybe change
+   * the name of this property?
+   */
+  g_object_class_install_property (object_class,
+      PROP_VIEWFINDER_SUPPORTED_CAPS,
+      g_param_spec_boxed ("viewfinder-supported-caps",
+          "Camera source Viewfinder pad supported caps",
+          "The caps that the camera source can produce on the viewfinder pad",
+          GST_TYPE_CAPS, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstCameraBin::capture-start:
+   * @camera: the camera bin element
+   *
+   * Starts image capture or video recording depending on the Mode.
+   */
+  camerabin_signals[START_CAPTURE_SIGNAL] =
+      g_signal_new ("start-capture",
+      G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+      G_STRUCT_OFFSET (GstCameraBinClass, start_capture),
+      NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
+
+  /**
+   * GstCameraBin::capture-stop:
+   * @camera: the camera bin element
+   */
+  camerabin_signals[STOP_CAPTURE_SIGNAL] =
+      g_signal_new ("stop-capture",
+      G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+      G_STRUCT_OFFSET (GstCameraBinClass, stop_capture),
+      NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
+}
+
+static void
+gst_camera_bin_init (GstCameraBin * camera)
+{
+  camera->post_previews = DEFAULT_POST_PREVIEWS;
+  camera->mode = DEFAULT_MODE;
+  camera->video_location = g_strdup (DEFAULT_VID_LOCATION);
+  camera->image_location = g_strdup (DEFAULT_IMG_LOCATION);
+  camera->viewfinderbin = gst_element_factory_make ("viewfinderbin", "vf-bin");
+  camera->zoom = DEFAULT_ZOOM;
+  camera->max_zoom = MAX_ZOOM;
+
+  /* capsfilters are created here as we proxy their caps properties and
+   * this way we avoid having to store the caps while on NULL state to 
+   * set them later */
+  camera->videobin_capsfilter = gst_element_factory_make ("capsfilter",
+      "videobin-capsfilter");
+  camera->imagebin_capsfilter = gst_element_factory_make ("capsfilter",
+      "imagebin-capsfilter");
+  camera->viewfinderbin_capsfilter = gst_element_factory_make ("capsfilter",
+      "viewfinderbin-capsfilter");
+
+  gst_bin_add_many (GST_BIN (camera),
+      gst_object_ref (camera->viewfinderbin),
+      gst_object_ref (camera->videobin_capsfilter),
+      gst_object_ref (camera->imagebin_capsfilter),
+      gst_object_ref (camera->viewfinderbin_capsfilter), NULL);
+
+  /* these elements are only added if they are going to be used */
+  camera->audio_capsfilter = gst_element_factory_make ("capsfilter",
+      "audio-capsfilter");
+  camera->audio_volume = gst_element_factory_make ("volume", "audio-volume");
+}
+
+static void
+gst_image_capture_bin_post_image_done (GstCameraBin * camera,
+    const gchar * filename)
+{
+  GstMessage *msg;
+
+  g_return_if_fail (filename != NULL);
+
+  msg = gst_message_new_element (GST_OBJECT_CAST (camera),
+      gst_structure_new ("image-done", "filename", G_TYPE_STRING,
+          filename, NULL));
+
+  if (!gst_element_post_message (GST_ELEMENT_CAST (camera), msg))
+    GST_WARNING_OBJECT (camera, "Failed to post image-done message");
+}
+
+static void
+gst_camera_bin_handle_message (GstBin * bin, GstMessage * message)
+{
+  switch (GST_MESSAGE_TYPE (message)) {
+    case GST_MESSAGE_ELEMENT:{
+      const GstStructure *structure = gst_message_get_structure (message);
+      const gchar *filename;
+
+      if (gst_structure_has_name (structure, "GstMultiFileSink")) {
+        GST_CAMERA_BIN_PROCESSING_DEC (GST_CAMERA_BIN_CAST (bin));
+        filename = gst_structure_get_string (structure, "filename");
+        if (filename) {
+          gst_image_capture_bin_post_image_done (GST_CAMERA_BIN_CAST (bin),
+              filename);
+        }
+      }
+    }
+      break;
+    case GST_MESSAGE_WARNING:{
+      GError *err = NULL;
+      gchar *debug = NULL;
+
+      gst_message_parse_warning (message, &err, &debug);
+      if (err->domain == GST_RESOURCE_ERROR) {
+        /* some capturing failed */
+        GST_CAMERA_BIN_PROCESSING_DEC (GST_CAMERA_BIN_CAST (bin));
+      }
+    }
+      break;
+    case GST_MESSAGE_EOS:{
+      GstElement *src = GST_ELEMENT (GST_MESSAGE_SRC (message));
+      if (src == GST_CAMERA_BIN_CAST (bin)->videosink) {
+        GST_DEBUG_OBJECT (bin, "EOS from video branch");
+        GST_CAMERA_BIN_PROCESSING_DEC (GST_CAMERA_BIN_CAST (bin));
+      }
+    }
+      break;
+    default:
+      break;
+  }
+  if (message)
+    GST_BIN_CLASS (parent_class)->handle_message (bin, message);
+}
+
+/*
+ * Transforms:
+ * ... ! previous_element [ ! current_filter ] ! next_element ! ...
+ *
+ * into:
+ * ... ! previous_element [ ! new_filter ] ! next_element ! ...
+ *
+ * Where current_filter and new_filter might or might not be NULL
+ */
+static void
+gst_camera_bin_check_and_replace_filter (GstCameraBin * camera,
+    GstElement ** current_filter, GstElement * new_filter,
+    GstElement * previous_element, GstElement * next_element)
+{
+  if (*current_filter == new_filter) {
+    GST_DEBUG_OBJECT (camera, "Current filter is the same as the previous, "
+        "no switch needed.");
+    return;
+  }
+
+  GST_DEBUG_OBJECT (camera, "Replacing current filter (%s) with new filter "
+      "(%s)", *current_filter ? GST_ELEMENT_NAME (*current_filter) : "null",
+      new_filter ? GST_ELEMENT_NAME (new_filter) : "null");
+
+  if (*current_filter) {
+    gst_bin_remove (GST_BIN_CAST (camera), *current_filter);
+    gst_object_unref (*current_filter);
+    *current_filter = NULL;
+  } else {
+    /* unlink the pads */
+    gst_element_unlink (previous_element, next_element);
+  }
+
+  if (new_filter) {
+    *current_filter = gst_object_ref (new_filter);
+    gst_bin_add (GST_BIN_CAST (camera), gst_object_ref (new_filter));
+    gst_element_link_many (previous_element, new_filter, next_element, NULL);
+  } else {
+    gst_element_link (previous_element, next_element);
+  }
+}
+
+static void
+encodebin_element_added (GstElement * encodebin, GstElement * new_element,
+    GstCameraBin * camera)
+{
+  GstElementFactory *factory = gst_element_get_factory (new_element);
+
+  if (factory != NULL) {
+    if (strcmp (GST_PLUGIN_FEATURE_NAME (factory), "audiorate") == 0 ||
+        strcmp (GST_PLUGIN_FEATURE_NAME (factory), "videorate") == 0) {
+      g_object_set (new_element, "skip-to-first", TRUE, NULL);
+    }
+  }
+}
+
+#define VIDEO_PAD 1
+#define AUDIO_PAD 2
+static GstPad *
+encodebin_find_pad (GstCameraBin * camera, GstElement * encodebin,
+    gint pad_type)
+{
+  GstPad *pad = NULL;
+  GstIterator *iter;
+  gboolean done;
+
+  GST_DEBUG_OBJECT (camera, "Looking at encodebin pads, searching for %s pad",
+      VIDEO_PAD ? "video" : "audio");
+
+  iter = gst_element_iterate_sink_pads (encodebin);
+  done = FALSE;
+  while (!done) {
+    switch (gst_iterator_next (iter, (gpointer *) & pad)) {
+      case GST_ITERATOR_OK:
+        if (pad_type == VIDEO_PAD) {
+          if (strstr (GST_PAD_NAME (pad), "video") != NULL) {
+            GST_DEBUG_OBJECT (camera, "Found video pad %s", GST_PAD_NAME (pad));
+            done = TRUE;
+            break;
+          }
+        } else if (pad_type == AUDIO_PAD) {
+          if (strstr (GST_PAD_NAME (pad), "audio") != NULL) {
+            GST_DEBUG_OBJECT (camera, "Found audio pad %s", GST_PAD_NAME (pad));
+            done = TRUE;
+            break;
+          }
+        }
+        gst_object_unref (pad);
+        pad = NULL;
+        break;
+      case GST_ITERATOR_RESYNC:
+        gst_iterator_resync (iter);
+        break;
+      case GST_ITERATOR_ERROR:
+        pad = NULL;
+        done = TRUE;
+        break;
+      case GST_ITERATOR_DONE:
+        pad = NULL;
+        done = TRUE;
+        break;
+    }
+  }
+  gst_iterator_free (iter);
+
+  /* no static pad, try requesting one */
+  if (pad == NULL) {
+    GstElementClass *klass;
+    GstPadTemplate *tmpl;
+
+    GST_DEBUG_OBJECT (camera, "No pads found, trying to request one");
+
+    klass = GST_ELEMENT_GET_CLASS (encodebin);
+    tmpl = gst_element_class_get_pad_template (klass, pad_type == VIDEO_PAD ?
+        "video_%d" : "audio_%d");
+
+    pad = gst_element_request_pad (encodebin, tmpl, NULL, NULL);
+    GST_DEBUG_OBJECT (camera, "Got pad: %s", pad ? GST_PAD_NAME (pad) : "null");
+    gst_object_unref (tmpl);
+  }
+
+  return pad;
+}
+
+static gboolean
+gst_camera_bin_video_profile_has_audio (GstCameraBin * camera)
+{
+  const GList *list;
+
+  g_return_val_if_fail (camera->video_profile != NULL, FALSE);
+
+  if (GST_IS_ENCODING_VIDEO_PROFILE (camera->video_profile))
+    return FALSE;
+
+  for (list =
+      gst_encoding_container_profile_get_profiles ((GstEncodingContainerProfile
+              *) camera->video_profile); list; list = g_list_next (list)) {
+    GstEncodingProfile *profile = (GstEncodingProfile *) list->data;
+
+    if (GST_IS_ENCODING_AUDIO_PROFILE (profile))
+      return TRUE;
+  }
+
+  return FALSE;
+}
+
+static GstPadLinkReturn
+gst_camera_bin_link_encodebin (GstCameraBin * camera, GstElement * encodebin,
+    GstElement * element, gint padtype)
+{
+  GstPadLinkReturn ret;
+  GstPad *srcpad;
+  GstPad *sinkpad = NULL;
+
+  srcpad = gst_element_get_static_pad (element, "src");
+  sinkpad = encodebin_find_pad (camera, encodebin, padtype);
+
+  g_assert (srcpad != NULL);
+  g_assert (sinkpad != NULL);
+
+  ret = gst_pad_link (srcpad, sinkpad);
+  gst_object_unref (sinkpad);
+  gst_object_unref (srcpad);
+
+  return ret;
+}
+
+static void
+gst_camera_bin_src_notify_max_zoom_cb (GObject * self, GParamSpec * pspec,
+    gpointer user_data)
+{
+  GstCameraBin *camera = (GstCameraBin *) user_data;
+
+  g_object_get (self, "max-zoom", &camera->max_zoom, NULL);
+  GST_DEBUG_OBJECT (camera, "Max zoom updated to %f", camera->max_zoom);
+  g_object_notify (G_OBJECT (camera), "max-zoom");
+}
+
+/**
+ * gst_camera_bin_create_elements:
+ * @param camera: the #GstCameraBin
+ *
+ * Creates all elements inside #GstCameraBin
+ *
+ * Each of the pads on the camera source is linked as follows:
+ * .pad ! queue ! capsfilter ! correspondingbin
+ *
+ * Where 'correspondingbin' is the bin appropriate for
+ * the camera source pad.
+ */
+static gboolean
+gst_camera_bin_create_elements (GstCameraBin * camera)
+{
+  gboolean new_src = FALSE;
+  gboolean new_audio_src = FALSE;
+  gboolean has_audio;
+  gboolean profile_switched = FALSE;
+
+  if (!camera->elements_created) {
+    /* TODO check that elements created in _init were really created */
+    /* TODO add proper missing plugin error handling */
+
+    camera->video_encodebin = gst_element_factory_make ("encodebin", NULL);
+    camera->video_encodebin_signal_id =
+        g_signal_connect (camera->video_encodebin, "element-added",
+        (GCallback) encodebin_element_added, camera);
+
+    camera->videosink =
+        gst_element_factory_make ("filesink", "videobin-filesink");
+    g_object_set (camera->videosink, "async", FALSE, NULL);
+
+    /* audio elements */
+    camera->audio_queue = gst_element_factory_make ("queue", "audio-queue");
+    camera->audio_convert = gst_element_factory_make ("audioconvert",
+        "audio-convert");
+
+    if (camera->video_profile == NULL) {
+      GstEncodingContainerProfile *prof;
+      GstEncodingVideoProfile *video_prof;
+      GstCaps *caps;
+
+      caps = gst_caps_new_simple ("video/x-msvideo", NULL);
+      prof = gst_encoding_container_profile_new ("avi", "mpeg4+avi",
+          caps, NULL);
+      gst_caps_unref (caps);
+
+      caps = gst_caps_new_simple ("video/mpeg",
+          "mpegversion", G_TYPE_INT, 4,
+          "systemstream", G_TYPE_BOOLEAN, FALSE, NULL);
+      video_prof = gst_encoding_video_profile_new (caps, NULL, NULL, 1);
+      gst_encoding_video_profile_set_variableframerate (video_prof, TRUE);
+      if (!gst_encoding_container_profile_add_profile (prof,
+              (GstEncodingProfile *) video_prof)) {
+        GST_WARNING_OBJECT (camera, "Failed to create encoding profiles");
+      }
+      gst_caps_unref (caps);
+
+      camera->video_profile = (GstEncodingProfile *) prof;
+      camera->video_profile_switch = TRUE;
+    }
+
+    camera->image_encodebin = gst_element_factory_make ("encodebin", NULL);
+    camera->image_encodebin_signal_id =
+        g_signal_connect (camera->image_encodebin, "element-added",
+        (GCallback) encodebin_element_added, camera);
+
+    camera->imagesink =
+        gst_element_factory_make ("multifilesink", "imagebin-filesink");
+    g_object_set (camera->imagesink, "async", FALSE, "post-messages", TRUE,
+        NULL);
+
+    if (camera->image_profile == NULL) {
+      GstEncodingVideoProfile *prof;
+      GstCaps *caps;
+
+      caps = gst_caps_new_simple ("image/jpeg", NULL);
+      prof = gst_encoding_video_profile_new (caps, NULL, NULL, 1);
+      gst_encoding_video_profile_set_variableframerate (prof, TRUE);
+      gst_caps_unref (caps);
+
+      camera->image_profile = (GstEncodingProfile *) prof;
+      camera->image_profile_switch = TRUE;
+    }
+
+    camera->videobin_queue =
+        gst_element_factory_make ("queue", "videobin-queue");
+    camera->imagebin_queue =
+        gst_element_factory_make ("queue", "imagebin-queue");
+    camera->viewfinderbin_queue =
+        gst_element_factory_make ("queue", "viewfinderbin-queue");
+
+    g_object_set (camera->viewfinderbin_queue, "leaky", 2, "silent", TRUE,
+        NULL);
+    g_object_set (camera->imagebin_queue, "max-size-time", (guint64) 0,
+        "silent", TRUE, NULL);
+    g_object_set (camera->videobin_queue, "silent", TRUE, NULL);
+
+    gst_bin_add_many (GST_BIN_CAST (camera),
+        gst_object_ref (camera->video_encodebin),
+        gst_object_ref (camera->videosink),
+        gst_object_ref (camera->image_encodebin),
+        gst_object_ref (camera->imagesink),
+        gst_object_ref (camera->videobin_queue),
+        gst_object_ref (camera->imagebin_queue),
+        gst_object_ref (camera->viewfinderbin_queue), NULL);
+
+    /* Linking can be optimized TODO */
+    gst_element_link_many (camera->videobin_queue, camera->videobin_capsfilter,
+        NULL);
+    gst_element_link (camera->video_encodebin, camera->videosink);
+
+    gst_element_link_many (camera->imagebin_queue, camera->imagebin_capsfilter,
+        NULL);
+    gst_element_link (camera->image_encodebin, camera->imagesink);
+    gst_element_link_many (camera->viewfinderbin_queue,
+        camera->viewfinderbin_capsfilter, camera->viewfinderbin, NULL);
+    /*
+     * Video can't get into playing as its internal filesink will open
+     * a file for writing and leave it empty if unused.
+     *
+     * Its state is managed using the current mode and the source's
+     * ready-for-capture notify callback. When we are at video mode and
+     * the source's ready-for-capture goes to FALSE it means it is
+     * starting recording, so we should prepare the video bin.
+     */
+    gst_element_set_locked_state (camera->videosink, TRUE);
+    gst_element_set_locked_state (camera->imagesink, TRUE);
+
+    g_object_set (camera->videosink, "location", camera->video_location, NULL);
+    g_object_set (camera->imagesink, "location", camera->image_location, NULL);
+  }
+
+  if (camera->video_profile_switch) {
+    GST_DEBUG_OBJECT (camera, "Switching encodebin's profile");
+    g_object_set (camera->video_encodebin, "profile", camera->video_profile,
+        NULL);
+    gst_camera_bin_link_encodebin (camera, camera->video_encodebin,
+        camera->videobin_capsfilter, VIDEO_PAD);
+    camera->video_profile_switch = FALSE;
+
+    /* used to trigger relinking further down */
+    profile_switched = TRUE;
+  }
+
+  if (camera->image_profile_switch) {
+    GST_DEBUG_OBJECT (camera, "Switching encodebin's profile");
+    g_object_set (camera->image_encodebin, "profile", camera->image_profile,
+        NULL);
+    gst_camera_bin_link_encodebin (camera, camera->image_encodebin,
+        camera->imagebin_capsfilter, VIDEO_PAD);
+    camera->image_profile_switch = FALSE;
+  }
+
+  /* check if we need to replace the camera src */
+  if (camera->src) {
+    if (camera->user_src && camera->user_src != camera->src) {
+
+      if (camera->src_capture_notify_id)
+        g_signal_handler_disconnect (camera->src,
+            camera->src_capture_notify_id);
+
+      gst_bin_remove (GST_BIN_CAST (camera), camera->src);
+      gst_object_unref (camera->src);
+      camera->src = NULL;
+    }
+  }
+
+  if (!camera->src) {
+    if (camera->user_src) {
+      camera->src = gst_object_ref (camera->user_src);
+    } else {
+      camera->src = gst_element_factory_make ("omxcamerabinsrc", "camerasrc");
+    }
+
+    new_src = TRUE;
+  }
+
+  g_assert (camera->src != NULL);
+  g_object_set (camera->src, "mode", camera->mode, NULL);
+  if (camera->src) {
+    if (g_object_class_find_property (G_OBJECT_GET_CLASS (camera->src),
+            "preview-caps")) {
+      g_object_set (camera->src, "post-previews", camera->post_previews,
+          "preview-caps", camera->preview_caps, "preview-filter",
+          camera->preview_filter, NULL);
+    }
+    g_object_set (camera->src, "zoom", camera->zoom, NULL);
+    g_signal_connect (G_OBJECT (camera->src), "notify::max-zoom",
+        (GCallback) gst_camera_bin_src_notify_max_zoom_cb, camera);
+  }
+  if (new_src) {
+    gst_bin_add (GST_BIN_CAST (camera), gst_object_ref (camera->src));
+    camera->src_capture_notify_id = g_signal_connect (G_OBJECT (camera->src),
+        "notify::ready-for-capture",
+        G_CALLBACK (gst_camera_bin_src_notify_readyforcapture), camera);
+    gst_element_link_pads (camera->src, "vfsrc", camera->viewfinderbin_queue,
+        "sink");
+    gst_element_link_pads (camera->src, "imgsrc", camera->imagebin_queue,
+        "sink");
+    gst_element_link_pads (camera->src, "vidsrc", camera->videobin_queue,
+        "sink");
+  }
+
+  gst_camera_bin_check_and_replace_filter (camera, &camera->image_filter,
+      camera->user_image_filter, camera->imagebin_queue,
+      camera->imagebin_capsfilter);
+  gst_camera_bin_check_and_replace_filter (camera, &camera->video_filter,
+      camera->user_video_filter, camera->videobin_queue,
+      camera->videobin_capsfilter);
+  gst_camera_bin_check_and_replace_filter (camera, &camera->viewfinder_filter,
+      camera->user_viewfinder_filter, camera->viewfinderbin_queue,
+      camera->viewfinderbin_capsfilter);
+
+  /* check if we need to replace the camera audio src */
+  has_audio = gst_camera_bin_video_profile_has_audio (camera);
+  if (camera->audio_src) {
+    if ((camera->user_audio_src && camera->user_audio_src != camera->audio_src)
+        || !has_audio) {
+      gst_bin_remove (GST_BIN_CAST (camera), camera->audio_src);
+      gst_bin_remove (GST_BIN_CAST (camera), camera->audio_queue);
+      gst_bin_remove (GST_BIN_CAST (camera), camera->audio_volume);
+      gst_bin_remove (GST_BIN_CAST (camera), camera->audio_capsfilter);
+      gst_bin_remove (GST_BIN_CAST (camera), camera->audio_convert);
+      gst_object_unref (camera->audio_src);
+      camera->audio_src = NULL;
+    }
+  }
+
+  if (!camera->audio_src && has_audio) {
+    if (camera->user_audio_src) {
+      camera->audio_src = gst_object_ref (camera->user_audio_src);
+    } else {
+      camera->audio_src =
+          gst_element_factory_make (DEFAULT_AUDIO_SRC, "audiosrc");
+    }
+
+    gst_element_set_locked_state (camera->audio_src, TRUE);
+    new_audio_src = TRUE;
+  }
+
+  if (new_audio_src) {
+    gst_bin_add (GST_BIN_CAST (camera), gst_object_ref (camera->audio_src));
+    gst_bin_add (GST_BIN_CAST (camera), gst_object_ref (camera->audio_queue));
+    gst_bin_add (GST_BIN_CAST (camera), gst_object_ref (camera->audio_volume));
+    gst_bin_add (GST_BIN_CAST (camera),
+        gst_object_ref (camera->audio_capsfilter));
+    gst_bin_add (GST_BIN_CAST (camera), gst_object_ref (camera->audio_convert));
+
+    gst_element_link_many (camera->audio_src, camera->audio_queue,
+        camera->audio_volume,
+        camera->audio_capsfilter, camera->audio_convert, NULL);
+  }
+
+  if ((profile_switched && has_audio) || new_audio_src) {
+    gst_camera_bin_link_encodebin (camera, camera->video_encodebin,
+        camera->audio_convert, AUDIO_PAD);
+  }
+
+  camera->elements_created = TRUE;
+  return TRUE;
+}
+
+static GstStateChangeReturn
+gst_camera_bin_change_state (GstElement * element, GstStateChange trans)
+{
+  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
+  GstCameraBin *camera = GST_CAMERA_BIN_CAST (element);
+
+  switch (trans) {
+    case GST_STATE_CHANGE_NULL_TO_READY:
+      if (!gst_camera_bin_create_elements (camera)) {
+        return GST_STATE_CHANGE_FAILURE;
+      }
+      break;
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      GST_CAMERA_BIN_RESET_PROCESSING_COUNTER (camera);
+      break;
+    default:
+      break;
+  }
+
+  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, trans);
+
+  switch (trans) {
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      if (GST_STATE (camera->videosink) >= GST_STATE_PAUSED)
+        gst_element_set_state (camera->videosink, GST_STATE_READY);
+      if (GST_STATE (camera->imagesink) >= GST_STATE_PAUSED)
+        gst_element_set_state (camera->imagesink, GST_STATE_READY);
+      if (camera->audio_src && GST_STATE (camera->audio_src) >= GST_STATE_READY)
+        gst_element_set_state (camera->audio_src, GST_STATE_READY);
+
+      gst_tag_setter_reset_tags (GST_TAG_SETTER (camera));
+      GST_CAMERA_BIN_RESET_PROCESSING_COUNTER (camera);
+
+      /* explicitly set to READY as they might be outside of the bin */
+      gst_element_set_state (camera->audio_queue, GST_STATE_READY);
+      gst_element_set_state (camera->audio_volume, GST_STATE_READY);
+      gst_element_set_state (camera->audio_capsfilter, GST_STATE_READY);
+      gst_element_set_state (camera->audio_convert, GST_STATE_READY);
+      break;
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      gst_element_set_state (camera->videosink, GST_STATE_NULL);
+      gst_element_set_state (camera->imagesink, GST_STATE_NULL);
+      if (camera->audio_src)
+        gst_element_set_state (camera->audio_src, GST_STATE_NULL);
+
+      /* explicitly set to NULL as they might be outside of the bin */
+      gst_element_set_state (camera->audio_queue, GST_STATE_NULL);
+      gst_element_set_state (camera->audio_volume, GST_STATE_NULL);
+      gst_element_set_state (camera->audio_capsfilter, GST_STATE_NULL);
+      gst_element_set_state (camera->audio_convert, GST_STATE_NULL);
+
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+}
+
+static void
+gst_camera_bin_set_location (GstCameraBin * camera, const gchar * location)
+{
+  GST_DEBUG_OBJECT (camera, "Setting mode %d location to %s", camera->mode,
+      location);
+  if (camera->mode == MODE_IMAGE) {
+    g_free (camera->image_location);
+    camera->image_location = g_strdup (location);
+  } else {
+    g_free (camera->video_location);
+    camera->video_location = g_strdup (location);
+  }
+}
+
+static void
+gst_camera_bin_set_audio_src (GstCameraBin * camera, GstElement * src)
+{
+  GST_DEBUG_OBJECT (GST_OBJECT (camera),
+      "Setting audio source %" GST_PTR_FORMAT, src);
+
+  if (camera->user_audio_src)
+    g_object_unref (camera->user_audio_src);
+
+  if (src)
+    g_object_ref (src);
+  camera->user_audio_src = src;
+}
+
+static void
+gst_camera_bin_set_camera_src (GstCameraBin * camera, GstElement * src)
+{
+  GST_DEBUG_OBJECT (GST_OBJECT (camera),
+      "Setting camera source %" GST_PTR_FORMAT, src);
+
+  if (camera->user_src)
+    g_object_unref (camera->user_src);
+
+  if (src)
+    g_object_ref (src);
+  camera->user_src = src;
+}
+
+static void
+gst_camera_bin_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstCameraBin *camera = GST_CAMERA_BIN_CAST (object);
+
+  switch (prop_id) {
+    case PROP_MODE:
+      gst_camera_bin_change_mode (camera, g_value_get_enum (value));
+      break;
+    case PROP_LOCATION:
+      gst_camera_bin_set_location (camera, g_value_get_string (value));
+      break;
+    case PROP_CAMERA_SRC:
+      gst_camera_bin_set_camera_src (camera, g_value_get_object (value));
+      break;
+    case PROP_AUDIO_SRC:
+      gst_camera_bin_set_audio_src (camera, g_value_get_object (value));
+      break;
+    case PROP_MUTE_AUDIO:
+      g_object_set (camera->audio_volume, "mute", g_value_get_boolean (value),
+          NULL);
+      break;
+    case PROP_AUDIO_CAPTURE_CAPS:{
+      GST_DEBUG_OBJECT (camera,
+          "Setting audio capture caps to %" GST_PTR_FORMAT,
+          gst_value_get_caps (value));
+
+      g_object_set (camera->audio_capsfilter, "caps",
+          gst_value_get_caps (value), NULL);
+    }
+      break;
+    case PROP_IMAGE_CAPTURE_CAPS:{
+      GstPad *pad = NULL;
+
+      if (camera->src)
+        pad =
+            gst_element_get_static_pad (camera->src,
+            GST_BASE_CAMERA_SRC_IMAGE_PAD_NAME);
+
+      GST_DEBUG_OBJECT (camera,
+          "Setting image capture caps to %" GST_PTR_FORMAT,
+          gst_value_get_caps (value));
+
+      /* set the capsfilter caps and notify the src to renegotiate */
+      g_object_set (camera->imagebin_capsfilter, "caps",
+          gst_value_get_caps (value), NULL);
+      if (pad) {
+        GST_DEBUG_OBJECT (camera, "Pushing renegotiate on %s",
+            GST_PAD_NAME (pad));
+        GST_PAD_EVENTFUNC (pad) (pad, gst_camera_bin_new_event_renegotiate ());
+        gst_object_unref (pad);
+      }
+    }
+      break;
+    case PROP_VIDEO_CAPTURE_CAPS:{
+      GstPad *pad = NULL;
+
+      if (camera->src)
+        pad =
+            gst_element_get_static_pad (camera->src,
+            GST_BASE_CAMERA_SRC_VIDEO_PAD_NAME);
+
+      GST_DEBUG_OBJECT (camera,
+          "Setting video capture caps to %" GST_PTR_FORMAT,
+          gst_value_get_caps (value));
+
+      /* set the capsfilter caps and notify the src to renegotiate */
+      g_object_set (camera->videobin_capsfilter, "caps",
+          gst_value_get_caps (value), NULL);
+      if (pad) {
+        GST_DEBUG_OBJECT (camera, "Pushing renegotiate on %s",
+            GST_PAD_NAME (pad));
+        GST_PAD_EVENTFUNC (pad) (pad, gst_camera_bin_new_event_renegotiate ());
+        gst_object_unref (pad);
+      }
+    }
+      break;
+    case PROP_VIEWFINDER_CAPS:{
+      GstPad *pad = NULL;
+
+      if (camera->src)
+        pad =
+            gst_element_get_static_pad (camera->src,
+            GST_BASE_CAMERA_SRC_VIEWFINDER_PAD_NAME);
+
+      GST_DEBUG_OBJECT (camera,
+          "Setting viewfinder capture caps to %" GST_PTR_FORMAT,
+          gst_value_get_caps (value));
+
+      /* set the capsfilter caps and notify the src to renegotiate */
+      g_object_set (camera->viewfinderbin_capsfilter, "caps",
+          gst_value_get_caps (value), NULL);
+      if (pad) {
+        GST_DEBUG_OBJECT (camera, "Pushing renegotiate on %s",
+            GST_PAD_NAME (pad));
+        GST_PAD_EVENTFUNC (pad) (pad, gst_camera_bin_new_event_renegotiate ());
+        gst_object_unref (pad);
+      }
+    }
+      break;
+    case PROP_POST_PREVIEWS:
+      camera->post_previews = g_value_get_boolean (value);
+      if (camera->src
+          && g_object_class_find_property (G_OBJECT_GET_CLASS (camera->src),
+              "post-previews"))
+        g_object_set (camera->src, "post-previews", camera->post_previews,
+            NULL);
+      break;
+    case PROP_PREVIEW_CAPS:
+      gst_caps_replace (&camera->preview_caps,
+          (GstCaps *) gst_value_get_caps (value));
+      if (camera->src
+          && g_object_class_find_property (G_OBJECT_GET_CLASS (camera->src),
+              "preview-caps"))
+        g_object_set (camera->src, "preview-caps", camera->preview_caps, NULL);
+      break;
+    case PROP_VIDEO_ENCODING_PROFILE:
+      if (camera->video_profile)
+        gst_encoding_profile_unref (camera->video_profile);
+      camera->video_profile =
+          (GstEncodingProfile *) gst_value_dup_mini_object (value);
+      camera->video_profile_switch = TRUE;
+      break;
+    case PROP_IMAGE_FILTER:
+      if (camera->user_image_filter)
+        g_object_unref (camera->user_image_filter);
+
+      camera->user_image_filter = g_value_dup_object (value);
+      break;
+    case PROP_VIDEO_FILTER:
+      if (camera->user_video_filter)
+        g_object_unref (camera->user_video_filter);
+
+      camera->user_video_filter = g_value_dup_object (value);
+      break;
+    case PROP_VIEWFINDER_FILTER:
+      if (camera->user_viewfinder_filter)
+        g_object_unref (camera->user_viewfinder_filter);
+
+      camera->user_viewfinder_filter = g_value_dup_object (value);
+      break;
+    case PROP_PREVIEW_FILTER:
+      if (camera->preview_filter)
+        g_object_unref (camera->preview_filter);
+
+      camera->preview_filter = g_value_dup_object (value);
+      if (camera->src
+          && g_object_class_find_property (G_OBJECT_GET_CLASS (camera->src),
+              "preview-filter"))
+        g_object_set (camera->src, "preview-filter", camera->preview_filter,
+            NULL);
+      break;
+    case PROP_VIEWFINDER_SINK:
+      g_object_set (camera->viewfinderbin, "video-sink",
+          g_value_get_object (value), NULL);
+      break;
+    case PROP_ZOOM:
+      camera->zoom = g_value_get_float (value);
+      /* limit to max-zoom */
+      if (camera->zoom > camera->max_zoom) {
+        GST_DEBUG_OBJECT (camera, "Clipping zoom %f to max-zoom %f",
+            camera->zoom, camera->max_zoom);
+        camera->zoom = camera->max_zoom;
+      }
+      if (camera->src)
+        g_object_set (camera->src, "zoom", camera->zoom, NULL);
+      break;
+    case PROP_IMAGE_ENCODING_PROFILE:
+      if (camera->image_profile)
+        gst_encoding_profile_unref (camera->image_profile);
+      camera->image_profile =
+          (GstEncodingProfile *) gst_value_dup_mini_object (value);
+      camera->image_profile_switch = TRUE;
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_camera_bin_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstCameraBin *camera = GST_CAMERA_BIN_CAST (object);
+
+  switch (prop_id) {
+    case PROP_MODE:
+      g_value_set_enum (value, camera->mode);
+      break;
+    case PROP_LOCATION:
+      if (camera->mode == MODE_VIDEO) {
+        g_value_set_string (value, camera->video_location);
+      } else {
+        g_value_set_string (value, camera->image_location);
+      }
+      break;
+    case PROP_CAMERA_SRC:
+      g_value_set_object (value, camera->src);
+      break;
+    case PROP_AUDIO_SRC:
+      g_value_set_object (value, camera->audio_src);
+      break;
+    case PROP_MUTE_AUDIO:{
+      gboolean mute;
+
+      g_object_get (camera->audio_volume, "mute", &mute, NULL);
+      g_value_set_boolean (value, mute);
+      break;
+    }
+    case PROP_AUDIO_CAPTURE_SUPPORTED_CAPS:
+    case PROP_VIDEO_CAPTURE_SUPPORTED_CAPS:
+    case PROP_VIEWFINDER_SUPPORTED_CAPS:
+    case PROP_IMAGE_CAPTURE_SUPPORTED_CAPS:{
+      GstPad *pad;
+      GstElement *element;
+      GstCaps *caps;
+      const gchar *padname;
+
+      if (prop_id == PROP_VIDEO_CAPTURE_SUPPORTED_CAPS) {
+        element = camera->src;
+        padname = GST_BASE_CAMERA_SRC_VIDEO_PAD_NAME;
+      } else if (prop_id == PROP_IMAGE_CAPTURE_SUPPORTED_CAPS) {
+        element = camera->src;
+        padname = GST_BASE_CAMERA_SRC_IMAGE_PAD_NAME;
+      } else if (prop_id == PROP_VIEWFINDER_SUPPORTED_CAPS) {
+        element = camera->src;
+        padname = GST_BASE_CAMERA_SRC_VIEWFINDER_PAD_NAME;
+      } else {
+        element = camera->audio_src;
+        padname = "src";
+      }
+
+      if (element) {
+        pad = gst_element_get_static_pad (element, padname);
+
+        g_assert (pad != NULL);
+
+        /* TODO not sure if we want get_caps or get_allowed_caps to already
+         * consider the full pipeline scenario and avoid picking a caps that
+         * won't negotiate. Need to take care on the special case of the
+         * pad being unlinked.
+         */
+        caps = gst_pad_get_caps_reffed (pad);
+        if (caps) {
+          gst_value_set_caps (value, caps);
+          gst_caps_unref (caps);
+        }
+
+        gst_object_unref (pad);
+      } else {
+        GST_DEBUG_OBJECT (camera, "Source not created, can't get "
+            "supported caps");
+      }
+    }
+      break;
+    case PROP_AUDIO_CAPTURE_CAPS:{
+      GstCaps *caps = NULL;
+      g_object_get (camera->audio_capsfilter, "caps", &caps, NULL);
+      gst_value_set_caps (value, caps);
+      gst_caps_unref (caps);
+    }
+      break;
+    case PROP_IMAGE_CAPTURE_CAPS:{
+      GstCaps *caps = NULL;
+      g_object_get (camera->imagebin_capsfilter, "caps", &caps, NULL);
+      gst_value_set_caps (value, caps);
+      gst_caps_unref (caps);
+    }
+      break;
+    case PROP_VIDEO_CAPTURE_CAPS:{
+      GstCaps *caps = NULL;
+      g_object_get (camera->videobin_capsfilter, "caps", &caps, NULL);
+      gst_value_set_caps (value, caps);
+      gst_caps_unref (caps);
+    }
+      break;
+    case PROP_VIEWFINDER_CAPS:{
+      GstCaps *caps = NULL;
+      g_object_get (camera->viewfinderbin_capsfilter, "caps", &caps, NULL);
+      gst_value_set_caps (value, caps);
+      gst_caps_unref (caps);
+    }
+      break;
+    case PROP_POST_PREVIEWS:
+      g_value_set_boolean (value, camera->post_previews);
+      break;
+    case PROP_PREVIEW_CAPS:
+      if (camera->preview_caps)
+        gst_value_set_caps (value, camera->preview_caps);
+      break;
+    case PROP_VIDEO_ENCODING_PROFILE:
+      if (camera->video_profile) {
+        gst_value_set_mini_object (value,
+            (GstMiniObject *) camera->video_profile);
+      }
+      break;
+    case PROP_VIDEO_FILTER:
+      if (camera->video_filter)
+        g_value_set_object (value, camera->video_filter);
+      break;
+    case PROP_IMAGE_FILTER:
+      if (camera->image_filter)
+        g_value_set_object (value, camera->image_filter);
+      break;
+    case PROP_VIEWFINDER_FILTER:
+      if (camera->viewfinder_filter)
+        g_value_set_object (value, camera->viewfinder_filter);
+      break;
+    case PROP_PREVIEW_FILTER:
+      if (camera->preview_filter)
+        g_value_set_object (value, camera->preview_filter);
+      break;
+    case PROP_VIEWFINDER_SINK:{
+      GstElement *sink;
+
+      g_object_get (camera->viewfinderbin, "video-sink", &sink, NULL);
+      g_value_take_object (value, sink);
+      break;
+    }
+    case PROP_ZOOM:
+      g_value_set_float (value, camera->zoom);
+      break;
+    case PROP_MAX_ZOOM:
+      g_value_set_float (value, camera->max_zoom);
+      break;
+    case PROP_IMAGE_ENCODING_PROFILE:
+      if (camera->image_profile) {
+        gst_value_set_mini_object (value,
+            (GstMiniObject *) camera->image_profile);
+      }
+      break;
+    case PROP_IDLE:
+      g_value_set_boolean (value,
+          g_atomic_int_get (&camera->processing_counter) == 0);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+gboolean
+gst_camera_bin_plugin_init (GstPlugin * plugin)
+{
+  GST_DEBUG_CATEGORY_INIT (gst_camera_bin_debug, "camerabin2", 0, "CameraBin2");
+
+  return gst_element_register (plugin, "camerabin2", GST_RANK_NONE,
+      gst_camera_bin_get_type ());
+}
diff --git a/gst/camerabin2/gstcamerabin2.h b/gst/camerabin2/gstcamerabin2.h
new file mode 100644
index 0000000..59e3723
--- /dev/null
+++ b/gst/camerabin2/gstcamerabin2.h
@@ -0,0 +1,113 @@
+/* GStreamer
+ * Copyright (C) 2010 Thiago Santos <thiago.sousa.santos@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+#ifndef _GST_CAMERA_BIN_H_
+#define _GST_CAMERA_BIN_H_
+
+#include <gst/gst.h>
+#include <gst/pbutils/encoding-profile.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_CAMERA_BIN   (gst_camera_bin_get_type())
+#define GST_CAMERA_BIN(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CAMERA_BIN,GstCameraBin))
+#define GST_CAMERA_BIN_CAST(obj)   ((GstCameraBin *) obj)
+#define GST_CAMERA_BIN_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CAMERA_BIN,GstCameraBinClass))
+#define GST_IS_CAMERA_BIN(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CAMERA_BIN))
+#define GST_IS_CAMERA_BIN_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CAMERA_BIN))
+
+typedef struct _GstCameraBin GstCameraBin;
+typedef struct _GstCameraBinClass GstCameraBinClass;
+
+struct _GstCameraBin
+{
+  GstPipeline pipeline;
+
+  GstElement *src;
+  GstElement *user_src;
+  gulong src_capture_notify_id;
+
+  GstElement *video_encodebin;
+  gulong video_encodebin_signal_id;
+  GstElement *videosink;
+  gulong videosink_probe;
+  GstElement *videobin_queue;
+  GstElement *videobin_capsfilter;
+
+  GstElement *viewfinderbin;
+  GstElement *viewfinderbin_queue;
+  GstElement *viewfinderbin_capsfilter;
+
+  GstElement *image_encodebin;
+  gulong image_encodebin_signal_id;
+  GstElement *imagesink;
+  GstElement *imagebin_queue;
+  GstElement *imagebin_capsfilter;
+
+  GstElement *video_filter;
+  GstElement *image_filter;
+  GstElement *viewfinder_filter;
+  GstElement *user_video_filter;
+  GstElement *user_image_filter;
+  GstElement *user_viewfinder_filter;
+
+  GstElement *audio_src;
+  GstElement *user_audio_src;
+  GstElement *audio_queue;
+  GstElement *audio_volume;
+  GstElement *audio_capsfilter;
+  GstElement *audio_convert;
+
+  gint processing_counter; /* atomic int */
+
+  /* Index of the auto incrementing file index for video recordings */
+  gint video_index;
+
+  gboolean video_profile_switch;
+  gboolean image_profile_switch;
+
+  /* properties */
+  gint mode;
+  gchar *video_location;
+  gchar *image_location;
+  gboolean post_previews;
+  GstCaps *preview_caps;
+  GstElement *preview_filter;
+  GstEncodingProfile *video_profile;
+  GstEncodingProfile *image_profile;
+  gfloat zoom;
+  gfloat max_zoom;
+
+  gboolean elements_created;
+};
+
+struct _GstCameraBinClass
+{
+  GstPipelineClass pipeline_class;
+
+  /* Action signals */
+  void (*start_capture) (GstCameraBin * camera);
+  void (*stop_capture) (GstCameraBin * camera);
+};
+
+GType gst_camera_bin_get_type (void);
+gboolean gst_camera_bin_plugin_init (GstPlugin * plugin);
+
+G_END_DECLS
+
+#endif
diff --git a/gst/camerabin2/gstimagecapturebin.c b/gst/camerabin2/gstimagecapturebin.c
new file mode 100644
index 0000000..b4aba2a
--- /dev/null
+++ b/gst/camerabin2/gstimagecapturebin.c
@@ -0,0 +1,352 @@
+/* GStreamer
+ * Copyright (C) 2010 Thiago Santos <thiago.sousa.santos@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+/**
+ * SECTION:element-gstimagecapturebin
+ *
+ * The gstimagecapturebin element does FIXME stuff.
+ *
+ * <refsect2>
+ * <title>Example launch line</title>
+ * |[
+ * gst-launch -v videotestsrc num-buffers=3 ! imagecapturebin
+ * ]|
+ * FIXME Describe what the pipeline does.
+ * </refsect2>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstimagecapturebin.h"
+#include "camerabingeneral.h"
+
+/* prototypes */
+
+
+enum
+{
+  PROP_0,
+  PROP_LOCATION,
+  PROP_ENCODER,
+  PROP_MUXER
+};
+
+#define DEFAULT_LOCATION "img_%d"
+#define DEFAULT_COLORSPACE "ffmpegcolorspace"
+#define DEFAULT_ENCODER "jpegenc"
+#define DEFAULT_MUXER "jifmux"
+#define DEFAULT_SINK "multifilesink"
+
+/* pad templates */
+
+static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("video/x-raw-yuv; video/x-raw-rgb")
+    );
+
+/* class initialization */
+
+GST_BOILERPLATE (GstImageCaptureBin, gst_image_capture_bin, GstBin,
+    GST_TYPE_BIN);
+
+/* GObject callbacks */
+static void gst_image_capture_bin_dispose (GObject * object);
+static void gst_image_capture_bin_finalize (GObject * object);
+
+/* Element class functions */
+static GstStateChangeReturn
+gst_image_capture_bin_change_state (GstElement * element, GstStateChange trans);
+
+static void
+gst_image_capture_bin_set_encoder (GstImageCaptureBin * imagebin,
+    GstElement * encoder)
+{
+  GST_DEBUG_OBJECT (GST_OBJECT (imagebin),
+      "Setting image encoder %" GST_PTR_FORMAT, encoder);
+
+  if (imagebin->user_encoder)
+    g_object_unref (imagebin->user_encoder);
+
+  if (encoder)
+    g_object_ref (encoder);
+
+  imagebin->user_encoder = encoder;
+}
+
+static void
+gst_image_capture_bin_set_muxer (GstImageCaptureBin * imagebin,
+    GstElement * muxer)
+{
+  GST_DEBUG_OBJECT (GST_OBJECT (imagebin),
+      "Setting image muxer %" GST_PTR_FORMAT, muxer);
+
+  if (imagebin->user_muxer)
+    g_object_unref (imagebin->user_muxer);
+
+  if (muxer)
+    g_object_ref (muxer);
+
+  imagebin->user_muxer = muxer;
+}
+
+static void
+gst_image_capture_bin_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstImageCaptureBin *imagebin = GST_IMAGE_CAPTURE_BIN_CAST (object);
+
+  switch (prop_id) {
+    case PROP_LOCATION:
+      g_free (imagebin->location);
+      imagebin->location = g_value_dup_string (value);
+      GST_DEBUG_OBJECT (imagebin, "setting location to %s", imagebin->location);
+      if (imagebin->sink) {
+        g_object_set (imagebin->sink, "location", imagebin->location, NULL);
+      }
+      break;
+    case PROP_ENCODER:
+      gst_image_capture_bin_set_encoder (imagebin, g_value_get_object (value));
+      break;
+    case PROP_MUXER:
+      gst_image_capture_bin_set_muxer (imagebin, g_value_get_object (value));
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_image_capture_bin_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstImageCaptureBin *imagebin = GST_IMAGE_CAPTURE_BIN_CAST (object);
+
+  switch (prop_id) {
+    case PROP_LOCATION:
+      g_value_set_string (value, imagebin->location);
+      break;
+    case PROP_ENCODER:
+      g_value_set_object (value, imagebin->encoder);
+      break;
+    case PROP_MUXER:
+      g_value_set_object (value, imagebin->muxer);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_image_capture_bin_finalize (GObject * object)
+{
+  GstImageCaptureBin *imgbin = GST_IMAGE_CAPTURE_BIN_CAST (object);
+
+  g_free (imgbin->location);
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static void
+gst_image_capture_bin_base_init (gpointer g_class)
+{
+  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
+
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&sink_template));
+
+  gst_element_class_set_details_simple (element_class, "Image Capture Bin",
+      "Sink/Video", "Image Capture Bin used in camerabin2",
+      "Thiago Santos <thiago.sousa.santos@collabora.co.uk>");
+}
+
+static void
+gst_image_capture_bin_class_init (GstImageCaptureBinClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *element_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  element_class = GST_ELEMENT_CLASS (klass);
+
+  gobject_class->dispose = gst_image_capture_bin_dispose;
+  gobject_class->finalize = gst_image_capture_bin_finalize;
+  gobject_class->set_property = gst_image_capture_bin_set_property;
+  gobject_class->get_property = gst_image_capture_bin_get_property;
+
+  element_class->change_state =
+      GST_DEBUG_FUNCPTR (gst_image_capture_bin_change_state);
+
+  g_object_class_install_property (gobject_class, PROP_LOCATION,
+      g_param_spec_string ("location", "Location",
+          "Location to save the captured files. A %%d can be used as a "
+          "placeholder for a capture count",
+          DEFAULT_LOCATION, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class, PROP_ENCODER,
+      g_param_spec_object ("image-encoder", "Image encoder",
+          "Image encoder GStreamer element (default is jpegenc)",
+          GST_TYPE_ELEMENT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_class, PROP_MUXER,
+      g_param_spec_object ("image-muxer", "Image muxer",
+          "Image muxer GStreamer element (default is jifmux)",
+          GST_TYPE_ELEMENT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+}
+
+static void
+gst_image_capture_bin_init (GstImageCaptureBin * imagebin,
+    GstImageCaptureBinClass * imagebin_class)
+{
+  GstPadTemplate *tmpl;
+
+  tmpl = gst_static_pad_template_get (&sink_template);
+  imagebin->ghostpad = gst_ghost_pad_new_no_target_from_template ("sink", tmpl);
+  gst_object_unref (tmpl);
+  gst_element_add_pad (GST_ELEMENT_CAST (imagebin), imagebin->ghostpad);
+
+  imagebin->sink = NULL;
+
+  imagebin->location = g_strdup (DEFAULT_LOCATION);
+  imagebin->encoder = NULL;
+  imagebin->user_encoder = NULL;
+  imagebin->muxer = NULL;
+  imagebin->user_muxer = NULL;
+}
+
+static void
+gst_image_capture_bin_dispose (GObject * object)
+{
+  GstImageCaptureBin *imagebin = GST_IMAGE_CAPTURE_BIN_CAST (object);
+
+  if (imagebin->user_encoder) {
+    gst_object_unref (imagebin->user_encoder);
+    imagebin->user_encoder = NULL;
+  }
+
+  if (imagebin->user_muxer) {
+    gst_object_unref (imagebin->user_muxer);
+    imagebin->user_muxer = NULL;
+  }
+  G_OBJECT_CLASS (parent_class)->dispose ((GObject *) imagebin);
+}
+
+static gboolean
+gst_image_capture_bin_create_elements (GstImageCaptureBin * imagebin)
+{
+  GstElement *colorspace;
+  GstPad *pad = NULL;
+
+  if (imagebin->elements_created)
+    return TRUE;
+
+  /* create elements */
+  colorspace =
+      gst_camerabin_create_and_add_element (GST_BIN (imagebin),
+      DEFAULT_COLORSPACE, "imagebin-colorspace");
+  if (!colorspace)
+    goto error;
+
+  if (imagebin->user_encoder) {
+    imagebin->encoder = imagebin->user_encoder;
+    if (!gst_camerabin_add_element (GST_BIN (imagebin), imagebin->encoder)) {
+      goto error;
+    }
+  } else {
+    imagebin->encoder =
+        gst_camerabin_create_and_add_element (GST_BIN (imagebin),
+        DEFAULT_ENCODER, "imagebin-encoder");
+    if (!imagebin->encoder)
+      goto error;
+  }
+
+  if (imagebin->user_muxer) {
+    imagebin->muxer = imagebin->user_muxer;
+    if (!gst_camerabin_add_element (GST_BIN (imagebin), imagebin->muxer)) {
+      goto error;
+    }
+  } else {
+    imagebin->muxer =
+        gst_camerabin_create_and_add_element (GST_BIN (imagebin),
+        DEFAULT_MUXER, "imagebin-muxer");
+    if (!imagebin->muxer)
+      goto error;
+  }
+
+  imagebin->sink =
+      gst_camerabin_create_and_add_element (GST_BIN (imagebin), DEFAULT_SINK,
+      "imagebin-sink");
+  if (!imagebin->sink)
+    goto error;
+
+  g_object_set (imagebin->sink, "location", imagebin->location, "async", FALSE,
+      "post-messages", TRUE, NULL);
+
+  /* add ghostpad */
+  pad = gst_element_get_static_pad (colorspace, "sink");
+  if (!gst_ghost_pad_set_target (GST_GHOST_PAD (imagebin->ghostpad), pad))
+    goto error;
+  gst_object_unref (pad);
+
+  imagebin->elements_created = TRUE;
+  return TRUE;
+
+error:
+  if (pad)
+    gst_object_unref (pad);
+  return FALSE;
+}
+
+static GstStateChangeReturn
+gst_image_capture_bin_change_state (GstElement * element, GstStateChange trans)
+{
+  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
+  GstImageCaptureBin *imagebin = GST_IMAGE_CAPTURE_BIN_CAST (element);
+
+  switch (trans) {
+    case GST_STATE_CHANGE_NULL_TO_READY:
+      if (!gst_image_capture_bin_create_elements (imagebin)) {
+        return GST_STATE_CHANGE_FAILURE;
+      }
+      break;
+    default:
+      break;
+  }
+
+  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, trans);
+
+  switch (trans) {
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+}
+
+gboolean
+gst_image_capture_bin_plugin_init (GstPlugin * plugin)
+{
+  return gst_element_register (plugin, "imagecapturebin", GST_RANK_NONE,
+      gst_image_capture_bin_get_type ());
+}
diff --git a/gst/camerabin2/gstimagecapturebin.h b/gst/camerabin2/gstimagecapturebin.h
new file mode 100644
index 0000000..98a28e9
--- /dev/null
+++ b/gst/camerabin2/gstimagecapturebin.h
@@ -0,0 +1,63 @@
+/* GStreamer
+ * Copyright (C) 2010 Thiago Santos <thiago.sousa.santos@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+#ifndef _GST_IMAGE_CAPTURE_BIN_H_
+#define _GST_IMAGE_CAPTURE_BIN_H_
+
+#include <gst/gst.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_IMAGE_CAPTURE_BIN   (gst_image_capture_bin_get_type())
+#define GST_IMAGE_CAPTURE_BIN(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_IMAGE_CAPTURE_BIN,GstImageCaptureBin))
+#define GST_IMAGE_CAPTURE_BIN_CAST(obj)   ((GstImageCaptureBin *) obj)
+#define GST_IMAGE_CAPTURE_BIN_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_IMAGE_CAPTURE_BIN,GstImageCaptureBinClass))
+#define GST_IS_IMAGE_CAPTURE_BIN(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_IMAGE_CAPTURE_BIN))
+#define GST_IS_IMAGE_CAPTURE_BIN_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_IMAGE_CAPTURE_BIN))
+
+typedef struct _GstImageCaptureBin GstImageCaptureBin;
+typedef struct _GstImageCaptureBinClass GstImageCaptureBinClass;
+
+struct _GstImageCaptureBin
+{
+  GstBin bin;
+
+  GstPad *ghostpad;
+  GstElement *sink;
+
+  /* props */
+  gchar *location;
+  GstElement *encoder;
+  GstElement *user_encoder;
+  GstElement *muxer;
+  GstElement *user_muxer;
+
+  gboolean elements_created;
+};
+
+struct _GstImageCaptureBinClass
+{
+  GstBinClass bin_class;
+};
+
+GType gst_image_capture_bin_get_type (void);
+gboolean gst_image_capture_bin_plugin_init (GstPlugin * plugin);
+
+G_END_DECLS
+
+#endif
diff --git a/gst/camerabin2/gstomxcamerabinsrc.c b/gst/camerabin2/gstomxcamerabinsrc.c
new file mode 100644
index 0000000..67cae19
--- /dev/null
+++ b/gst/camerabin2/gstomxcamerabinsrc.c
@@ -0,0 +1,766 @@
+/*
+ * GStreamer
+ * Copyright (C) 2011 Texas Instruments, Inc
+ * Author: Alessandro Decina <alessandro.decina@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#include <string.h>
+
+#include "gstomxcamerabinsrc.h"
+#include "camerabingeneral.h"
+
+/* FIXME: get rid of this */
+enum
+{
+  OMX_CAMERA_MODE_PREVIEW = 0,
+  OMX_CAMERA_MODE_VIDEO = 1,
+  OMX_CAMERA_MODE_VIDEO_IMAGE = 2,
+  OMX_CAMERA_MODE_IMAGE = 3,
+  OMX_CAMERA_MODE_IMAGE_HS = 4,
+};
+
+enum GstVideoRecordingStatus
+{
+  GST_VIDEO_RECORDING_STATUS_DONE,
+  GST_VIDEO_RECORDING_STATUS_STARTING,
+  GST_VIDEO_RECORDING_STATUS_RUNNING,
+  GST_VIDEO_RECORDING_STATUS_FINISHING
+};
+
+
+enum
+{
+  PROP_0,
+};
+
+GST_DEBUG_CATEGORY (omx_camera_bin_src_debug);
+#define GST_CAT_DEFAULT omx_camera_bin_src_debug
+
+GST_BOILERPLATE (GstOmxCameraBinSrc, gst_omx_camera_bin_src,
+    GstBaseCameraSrc, GST_TYPE_BASE_CAMERA_SRC);
+
+static void set_capsfilter_caps (GstOmxCameraBinSrc * self, GstCaps * new_caps);
+
+static void
+gst_omx_camera_bin_src_dispose (GObject * object)
+{
+  GstOmxCameraBinSrc *self = GST_OMX_CAMERA_BIN_SRC (object);
+
+  gst_caps_replace (&self->image_capture_caps, NULL);
+
+  G_OBJECT_CLASS (parent_class)->dispose (object);
+}
+
+static void
+gst_omx_camera_bin_src_finalize (GstOmxCameraBinSrc * self)
+{
+  G_OBJECT_CLASS (parent_class)->finalize ((GObject *) (self));
+}
+
+static void
+gst_omx_camera_bin_src_set_property (GObject * object,
+    guint prop_id, const GValue * value, GParamSpec * pspec)
+{
+  GstOmxCameraBinSrc *self = GST_OMX_CAMERA_BIN_SRC (object);
+
+  switch (prop_id) {
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (self, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_omx_camera_bin_src_get_property (GObject * object,
+    guint prop_id, GValue * value, GParamSpec * pspec)
+{
+  GstOmxCameraBinSrc *self = GST_OMX_CAMERA_BIN_SRC (object);
+
+  switch (prop_id) {
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (self, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_omx_camera_bin_reset_video_src_caps (GstOmxCameraBinSrc * self,
+    GstCaps * caps)
+{
+#if 0
+  GstClock *clock;
+  gint64 base_time;
+
+  GST_DEBUG_OBJECT (self, "Resetting src caps to %" GST_PTR_FORMAT, caps);
+  if (self->video_source) {
+    clock = gst_element_get_clock (self->video_source);
+    base_time = gst_element_get_base_time (self->video_source);
+
+    gst_element_set_state (self->video_source, GST_STATE_READY);
+    set_capsfilter_caps (self, caps);
+
+    self->drop_newseg = TRUE;
+
+    GST_DEBUG_OBJECT (self, "Bringing source up");
+    gst_element_sync_state_with_parent (self->video_source);
+
+    if (clock) {
+      gst_element_set_clock (self->video_source, clock);
+      gst_element_set_base_time (self->video_source, base_time);
+
+      if (GST_IS_BIN (self->video_source)) {
+        GstIterator *it =
+            gst_bin_iterate_elements (GST_BIN (self->video_source));
+        gpointer item = NULL;
+        gboolean done = FALSE;
+        while (!done) {
+          switch (gst_iterator_next (it, &item)) {
+            case GST_ITERATOR_OK:
+              gst_element_set_base_time (GST_ELEMENT (item), base_time);
+              gst_object_unref (item);
+              break;
+            case GST_ITERATOR_RESYNC:
+              gst_iterator_resync (it);
+              break;
+            case GST_ITERATOR_ERROR:
+              done = TRUE;
+              break;
+            case GST_ITERATOR_DONE:
+              done = TRUE;
+              break;
+          }
+        }
+        gst_iterator_free (it);
+      }
+
+      gst_object_unref (clock);
+    }
+  }
+#endif
+}
+
+/**
+ * gst_omx_camera_bin_src_imgsrc_probe:
+ *
+ * Buffer probe called before sending each buffer to image queue.
+ */
+static gboolean
+gst_omx_camera_bin_src_imgsrc_probe (GstPad * pad, GstBuffer * buffer,
+    gpointer data)
+{
+  GstOmxCameraBinSrc *self = GST_OMX_CAMERA_BIN_SRC (data);
+  GstBaseCameraSrc *camerasrc = GST_BASE_CAMERA_SRC (data);
+  gboolean ret = FALSE;
+
+  GST_LOG_OBJECT (self, "Image probe, mode %d, capture count %d",
+      camerasrc->mode, self->image_capture_count);
+
+  g_mutex_lock (camerasrc->capturing_mutex);
+  if (self->image_capture_count > 0) {
+    ret = TRUE;
+    self->image_capture_count--;
+
+    /* post preview */
+    /* TODO This can likely be optimized if the viewfinder caps is the same as
+     * the preview caps, avoiding another scaling of the same buffer. */
+    GST_DEBUG_OBJECT (self, "Posting preview for image");
+    gst_base_camera_src_post_preview (camerasrc, buffer);
+
+    if (self->image_capture_count == 0) {
+      gst_base_camera_src_finish_capture (camerasrc);
+    }
+  }
+  g_mutex_unlock (camerasrc->capturing_mutex);
+  return ret;
+}
+
+/**
+ * gst_omx_camera_bin_src_vidsrc_probe:
+ *
+ * Buffer probe called before sending each buffer to image queue.
+ */
+static gboolean
+gst_omx_camera_bin_src_vidsrc_probe (GstPad * pad, GstBuffer * buffer,
+    gpointer data)
+{
+  GstOmxCameraBinSrc *self = GST_OMX_CAMERA_BIN_SRC (data);
+  GstBaseCameraSrc *camerasrc = GST_BASE_CAMERA_SRC_CAST (self);
+  gboolean ret = FALSE;
+
+  GST_LOG_OBJECT (self, "Video probe, mode %d, capture status %d",
+      camerasrc->mode, self->video_rec_status);
+
+  /* TODO do we want to lock for every buffer? */
+  /*
+   * Note that we can use gst_pad_push_event here because we are a buffer
+   * probe.
+   */
+  /* TODO shouldn't access this directly */
+  g_mutex_lock (camerasrc->capturing_mutex);
+  if (self->video_rec_status == GST_VIDEO_RECORDING_STATUS_DONE) {
+    /* NOP */
+  } else if (self->video_rec_status == GST_VIDEO_RECORDING_STATUS_STARTING) {
+    GST_DEBUG_OBJECT (self, "Starting video recording");
+    self->video_rec_status = GST_VIDEO_RECORDING_STATUS_RUNNING;
+
+    /* post preview */
+    GST_DEBUG_OBJECT (self, "Posting preview for video");
+    gst_base_camera_src_post_preview (camerasrc, buffer);
+
+    ret = TRUE;
+  } else if (self->video_rec_status == GST_VIDEO_RECORDING_STATUS_FINISHING) {
+    /* send eos */
+    GST_DEBUG_OBJECT (self, "Finishing video recording, pushing eos");
+    gst_pad_push_event (pad, gst_event_new_eos ());
+    self->video_rec_status = GST_VIDEO_RECORDING_STATUS_DONE;
+    gst_base_camera_src_finish_capture (camerasrc);
+  } else {
+    ret = TRUE;
+  }
+  g_mutex_unlock (camerasrc->capturing_mutex);
+  return ret;
+}
+
+static gboolean
+gst_omx_camera_bin_src_event (GstPad * pad, GstEvent * event)
+{
+  GstOmxCameraBinSrc *src = GST_OMX_CAMERA_BIN_SRC (GST_PAD_PARENT (pad));
+  const GstStructure *structure;
+
+  structure = gst_event_get_structure (event);
+  if (structure && gst_structure_has_name (structure, "renegotiate")) {
+    GST_DEBUG_OBJECT (src, "Received renegotiate on pad %s",
+        GST_PAD_NAME (pad));
+
+    if (pad == src->imgsrc) {
+      src->image_renegotiate = TRUE;
+    } else if (pad == src->vidsrc) {
+      src->video_renegotiate = TRUE;
+    }
+  }
+
+  return src->srcpad_event_func (pad, event);
+}
+
+#if 0
+static gboolean
+gst_omx_camera_src_src_event_probe (GstPad * pad, GstEvent * evt,
+    gpointer udata)
+{
+  gboolean ret = TRUE;
+  GstOmxCameraBinSrc *self = udata;
+
+  return TRUE;
+
+  switch (GST_EVENT_TYPE (evt)) {
+    case GST_EVENT_EOS:
+      /* drop */
+      ret = FALSE;
+      break;
+    case GST_EVENT_NEWSEGMENT:
+      if (self->drop_newseg) {
+        ret = FALSE;
+        self->drop_newseg = FALSE;
+      }
+      break;
+    default:
+      break;
+  }
+
+  if (ret == FALSE)
+    GST_INFO_OBJECT (self, "dropping %s event",
+        gst_event_type_get_name (GST_EVENT_TYPE (evt)));
+
+  return ret;
+}
+#endif
+
+static void
+gst_omx_camera_bin_src_caps_cb (GObject * gobject, GParamSpec * pspec,
+    gpointer user_data)
+{
+  GstBaseCameraSrc *bcamsrc = GST_BASE_CAMERA_SRC (user_data);
+  GstOmxCameraBinSrc *self = GST_OMX_CAMERA_BIN_SRC (user_data);
+  GstPad *src_caps_src_pad;
+  GstCaps *caps = NULL;
+  GstStructure *in_st = NULL;
+
+  /* get the new caps that were set on the capsfilter that configures the
+   * source */
+  src_caps_src_pad = gst_element_get_static_pad (self->src_filter, "src");
+  caps = gst_pad_get_caps_reffed (src_caps_src_pad);
+  gst_object_unref (src_caps_src_pad);
+  GST_DEBUG_OBJECT (self, "src-filter caps changed to %s",
+      gst_caps_to_string (caps));
+
+  if (gst_caps_get_size (caps)) {
+    in_st = gst_caps_get_structure (caps, 0);
+    if (in_st) {
+      gst_structure_get_int (in_st, "width", &bcamsrc->width);
+      gst_structure_get_int (in_st, "height", &bcamsrc->height);
+
+      GST_DEBUG_OBJECT (self, "Source dimensions now: %dx%d", bcamsrc->width,
+          bcamsrc->height);
+    }
+  }
+
+  /* Update zoom */
+  //gst_base_camera_src_setup_zoom (bcamsrc);
+
+  /* drop our ref on the caps */
+  gst_caps_unref (caps);
+};
+
+static void
+gst_omx_camera_pad_added_cb (GstElement * element,
+    GstPad * pad, gpointer user_data)
+{
+  GstOmxCameraBinSrc *self = GST_OMX_CAMERA_BIN_SRC (user_data);
+  gchar *name;
+  GstPad *sink;
+
+
+  name = gst_pad_get_name (pad);
+  GST_INFO_OBJECT (self, "pad added %s", name);
+
+  if (!strcmp (name, "vidsrc")) {
+    sink = gst_element_get_static_pad (self->vidsrc_stride, "sink");
+    if (gst_pad_link (pad, sink) != GST_PAD_LINK_OK) {
+      GST_ERROR_OBJECT (self,
+          "failed to link omx_camera:vidsrc to vidsrc_stride");
+    }
+    gst_object_unref (sink);
+
+    gst_pad_add_buffer_probe (pad,
+        G_CALLBACK (gst_omx_camera_bin_src_vidsrc_probe), self);
+  } else if (!strcmp (name, "imgsrc")) {
+    sink = gst_element_get_static_pad (self->imgsrc_stride, "sink");
+    if (gst_pad_link (pad, sink) != GST_PAD_LINK_OK) {
+      GST_ERROR_OBJECT (self,
+          "failed to link omx_camera:imgsrc to imgsrc_stride");
+    }
+    gst_object_unref (sink);
+
+    gst_pad_add_buffer_probe (pad,
+        G_CALLBACK (gst_omx_camera_bin_src_imgsrc_probe), self);
+  }
+}
+
+/**
+ * gst_omx_camera_bin_src_construct_pipeline:
+ * @bcamsrc: camerasrc object
+ *
+ * This function creates and links the elements of the camerasrc bin
+ * videosrc ! cspconv ! capsfilter ! crop ! scale ! capsfilter ! tee name=t !
+ *    t. ! ... (viewfinder pad)
+ *    t. ! output-selector name=outsel
+ *        outsel. ! (image pad)
+ *        outsel. ! (video pad)
+ *
+ * Returns: TRUE, if elements were successfully created, FALSE otherwise
+ */
+static gboolean
+gst_omx_camera_bin_src_construct_pipeline (GstBaseCameraSrc * bcamsrc)
+{
+  GstOmxCameraBinSrc *self = GST_OMX_CAMERA_BIN_SRC (bcamsrc);
+  GstBin *cbin = GST_BIN (bcamsrc);
+  gboolean ret = FALSE;
+  GstPad *pad;
+  GstCaps *caps;
+
+  if (!self->elements_created) {
+
+    GST_DEBUG_OBJECT (self, "constructing pipeline");
+
+    self->video_source = gst_element_factory_make ("omx_camera", NULL);
+    if (self->video_source == NULL)
+      goto done;
+
+    gst_bin_add (cbin, self->video_source);
+//    g_object_set (self->video_source, "num-buffers", 1000, NULL);
+
+    /* add a buffer probe to the src elemento to drop EOS from READY->NULL */
+    pad = gst_element_get_static_pad (self->video_source, "src");
+
+#if 0
+    self->src_event_probe_id = gst_pad_add_event_probe (pad,
+        (GCallback) gst_omx_camera_src_src_event_probe, self);
+    gst_object_unref (pad);
+#endif
+
+    if (!(self->src_filter =
+            gst_camerabin_create_and_add_element (cbin, "capsfilter",
+                "src-capsfilter")))
+      goto done;
+
+    caps = gst_caps_from_string ("video/x-raw-yuv-strided");
+    set_capsfilter_caps (self, caps);
+    gst_caps_unref (caps);
+
+    /* attach to notify::caps on the first capsfilter and use a callback
+     * to recalculate the zoom properties when these caps change and to
+     * propagate the caps to the second capsfilter */
+    pad = gst_element_get_static_pad (self->src_filter, "src");
+    g_signal_connect (pad, "notify::caps",
+        G_CALLBACK (gst_omx_camera_bin_src_caps_cb), self);
+    gst_object_unref (pad);
+
+    if (!(self->vfsrc_stride =
+            gst_camerabin_create_and_add_element (cbin,
+                "stridetransform", "vfsrc-stride")))
+      goto done;
+
+    self->vidsrc_stride =
+        gst_element_factory_make ("stridetransform", "vidsrc-stride");
+    self->imgsrc_stride =
+        gst_element_factory_make ("identity", "imgsrc-stride");
+    gst_bin_add_many (cbin, self->vidsrc_stride, self->imgsrc_stride, NULL);
+
+    g_signal_connect (self->video_source, "pad-added",
+        G_CALLBACK (gst_omx_camera_pad_added_cb), self);
+
+    if (bcamsrc->mode == MODE_IMAGE) {
+      g_object_set (self->video_source, "mode", OMX_CAMERA_MODE_VIDEO_IMAGE,
+          NULL);
+    } else {
+      g_object_set (self->video_source, "mode", OMX_CAMERA_MODE_VIDEO, NULL);
+    }
+
+    pad = gst_element_get_static_pad (self->vfsrc_stride, "src");
+    gst_ghost_pad_set_target (GST_GHOST_PAD (self->vfsrc), pad);
+    gst_object_unref (pad);
+
+    pad = gst_element_get_static_pad (self->vidsrc_stride, "src");
+    gst_ghost_pad_set_target (GST_GHOST_PAD (self->vidsrc), pad);
+    gst_object_unref (pad);
+
+    pad = gst_element_get_static_pad (self->imgsrc_stride, "src");
+    gst_ghost_pad_set_target (GST_GHOST_PAD (self->imgsrc), pad);
+    gst_object_unref (pad);
+
+    gst_pad_set_active (self->vfsrc, TRUE);
+    gst_pad_set_active (self->imgsrc, TRUE);    /* XXX ??? */
+    gst_pad_set_active (self->vidsrc, TRUE);    /* XXX ??? */
+  }
+  ret = TRUE;
+  self->elements_created = TRUE;
+done:
+  return ret;
+}
+
+static gboolean
+gst_omx_camera_bin_src_set_mode (GstBaseCameraSrc * bcamsrc,
+    GstCameraBinMode mode)
+{
+  GstPhotography *photography = gst_base_camera_src_get_photography (bcamsrc);
+  GstOmxCameraBinSrc *self = GST_OMX_CAMERA_BIN_SRC (bcamsrc);
+
+  GST_INFO_OBJECT (self, "mode %d", (gint) mode);
+
+  if (self->video_source) {
+    if (mode == MODE_IMAGE) {
+      self->image_renegotiate = TRUE;
+      g_object_set (self->video_source, "mode", OMX_CAMERA_MODE_VIDEO_IMAGE,
+          NULL);
+    } else {
+      self->video_renegotiate = TRUE;
+      g_object_set (self->video_source, "mode", OMX_CAMERA_MODE_VIDEO, NULL);
+    }
+  }
+  self->mode = mode;
+
+  if (photography) {
+    if (g_object_class_find_property (G_OBJECT_GET_CLASS (photography),
+            "capture-mode")) {
+      g_object_set (G_OBJECT (photography), "capture-mode", mode, NULL);
+    }
+  } else {
+    gst_omx_camera_bin_reset_video_src_caps (self, NULL);
+  }
+
+  return TRUE;
+}
+
+static void
+gst_omx_camera_bin_src_set_zoom (GstBaseCameraSrc * bcamsrc, gfloat zoom)
+{
+  GstOmxCameraBinSrc *self = GST_OMX_CAMERA_BIN_SRC (bcamsrc);
+
+  GST_INFO_OBJECT (self, "setting zoom %f", zoom);
+
+//  g_object_set (G_OBJECT (self->video_source), "zoom", (gint) (zoom * 100), NULL);
+}
+
+static GstCaps *
+gst_omx_camera_bin_src_get_allowed_input_caps (GstBaseCameraSrc * bcamsrc)
+{
+  GstOmxCameraBinSrc *self = GST_OMX_CAMERA_BIN_SRC (bcamsrc);
+  GstCaps *caps = NULL;
+  GstPad *pad = NULL, *peer_pad = NULL;
+  GstState state;
+  GstElement *videosrc;
+
+  videosrc = self->video_source;
+
+  if (!videosrc) {
+    GST_WARNING_OBJECT (self, "no videosrc, can't get allowed caps");
+    goto failed;
+  }
+
+  if (self->allowed_caps) {
+    GST_DEBUG_OBJECT (self, "returning cached caps");
+    goto done;
+  }
+
+  pad = gst_element_get_static_pad (videosrc, "src");
+
+  if (!pad) {
+    GST_WARNING_OBJECT (self, "no srcpad in videosrc");
+    goto failed;
+  }
+
+  state = GST_STATE (videosrc);
+
+  /* Make this function work also in NULL state */
+  if (state == GST_STATE_NULL) {
+    GST_DEBUG_OBJECT (self, "setting videosrc to ready temporarily");
+    peer_pad = gst_pad_get_peer (pad);
+    if (peer_pad) {
+      gst_pad_unlink (pad, peer_pad);
+    }
+    /* Set videosrc to READY to open video device */
+    gst_element_set_locked_state (videosrc, TRUE);
+    gst_element_set_state (videosrc, GST_STATE_READY);
+  }
+
+  self->allowed_caps = gst_pad_get_caps (pad);
+
+  /* Restore state and re-link if necessary */
+  if (state == GST_STATE_NULL) {
+    GST_DEBUG_OBJECT (self, "restoring videosrc state %d", state);
+    /* Reset videosrc to NULL state, some drivers seem to need this */
+    gst_element_set_state (videosrc, GST_STATE_NULL);
+    if (peer_pad) {
+      gst_pad_link (pad, peer_pad);
+      gst_object_unref (peer_pad);
+    }
+    gst_element_set_locked_state (videosrc, FALSE);
+  }
+
+  gst_object_unref (pad);
+
+done:
+  if (self->allowed_caps) {
+    caps = gst_caps_copy (self->allowed_caps);
+  }
+  GST_DEBUG_OBJECT (self, "allowed caps:%" GST_PTR_FORMAT, caps);
+failed:
+  return caps;
+}
+
+/**
+ * set_capsfilter_caps:
+ * @self: camerasrc object
+ * @new_caps: pointer to caps object to set
+ *
+ * Set given caps to camerabin capsfilters.
+ */
+static void
+set_capsfilter_caps (GstOmxCameraBinSrc * self, GstCaps * new_caps)
+{
+  GST_INFO_OBJECT (self, "new_caps:%" GST_PTR_FORMAT, new_caps);
+
+//  gst_base_camera_src_setup_zoom (GST_BASE_CAMERA_SRC (self));
+
+  g_object_set (G_OBJECT (self->src_filter), "caps", new_caps, NULL);
+  GST_INFO_OBJECT (self, "updated");
+}
+
+static gboolean
+gst_omx_camera_bin_src_start_capture (GstBaseCameraSrc * camerasrc)
+{
+  GstOmxCameraBinSrc *src = GST_OMX_CAMERA_BIN_SRC (camerasrc);
+
+  if (src->mode == MODE_IMAGE) {
+    src->image_capture_count = 1;
+  } else if (src->mode == MODE_VIDEO) {
+
+    if (src->video_renegotiate) {
+#if 0
+      g_mutex_unlock (camerasrc->capturing_mutex);
+      gst_omx_camera_bin_reset_video_src_caps (src, NULL);
+      g_mutex_lock (camerasrc->capturing_mutex);
+
+      /* clean capsfilter caps so they don't interfere here */
+      g_object_set (src->src_filter, "caps", NULL, NULL);
+
+      GST_DEBUG_OBJECT (src, "Getting allowed videosrc caps");
+      caps = gst_pad_get_allowed_caps (src->vidsrc);
+      GST_DEBUG_OBJECT (src, "Video src caps %" GST_PTR_FORMAT, caps);
+
+      src->video_renegotiate = FALSE;
+      g_mutex_unlock (camerasrc->capturing_mutex);
+      gst_omx_camera_bin_reset_video_src_caps (src, caps);
+      g_mutex_lock (camerasrc->capturing_mutex);
+      gst_caps_unref (caps);
+#endif
+    }
+    if (src->video_rec_status == GST_VIDEO_RECORDING_STATUS_DONE) {
+      src->video_rec_status = GST_VIDEO_RECORDING_STATUS_STARTING;
+    }
+  } else {
+    g_assert_not_reached ();
+    return FALSE;
+  }
+  return TRUE;
+}
+
+static void
+gst_omx_camera_bin_src_stop_capture (GstBaseCameraSrc * camerasrc)
+{
+  GstOmxCameraBinSrc *src = GST_OMX_CAMERA_BIN_SRC (camerasrc);
+
+  /* TODO shoud we access this directly? Maybe a macro is better? */
+  if (src->mode == MODE_VIDEO) {
+    if (src->video_rec_status == GST_VIDEO_RECORDING_STATUS_STARTING) {
+      GST_DEBUG_OBJECT (src, "Aborting, had not started recording");
+      src->video_rec_status = GST_VIDEO_RECORDING_STATUS_DONE;
+
+    } else if (src->video_rec_status == GST_VIDEO_RECORDING_STATUS_RUNNING) {
+      GST_DEBUG_OBJECT (src, "Marking video recording as finishing");
+      src->video_rec_status = GST_VIDEO_RECORDING_STATUS_FINISHING;
+    }
+  } else {
+    src->image_capture_count = 0;
+  }
+}
+
+static GstStateChangeReturn
+gst_omx_camera_bin_src_change_state (GstElement * element, GstStateChange trans)
+{
+  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
+  GstOmxCameraBinSrc *self = GST_OMX_CAMERA_BIN_SRC (element);
+
+  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, trans);
+
+  if (ret == GST_STATE_CHANGE_FAILURE)
+    goto end;
+
+  switch (trans) {
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      self->drop_newseg = FALSE;
+      self->image_renegotiate = TRUE;
+      self->video_renegotiate = TRUE;
+      break;
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      break;
+    case GST_STATE_CHANGE_NULL_TO_READY:
+      break;
+    default:
+      break;
+  }
+
+end:
+  return ret;
+}
+
+static void
+gst_omx_camera_bin_src_base_init (gpointer g_class)
+{
+  GstElementClass *gstelement_class = GST_ELEMENT_CLASS (g_class);
+
+  GST_DEBUG_CATEGORY_INIT (omx_camera_bin_src_debug, "omxcamerabinsrc",
+      0, "omx_camera camerabin2 adapter");
+
+  gst_element_class_set_details_simple (gstelement_class,
+      "omx_camera camerabin2 adapter", "Source/Video",
+      "omx_camera camerabin2 adapter",
+      "Alessandro Decina <alessandro.decina@collabora.co.uk>");
+}
+
+static void
+gst_omx_camera_bin_src_class_init (GstOmxCameraBinSrcClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *gstelement_class;
+  GstBaseCameraSrcClass *gstbasecamerasrc_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gstelement_class = GST_ELEMENT_CLASS (klass);
+  gstbasecamerasrc_class = GST_BASE_CAMERA_SRC_CLASS (klass);
+
+  gobject_class->dispose = gst_omx_camera_bin_src_dispose;
+  gobject_class->finalize =
+      (GObjectFinalizeFunc) gst_omx_camera_bin_src_finalize;
+  gobject_class->set_property = gst_omx_camera_bin_src_set_property;
+  gobject_class->get_property = gst_omx_camera_bin_src_get_property;
+
+  gstelement_class->change_state = gst_omx_camera_bin_src_change_state;
+
+  gstbasecamerasrc_class->construct_pipeline =
+      gst_omx_camera_bin_src_construct_pipeline;
+  gstbasecamerasrc_class->set_zoom = gst_omx_camera_bin_src_set_zoom;
+  gstbasecamerasrc_class->set_mode = gst_omx_camera_bin_src_set_mode;
+  gstbasecamerasrc_class->get_allowed_input_caps =
+      gst_omx_camera_bin_src_get_allowed_input_caps;
+  gstbasecamerasrc_class->start_capture = gst_omx_camera_bin_src_start_capture;
+  gstbasecamerasrc_class->stop_capture = gst_omx_camera_bin_src_stop_capture;
+}
+
+static void
+gst_omx_camera_bin_src_init (GstOmxCameraBinSrc * self,
+    GstOmxCameraBinSrcClass * klass)
+{
+  self->vfsrc =
+      gst_ghost_pad_new_no_target (GST_BASE_CAMERA_SRC_VIEWFINDER_PAD_NAME,
+      GST_PAD_SRC);
+  gst_element_add_pad (GST_ELEMENT (self), self->vfsrc);
+
+  self->imgsrc =
+      gst_ghost_pad_new_no_target (GST_BASE_CAMERA_SRC_IMAGE_PAD_NAME,
+      GST_PAD_SRC);
+  gst_element_add_pad (GST_ELEMENT (self), self->imgsrc);
+
+  self->vidsrc =
+      gst_ghost_pad_new_no_target (GST_BASE_CAMERA_SRC_VIDEO_PAD_NAME,
+      GST_PAD_SRC);
+  gst_element_add_pad (GST_ELEMENT (self), self->vidsrc);
+
+  self->srcpad_event_func = GST_PAD_EVENTFUNC (self->vfsrc);
+
+  gst_pad_set_event_function (self->imgsrc, gst_omx_camera_bin_src_event);
+  gst_pad_set_event_function (self->vidsrc, gst_omx_camera_bin_src_event);
+  gst_pad_set_event_function (self->vfsrc, gst_omx_camera_bin_src_event);
+
+  self->video_rec_status = GST_VIDEO_RECORDING_STATUS_DONE;
+  self->video_renegotiate = TRUE;
+  self->image_renegotiate = TRUE;
+  self->mode = GST_BASE_CAMERA_SRC_CAST (self)->mode;
+}
+
+gboolean
+gst_omx_camera_bin_src_plugin_init (GstPlugin * plugin)
+{
+  return gst_element_register (plugin, "omxcamerabinsrc", GST_RANK_PRIMARY + 1,
+      gst_omx_camera_bin_src_get_type ());
+}
diff --git a/gst/camerabin2/gstomxcamerabinsrc.h b/gst/camerabin2/gstomxcamerabinsrc.h
new file mode 100644
index 0000000..8679bca
--- /dev/null
+++ b/gst/camerabin2/gstomxcamerabinsrc.h
@@ -0,0 +1,106 @@
+/*
+ * GStreamer
+ * Copyright (C) 2011 Texas Instruments, Inc
+ * Author: Alessandro Decina <alessandro.decina@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+
+#ifndef __GST_OMX_CAMERA_BIN_SRC_H__
+#define __GST_OMX_CAMERA_BIN_SRC_H__
+
+#include <gst/gst.h>
+#include <gst/basecamerabinsrc/gstbasecamerasrc.h>
+#include <gst/basecamerabinsrc/gstcamerabinpreview.h>
+#include "camerabingeneral.h"
+
+G_BEGIN_DECLS
+#define GST_TYPE_OMX_CAMERA_BIN_SRC \
+  (gst_omx_camera_bin_src_get_type())
+#define GST_OMX_CAMERA_BIN_SRC(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OMX_CAMERA_BIN_SRC,GstOmxCameraBinSrc))
+#define GST_OMX_CAMERA_BIN_SRC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OMX_CAMERA_BIN_SRC,GstOmxCameraBinSrcClass))
+#define GST_IS_OMX_CAMERA_BIN_SRC(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OMX_CAMERA_BIN_SRC))
+#define GST_IS_OMX_CAMERA_BIN_SRC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_OMX_CAMERA_BIN_SRC))
+    GType gst_omx_camera_bin_src_get_type (void);
+
+typedef struct _GstOmxCameraBinSrc GstOmxCameraBinSrc;
+typedef struct _GstOmxCameraBinSrcClass GstOmxCameraBinSrcClass;
+
+
+/**
+ * GstOmxCameraBinSrc:
+ *
+ */
+struct _GstOmxCameraBinSrc
+{
+  GstBaseCameraSrc parent;
+
+  GstCameraBinMode mode;
+
+  GstPad *vfsrc;
+  GstPad *imgsrc;
+  GstPad *vidsrc;
+
+  /* video recording controls */
+  gint video_rec_status;
+
+  /* image capture controls */
+  gint image_capture_count;
+
+  /* source elements */
+  GstElement *video_source;
+  GstElement *src_filter;
+
+  GstElement *vfsrc_stride;
+  GstElement *vidsrc_stride;
+  GstElement *imgsrc_stride;
+
+  gboolean elements_created;
+
+  guint src_event_probe_id;
+
+  GstPadEventFunction srcpad_event_func;
+
+  /* For changing caps without losing timestamps */
+  gboolean drop_newseg;
+
+  /* Caps that videosrc supports */
+  GstCaps *allowed_caps;
+
+  /* Caps applied to capsfilters when taking still image */
+  GstCaps *image_capture_caps;
+  gboolean image_renegotiate;
+  gboolean video_renegotiate;
+};
+
+
+/**
+ * GstOmxCameraBinSrcClass:
+ *
+ */
+struct _GstOmxCameraBinSrcClass
+{
+  GstBaseCameraSrcClass parent;
+};
+
+gboolean gst_omx_camera_bin_src_plugin_init (GstPlugin * plugin);
+
+#endif /* __GST_OMX_CAMERA_BIN_SRC_H__ */
diff --git a/gst/camerabin2/gstplugin.c b/gst/camerabin2/gstplugin.c
new file mode 100644
index 0000000..2707690
--- /dev/null
+++ b/gst/camerabin2/gstplugin.c
@@ -0,0 +1,52 @@
+/* GStreamer
+ * Copyright (C) <2010> Thiago Santos <thiago.sousa.santos@collabora.co.uk>
+ *
+ * gstplugin.c: camerabin2 plugin registering
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstviewfinderbin.h"
+#include "gstimagecapturebin.h"
+#include "gstwrappercamerabinsrc.h"
+#include "gstomxcamerabinsrc.h"
+#include "gstcamerabin2.h"
+
+static gboolean
+plugin_init (GstPlugin * plugin)
+{
+  if (!gst_viewfinder_bin_plugin_init (plugin))
+    return FALSE;
+  if (!gst_image_capture_bin_plugin_init (plugin))
+    return FALSE;
+  if (!gst_wrapper_camera_bin_src_plugin_init (plugin))
+    return FALSE;
+  if (!gst_omx_camera_bin_src_plugin_init (plugin))
+    return FALSE;
+  if (!gst_camera_bin_plugin_init (plugin))
+    return FALSE;
+
+  return TRUE;
+}
+
+GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
+    GST_VERSION_MINOR,
+    "camerabin2", "camerabin2",
+    plugin_init, VERSION, "LGPL", GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
diff --git a/gst/camerabin2/gstviewfinderbin.c b/gst/camerabin2/gstviewfinderbin.c
new file mode 100644
index 0000000..98f0697
--- /dev/null
+++ b/gst/camerabin2/gstviewfinderbin.c
@@ -0,0 +1,305 @@
+/* GStreamer
+ * Copyright (C) 2010 Thiago Santos <thiago.sousa.santos@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+/**
+ * SECTION:element-gstviewfinderbin
+ *
+ * The gstviewfinderbin element is a displaying element for camerabin2.
+ *
+ * <refsect2>
+ * <title>Example launch line</title>
+ * |[
+ * gst-launch -v videotestsrc ! viewfinderbin
+ * ]|
+ * Feeds the viewfinderbin with video test data.
+ * </refsect2>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstviewfinderbin.h"
+
+GST_DEBUG_CATEGORY_STATIC (gst_viewfinder_bin_debug);
+#define GST_CAT_DEFAULT gst_viewfinder_bin_debug
+
+/* prototypes */
+
+
+enum
+{
+  PROP_0,
+  PROP_VIDEO_SINK,
+};
+
+/* pad templates */
+
+static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("video/x-raw-yuv-strided; video/x-raw-rgb")
+    );
+
+/* class initialization */
+
+GST_BOILERPLATE (GstViewfinderBin, gst_viewfinder_bin, GstBin, GST_TYPE_BIN);
+
+static void gst_viewfinder_bin_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * spec);
+static void gst_viewfinder_bin_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * spec);
+
+static void
+gst_viewfinder_bin_set_video_sink (GstViewfinderBin * vfbin, GstElement * sink);
+
+
+/* Element class functions */
+static GstStateChangeReturn
+gst_viewfinder_bin_change_state (GstElement * element, GstStateChange trans);
+
+static void
+gst_viewfinder_bin_dispose (GObject * object)
+{
+  GstViewfinderBin *viewfinderbin = GST_VIEWFINDER_BIN_CAST (object);
+
+  if (viewfinderbin->user_video_sink) {
+    gst_object_unref (viewfinderbin->user_video_sink);
+    viewfinderbin->user_video_sink = NULL;
+  }
+
+  if (viewfinderbin->video_sink) {
+    gst_object_unref (viewfinderbin->video_sink);
+    viewfinderbin->video_sink = NULL;
+  }
+
+  G_OBJECT_CLASS (parent_class)->dispose ((GObject *) viewfinderbin);
+}
+
+static void
+gst_viewfinder_bin_base_init (gpointer g_class)
+{
+  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);
+
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&sink_template));
+
+  gst_element_class_set_details_simple (element_class, "Viewfinder Bin",
+      "Sink/Video", "Viewfinder Bin used in camerabin2",
+      "Thiago Santos <thiago.sousa.santos@collabora.co.uk>");
+}
+
+static void
+gst_viewfinder_bin_class_init (GstViewfinderBinClass * klass)
+{
+  GObjectClass *gobject_klass;
+  GstElementClass *element_class;
+
+  gobject_klass = (GObjectClass *) klass;
+  element_class = GST_ELEMENT_CLASS (klass);
+
+  element_class->change_state =
+      GST_DEBUG_FUNCPTR (gst_viewfinder_bin_change_state);
+
+  gobject_klass->dispose = gst_viewfinder_bin_dispose;
+  gobject_klass->set_property = gst_viewfinder_bin_set_property;
+  gobject_klass->get_property = gst_viewfinder_bin_get_property;
+
+  g_object_class_install_property (gobject_klass, PROP_VIDEO_SINK,
+      g_param_spec_object ("video-sink", "Video Sink",
+          "the video output element to use (NULL = default)",
+          GST_TYPE_ELEMENT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+}
+
+static void
+gst_viewfinder_bin_init (GstViewfinderBin * viewfinderbin,
+    GstViewfinderBinClass * viewfinderbin_class)
+{
+  GstPadTemplate *templ = gst_static_pad_template_get (&sink_template);
+  viewfinderbin->ghostpad = gst_ghost_pad_new_no_target_from_template ("sink",
+      templ);
+  gst_object_unref (templ);
+  gst_element_add_pad (GST_ELEMENT_CAST (viewfinderbin),
+      viewfinderbin->ghostpad);
+}
+
+static gboolean
+gst_viewfinder_bin_create_elements (GstViewfinderBin * vfbin)
+{
+  GstElement *csp = NULL;
+  GstElement *videoscale = NULL;
+  GstPad *pad = NULL;
+  gboolean added = FALSE;
+
+  GST_DEBUG_OBJECT (vfbin, "Creating internal elements");
+
+  if (!vfbin->elements_created) {
+    /* create elements */
+    csp = gst_element_factory_make ("identity", "vfbin-csp");
+    if (!csp)
+      goto error;
+
+    videoscale = gst_element_factory_make ("identity", "vfbin-videoscale");
+    if (!videoscale)
+      goto error;
+
+    GST_DEBUG_OBJECT (vfbin, "Internal elements created, proceding to linking");
+
+    /* add and link */
+    gst_bin_add_many (GST_BIN_CAST (vfbin), csp, videoscale, NULL);
+    added = TRUE;
+    if (!gst_element_link (csp, videoscale))
+      goto error;
+
+    /* add ghostpad */
+    pad = gst_element_get_static_pad (csp, "sink");
+    if (!gst_ghost_pad_set_target (GST_GHOST_PAD (vfbin->ghostpad), pad))
+      goto error;
+    gst_object_unref (pad);
+
+    vfbin->elements_created = TRUE;
+    GST_DEBUG_OBJECT (vfbin, "Elements succesfully created and linked");
+  }
+
+  if (vfbin->video_sink) {
+    /* check if we need to replace the current one */
+    if (vfbin->user_video_sink && vfbin->video_sink != vfbin->user_video_sink) {
+      gst_bin_remove (GST_BIN_CAST (vfbin), vfbin->video_sink);
+      gst_object_unref (vfbin->video_sink);
+      vfbin->video_sink = NULL;
+    }
+  }
+
+  if (!vfbin->video_sink) {
+    if (vfbin->user_video_sink)
+      vfbin->video_sink = gst_object_ref (vfbin->user_video_sink);
+    else
+      vfbin->video_sink = gst_element_factory_make ("autovideosink",
+          "vfbin-sink");
+
+    gst_bin_add (GST_BIN_CAST (vfbin), gst_object_ref (vfbin->video_sink));
+
+    if (!videoscale)
+      videoscale = gst_bin_get_by_name (GST_BIN_CAST (vfbin),
+          "vfbin-videoscale");
+
+    if (!gst_element_link_pads (videoscale, "src", vfbin->video_sink, "sink")) {
+      GST_WARNING_OBJECT (vfbin, "Failed to link the new sink");
+    }
+  }
+
+  return TRUE;
+
+error:
+  GST_WARNING_OBJECT (vfbin, "Creating internal elements failed");
+  if (pad)
+    gst_object_unref (pad);
+  if (!added) {
+    if (csp)
+      gst_object_unref (csp);
+    if (videoscale)
+      gst_object_unref (videoscale);
+  } else {
+    gst_bin_remove_many (GST_BIN_CAST (vfbin), csp, videoscale, NULL);
+  }
+  return FALSE;
+}
+
+static GstStateChangeReturn
+gst_viewfinder_bin_change_state (GstElement * element, GstStateChange trans)
+{
+  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
+  GstViewfinderBin *vfbin = GST_VIEWFINDER_BIN_CAST (element);
+
+  switch (trans) {
+    case GST_STATE_CHANGE_NULL_TO_READY:
+      if (!gst_viewfinder_bin_create_elements (vfbin)) {
+        return GST_STATE_CHANGE_FAILURE;
+      }
+      break;
+    default:
+      break;
+  }
+
+  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, trans);
+
+  switch (trans) {
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+}
+
+static void
+gst_viewfinder_bin_set_video_sink (GstViewfinderBin * vfbin, GstElement * sink)
+{
+  GST_INFO_OBJECT (vfbin, "Setting video sink to %" GST_PTR_FORMAT, sink);
+
+  if (vfbin->user_video_sink != sink) {
+    if (vfbin->user_video_sink) {
+      gst_object_unref (vfbin->user_video_sink);
+    }
+    vfbin->user_video_sink = sink;
+    if (sink)
+      gst_object_ref (sink);
+  }
+}
+
+static void
+gst_viewfinder_bin_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstViewfinderBin *vfbin = GST_VIEWFINDER_BIN_CAST (object);
+
+  switch (prop_id) {
+    case PROP_VIDEO_SINK:
+      gst_viewfinder_bin_set_video_sink (vfbin, g_value_get_object (value));
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_viewfinder_bin_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstViewfinderBin *vfbin = GST_VIEWFINDER_BIN_CAST (object);
+
+  switch (prop_id) {
+    case PROP_VIDEO_SINK:
+      g_value_set_object (value, vfbin->video_sink);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+gboolean
+gst_viewfinder_bin_plugin_init (GstPlugin * plugin)
+{
+  GST_DEBUG_CATEGORY_INIT (gst_viewfinder_bin_debug, "viewfinderbin", 0,
+      "ViewFinderBin");
+  return gst_element_register (plugin, "viewfinderbin", GST_RANK_NONE,
+      gst_viewfinder_bin_get_type ());
+}
diff --git a/gst/camerabin2/gstviewfinderbin.h b/gst/camerabin2/gstviewfinderbin.h
new file mode 100644
index 0000000..6369219
--- /dev/null
+++ b/gst/camerabin2/gstviewfinderbin.h
@@ -0,0 +1,58 @@
+/* GStreamer
+ * Copyright (C) 2010 Thiago Santos <thiago.sousa.santos@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+#ifndef _GST_VIEWFINDER_BIN_H_
+#define _GST_VIEWFINDER_BIN_H_
+
+#include <gst/gst.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_VIEWFINDER_BIN   (gst_viewfinder_bin_get_type())
+#define GST_VIEWFINDER_BIN(obj)   (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VIEWFINDER_BIN,GstViewfinderBin))
+#define GST_VIEWFINDER_BIN_CAST(obj)   ((GstViewfinderBin *) obj)
+#define GST_VIEWFINDER_BIN_CLASS(klass)   (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VIEWFINDER_BIN,GstViewfinderBinClass))
+#define GST_IS_VIEWFINDER_BIN(obj)   (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VIEWFINDER_BIN))
+#define GST_IS_VIEWFINDER_BIN_CLASS(obj)   (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VIEWFINDER_BIN))
+
+typedef struct _GstViewfinderBin GstViewfinderBin;
+typedef struct _GstViewfinderBinClass GstViewfinderBinClass;
+
+struct _GstViewfinderBin
+{
+  GstBin bin;
+
+  GstPad *ghostpad;
+
+  GstElement *video_sink;
+  GstElement *user_video_sink;
+
+  gboolean elements_created;
+};
+
+struct _GstViewfinderBinClass
+{
+  GstBinClass bin_class;
+};
+
+GType gst_viewfinder_bin_get_type (void);
+gboolean gst_viewfinder_bin_plugin_init (GstPlugin * plugin);
+
+G_END_DECLS
+
+#endif
diff --git a/gst/camerabin2/gstwrappercamerabinsrc.c b/gst/camerabin2/gstwrappercamerabinsrc.c
new file mode 100644
index 0000000..2cf6ac4
--- /dev/null
+++ b/gst/camerabin2/gstwrappercamerabinsrc.c
@@ -0,0 +1,1158 @@
+/*
+ * GStreamer
+ * Copyright (C) 2010 Texas Instruments, Inc
+ * Copyright (C) 2010 Thiago Santos <thiago.sousa.santos@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+
+/**
+ * SECTION:element-wrappercamerabinsrc
+ *
+ * A camera bin src element that wraps a default video source with a single
+ * pad into the 3pad model that camerabin2 expects.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#include "gstwrappercamerabinsrc.h"
+#include "camerabingeneral.h"
+
+enum
+{
+  PROP_0,
+  PROP_VIDEO_SRC
+};
+
+GST_DEBUG_CATEGORY (wrapper_camera_bin_src_debug);
+#define GST_CAT_DEFAULT wrapper_camera_bin_src_debug
+
+GST_BOILERPLATE (GstWrapperCameraBinSrc, gst_wrapper_camera_bin_src,
+    GstBaseCameraSrc, GST_TYPE_BASE_CAMERA_SRC);
+
+static void set_capsfilter_caps (GstWrapperCameraBinSrc * self,
+    GstCaps * new_caps);
+
+static void
+gst_wrapper_camera_bin_src_dispose (GObject * object)
+{
+  GstWrapperCameraBinSrc *self = GST_WRAPPER_CAMERA_BIN_SRC (object);
+
+  if (self->app_vid_src) {
+    gst_object_unref (self->app_vid_src);
+    self->app_vid_src = NULL;
+  }
+  gst_caps_replace (&self->image_capture_caps, NULL);
+
+  G_OBJECT_CLASS (parent_class)->dispose (object);
+}
+
+static void
+gst_wrapper_camera_bin_src_finalize (GstWrapperCameraBinSrc * self)
+{
+  G_OBJECT_CLASS (parent_class)->finalize ((GObject *) (self));
+}
+
+static void
+gst_wrapper_camera_bin_src_set_property (GObject * object,
+    guint prop_id, const GValue * value, GParamSpec * pspec)
+{
+  GstWrapperCameraBinSrc *self = GST_WRAPPER_CAMERA_BIN_SRC (object);
+
+  switch (prop_id) {
+    case PROP_VIDEO_SRC:
+      if (GST_STATE (self) != GST_STATE_NULL) {
+        GST_ELEMENT_ERROR (self, CORE, FAILED,
+            ("camerasrc must be in NULL state when setting the video source element"),
+            (NULL));
+      } else {
+        if (self->app_vid_src)
+          gst_object_unref (self->app_vid_src);
+        self->app_vid_src = g_value_get_object (value);
+        if (self->app_vid_src)
+          gst_object_ref (self->app_vid_src);
+      }
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (self, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_wrapper_camera_bin_src_get_property (GObject * object,
+    guint prop_id, GValue * value, GParamSpec * pspec)
+{
+  GstWrapperCameraBinSrc *self = GST_WRAPPER_CAMERA_BIN_SRC (object);
+
+  switch (prop_id) {
+    case PROP_VIDEO_SRC:
+      if (self->src_vid_src)
+        g_value_set_object (value, self->src_vid_src);
+      else
+        g_value_set_object (value, self->app_vid_src);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (self, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_wrapper_camera_bin_reset_video_src_caps (GstWrapperCameraBinSrc * self,
+    GstCaps * caps)
+{
+  GstClock *clock;
+  gint64 base_time;
+
+  GST_DEBUG_OBJECT (self, "Resetting src caps to %" GST_PTR_FORMAT, caps);
+  if (self->src_vid_src) {
+    clock = gst_element_get_clock (self->src_vid_src);
+    base_time = gst_element_get_base_time (self->src_vid_src);
+
+    gst_element_set_state (self->src_vid_src, GST_STATE_READY);
+    set_capsfilter_caps (self, caps);
+
+    self->drop_newseg = TRUE;
+
+    GST_DEBUG_OBJECT (self, "Bringing source up");
+    gst_element_sync_state_with_parent (self->src_vid_src);
+
+    if (clock) {
+      gst_element_set_clock (self->src_vid_src, clock);
+      gst_element_set_base_time (self->src_vid_src, base_time);
+
+      if (GST_IS_BIN (self->src_vid_src)) {
+        GstIterator *it =
+            gst_bin_iterate_elements (GST_BIN (self->src_vid_src));
+        gpointer item = NULL;
+        gboolean done = FALSE;
+        while (!done) {
+          switch (gst_iterator_next (it, &item)) {
+            case GST_ITERATOR_OK:
+              gst_element_set_base_time (GST_ELEMENT (item), base_time);
+              gst_object_unref (item);
+              break;
+            case GST_ITERATOR_RESYNC:
+              gst_iterator_resync (it);
+              break;
+            case GST_ITERATOR_ERROR:
+              done = TRUE;
+              break;
+            case GST_ITERATOR_DONE:
+              done = TRUE;
+              break;
+          }
+        }
+        gst_iterator_free (it);
+      }
+
+      gst_object_unref (clock);
+    }
+  }
+}
+
+/**
+ * gst_wrapper_camera_bin_src_imgsrc_probe:
+ *
+ * Buffer probe called before sending each buffer to image queue.
+ */
+static gboolean
+gst_wrapper_camera_bin_src_imgsrc_probe (GstPad * pad, GstBuffer * buffer,
+    gpointer data)
+{
+  GstWrapperCameraBinSrc *self = GST_WRAPPER_CAMERA_BIN_SRC (data);
+  GstBaseCameraSrc *camerasrc = GST_BASE_CAMERA_SRC (data);
+  gboolean ret = FALSE;
+
+  GST_LOG_OBJECT (self, "Image probe, mode %d, capture count %d",
+      camerasrc->mode, self->image_capture_count);
+
+  g_mutex_lock (camerasrc->capturing_mutex);
+  if (self->image_capture_count > 0) {
+    ret = TRUE;
+    self->image_capture_count--;
+
+    /* post preview */
+    /* TODO This can likely be optimized if the viewfinder caps is the same as
+     * the preview caps, avoiding another scaling of the same buffer. */
+    GST_DEBUG_OBJECT (self, "Posting preview for image");
+    gst_base_camera_src_post_preview (camerasrc, buffer);
+
+    if (self->image_capture_count == 0) {
+      gst_base_camera_src_finish_capture (camerasrc);
+    }
+  }
+  g_mutex_unlock (camerasrc->capturing_mutex);
+  return ret;
+}
+
+/**
+ * gst_wrapper_camera_bin_src_vidsrc_probe:
+ *
+ * Buffer probe called before sending each buffer to image queue.
+ */
+static gboolean
+gst_wrapper_camera_bin_src_vidsrc_probe (GstPad * pad, GstBuffer * buffer,
+    gpointer data)
+{
+  GstWrapperCameraBinSrc *self = GST_WRAPPER_CAMERA_BIN_SRC (data);
+  GstBaseCameraSrc *camerasrc = GST_BASE_CAMERA_SRC_CAST (self);
+  gboolean ret = FALSE;
+
+  GST_LOG_OBJECT (self, "Video probe, mode %d, capture status %d",
+      camerasrc->mode, self->video_rec_status);
+
+  /* TODO do we want to lock for every buffer? */
+  /*
+   * Note that we can use gst_pad_push_event here because we are a buffer
+   * probe.
+   */
+  /* TODO shouldn't access this directly */
+  g_mutex_lock (camerasrc->capturing_mutex);
+  if (self->video_rec_status == GST_VIDEO_RECORDING_STATUS_DONE) {
+    /* NOP */
+  } else if (self->video_rec_status == GST_VIDEO_RECORDING_STATUS_STARTING) {
+    GST_DEBUG_OBJECT (self, "Starting video recording");
+    self->video_rec_status = GST_VIDEO_RECORDING_STATUS_RUNNING;
+
+    /* post preview */
+    GST_DEBUG_OBJECT (self, "Posting preview for video");
+    gst_base_camera_src_post_preview (camerasrc, buffer);
+
+    ret = TRUE;
+  } else if (self->video_rec_status == GST_VIDEO_RECORDING_STATUS_FINISHING) {
+    /* send eos */
+    GST_DEBUG_OBJECT (self, "Finishing video recording, pushing eos");
+    gst_pad_push_event (pad, gst_event_new_eos ());
+    self->video_rec_status = GST_VIDEO_RECORDING_STATUS_DONE;
+    gst_base_camera_src_finish_capture (camerasrc);
+  } else {
+    ret = TRUE;
+  }
+  g_mutex_unlock (camerasrc->capturing_mutex);
+  return ret;
+}
+
+static gboolean
+gst_wrapper_camera_bin_src_event (GstPad * pad, GstEvent * event)
+{
+  GstWrapperCameraBinSrc *src =
+      GST_WRAPPER_CAMERA_BIN_SRC (GST_PAD_PARENT (pad));
+  const GstStructure *structure;
+
+  structure = gst_event_get_structure (event);
+  if (structure && gst_structure_has_name (structure, "renegotiate")) {
+    GST_DEBUG_OBJECT (src, "Received renegotiate on pad %s",
+        GST_PAD_NAME (pad));
+
+    if (pad == src->imgsrc) {
+      src->image_renegotiate = TRUE;
+    } else if (pad == src->vidsrc) {
+      src->video_renegotiate = TRUE;
+    }
+  }
+
+  return src->srcpad_event_func (pad, event);
+}
+
+static gboolean
+gst_wrapper_camera_src_src_event_probe (GstPad * pad, GstEvent * evt,
+    gpointer udata)
+{
+  gboolean ret = TRUE;
+  GstWrapperCameraBinSrc *self = udata;
+
+  switch (GST_EVENT_TYPE (evt)) {
+    case GST_EVENT_EOS:
+      /* drop */
+      ret = FALSE;
+      break;
+    case GST_EVENT_NEWSEGMENT:
+      if (self->drop_newseg) {
+        ret = FALSE;
+        self->drop_newseg = FALSE;
+      }
+      break;
+    default:
+      break;
+  }
+  return ret;
+}
+
+static void
+gst_wrapper_camera_bin_src_caps_cb (GObject * gobject, GParamSpec * pspec,
+    gpointer user_data)
+{
+  GstBaseCameraSrc *bcamsrc = GST_BASE_CAMERA_SRC (user_data);
+  GstWrapperCameraBinSrc *self = GST_WRAPPER_CAMERA_BIN_SRC (user_data);
+  GstPad *src_caps_src_pad;
+  GstCaps *caps = NULL;
+  GstStructure *in_st = NULL;
+
+  /* get the new caps that were set on the capsfilter that configures the
+   * source */
+  src_caps_src_pad = gst_element_get_static_pad (self->src_filter, "src");
+  caps = gst_pad_get_caps_reffed (src_caps_src_pad);
+  gst_object_unref (src_caps_src_pad);
+  GST_DEBUG_OBJECT (self, "src-filter caps changed to %s",
+      gst_caps_to_string (caps));
+
+  if (gst_caps_get_size (caps)) {
+    in_st = gst_caps_get_structure (caps, 0);
+    if (in_st) {
+      gst_structure_get_int (in_st, "width", &bcamsrc->width);
+      gst_structure_get_int (in_st, "height", &bcamsrc->height);
+
+      GST_DEBUG_OBJECT (self, "Source dimensions now: %dx%d", bcamsrc->width,
+          bcamsrc->height);
+    }
+  }
+
+  /* Update zoom */
+  gst_base_camera_src_setup_zoom (bcamsrc);
+
+  /* Update post-zoom capsfilter */
+  if (self->src_zoom_filter)
+    g_object_set (G_OBJECT (self->src_zoom_filter), "caps", caps, NULL);
+
+  /* drop our ref on the caps */
+  gst_caps_unref (caps);
+};
+
+static void
+gst_wrapper_camera_bin_src_max_zoom_cb (GObject * self, GParamSpec * pspec,
+    gpointer user_data)
+{
+  GstBaseCameraSrc *bcamsrc = (GstBaseCameraSrc *) user_data;
+
+  g_object_get (self, "max-zoom", &bcamsrc->max_zoom, NULL);
+  g_object_notify (G_OBJECT (bcamsrc), "max-zoom");
+}
+
+
+/**
+ * gst_wrapper_camera_bin_src_construct_pipeline:
+ * @bcamsrc: camerasrc object
+ *
+ * This function creates and links the elements of the camerasrc bin
+ * videosrc ! cspconv ! capsfilter ! crop ! scale ! capsfilter ! tee name=t !
+ *    t. ! ... (viewfinder pad)
+ *    t. ! output-selector name=outsel
+ *        outsel. ! (image pad)
+ *        outsel. ! (video pad)
+ *
+ * Returns: TRUE, if elements were successfully created, FALSE otherwise
+ */
+static gboolean
+gst_wrapper_camera_bin_src_construct_pipeline (GstBaseCameraSrc * bcamsrc)
+{
+  GstWrapperCameraBinSrc *self = GST_WRAPPER_CAMERA_BIN_SRC (bcamsrc);
+  GstBin *cbin = GST_BIN (bcamsrc);
+  GstElement *tee;
+  gboolean ret = FALSE;
+  GstElement *videoscale;
+  GstPad *vf_pad;
+  GstPad *tee_capture_pad;
+  GstPad *src_caps_src_pad;
+
+  if (!self->elements_created) {
+
+    GST_DEBUG_OBJECT (self, "constructing pipeline");
+
+    /* Add application set or default video src element */
+    if (!(self->src_vid_src = gst_camerabin_setup_default_element (cbin,
+                self->app_vid_src, "autovideosrc", DEFAULT_VIDEOSRC,
+                "camerasrc-real-src"))) {
+      self->src_vid_src = NULL;
+      goto done;
+    } else {
+      if (!gst_camerabin_add_element (cbin, self->src_vid_src)) {
+        goto done;
+      }
+    }
+    /* we lost the reference */
+    self->app_vid_src = NULL;
+
+    /* we listen for changes to max-zoom in the video src so that
+     * we can proxy them to the basecamerasrc property */
+    if (g_object_class_find_property (G_OBJECT_GET_CLASS (bcamsrc), "max-zoom")) {
+      g_signal_connect (G_OBJECT (self->src_vid_src), "notify::max-zoom",
+          (GCallback) gst_wrapper_camera_bin_src_max_zoom_cb, bcamsrc);
+    }
+
+    /* add a buffer probe to the src elemento to drop EOS from READY->NULL */
+    {
+      GstPad *pad;
+      pad = gst_element_get_static_pad (self->src_vid_src, "src");
+
+      self->src_event_probe_id = gst_pad_add_event_probe (pad,
+          (GCallback) gst_wrapper_camera_src_src_event_probe, self);
+      gst_object_unref (pad);
+    }
+
+    if (!gst_camerabin_create_and_add_element (cbin, "ffmpegcolorspace",
+            "src-colorspace"))
+      goto done;
+
+    if (!(self->src_filter =
+            gst_camerabin_create_and_add_element (cbin, "capsfilter",
+                "src-capsfilter")))
+      goto done;
+
+    /* attach to notify::caps on the first capsfilter and use a callback
+     * to recalculate the zoom properties when these caps change and to
+     * propagate the caps to the second capsfilter */
+    src_caps_src_pad = gst_element_get_static_pad (self->src_filter, "src");
+    g_signal_connect (src_caps_src_pad, "notify::caps",
+        G_CALLBACK (gst_wrapper_camera_bin_src_caps_cb), self);
+    gst_object_unref (src_caps_src_pad);
+
+    if (!(self->src_zoom_crop =
+            gst_camerabin_create_and_add_element (cbin, "videocrop",
+                "zoom-crop")))
+      goto done;
+    if (!(self->src_zoom_scale =
+            gst_camerabin_create_and_add_element (cbin, "videoscale",
+                "zoom-scale")))
+      goto done;
+    if (!(self->src_zoom_filter =
+            gst_camerabin_create_and_add_element (cbin, "capsfilter",
+                "zoom-capsfilter")))
+      goto done;
+
+    if (!(tee =
+            gst_camerabin_create_and_add_element (cbin, "tee",
+                "camerasrc-tee")))
+      goto done;
+
+    /* viewfinder pad */
+    vf_pad = gst_element_get_request_pad (tee, "src%d");
+    g_object_set (tee, "alloc-pad", vf_pad, NULL);
+    gst_object_unref (vf_pad);
+
+    /* the viewfinder should always work, so we add some converters to it */
+    if (!gst_camerabin_create_and_add_element (cbin, "ffmpegcolorspace",
+            "viewfinder-colorspace"))
+      goto done;
+    if (!(videoscale =
+            gst_camerabin_create_and_add_element (cbin, "videoscale",
+                "viewfinder-scale")))
+      goto done;
+
+    /* image/video pad from tee */
+    tee_capture_pad = gst_element_get_request_pad (tee, "src%d");
+
+    self->output_selector =
+        gst_element_factory_make ("output-selector", "outsel");
+    g_object_set (self->output_selector, "pad-negotiation-mode", 0, NULL);
+    gst_bin_add (GST_BIN (self), self->output_selector);
+    {
+      GstPad *pad = gst_element_get_static_pad (self->output_selector, "sink");
+
+      /* check return TODO */
+      gst_pad_link (tee_capture_pad, pad);
+      gst_object_unref (pad);
+    }
+    gst_object_unref (tee_capture_pad);
+
+    /* Create the 2 output pads for video and image */
+    self->outsel_vidpad =
+        gst_element_get_request_pad (self->output_selector, "src%d");
+    self->outsel_imgpad =
+        gst_element_get_request_pad (self->output_selector, "src%d");
+
+    g_assert (self->outsel_vidpad != NULL);
+    g_assert (self->outsel_imgpad != NULL);
+
+    gst_pad_add_buffer_probe (self->outsel_imgpad,
+        G_CALLBACK (gst_wrapper_camera_bin_src_imgsrc_probe), self);
+    gst_pad_add_buffer_probe (self->outsel_vidpad,
+        G_CALLBACK (gst_wrapper_camera_bin_src_vidsrc_probe), self);
+    gst_ghost_pad_set_target (GST_GHOST_PAD (self->imgsrc),
+        self->outsel_imgpad);
+    gst_ghost_pad_set_target (GST_GHOST_PAD (self->vidsrc),
+        self->outsel_vidpad);
+
+    if (bcamsrc->mode == MODE_IMAGE) {
+      g_object_set (self->output_selector, "active-pad", self->outsel_imgpad,
+          NULL);
+    } else {
+      g_object_set (self->output_selector, "active-pad", self->outsel_vidpad,
+          NULL);
+    }
+
+    /* hook-up the vf ghostpad */
+    vf_pad = gst_element_get_static_pad (videoscale, "src");
+    gst_ghost_pad_set_target (GST_GHOST_PAD (self->vfsrc), vf_pad);
+    gst_object_unref (vf_pad);
+
+    gst_pad_set_active (self->vfsrc, TRUE);
+    gst_pad_set_active (self->imgsrc, TRUE);    /* XXX ??? */
+    gst_pad_set_active (self->vidsrc, TRUE);    /* XXX ??? */
+  }
+  ret = TRUE;
+  self->elements_created = TRUE;
+done:
+  return ret;
+}
+
+static gboolean
+copy_missing_fields (GQuark field_id, const GValue * value, gpointer user_data)
+{
+  GstStructure *st = (GstStructure *) user_data;
+  const GValue *val = gst_structure_id_get_value (st, field_id);
+
+  if (G_UNLIKELY (val == NULL)) {
+    gst_structure_id_set_value (st, field_id, value);
+  }
+
+  return TRUE;
+}
+
+/**
+ * adapt_image_capture:
+ * @self: camerasrc object
+ * @in_caps: caps object that describes incoming image format
+ *
+ * Adjust capsfilters and crop according image capture caps if necessary.
+ * The captured image format from video source might be different from
+ * what application requested, so we can try to fix that in camerabin.
+ *
+ */
+static void
+adapt_image_capture (GstWrapperCameraBinSrc * self, GstCaps * in_caps)
+{
+  GstBaseCameraSrc *bcamsrc = GST_BASE_CAMERA_SRC (self);
+  GstStructure *in_st, *new_st, *req_st;
+  gint in_width = 0, in_height = 0, req_width = 0, req_height = 0, crop = 0;
+  gdouble ratio_w, ratio_h;
+  GstCaps *filter_caps = NULL;
+
+  GST_LOG_OBJECT (self, "in caps: %" GST_PTR_FORMAT, in_caps);
+  GST_LOG_OBJECT (self, "requested caps: %" GST_PTR_FORMAT,
+      self->image_capture_caps);
+
+  in_st = gst_caps_get_structure (in_caps, 0);
+  gst_structure_get_int (in_st, "width", &in_width);
+  gst_structure_get_int (in_st, "height", &in_height);
+
+  req_st = gst_caps_get_structure (self->image_capture_caps, 0);
+  gst_structure_get_int (req_st, "width", &req_width);
+  gst_structure_get_int (req_st, "height", &req_height);
+
+  GST_INFO_OBJECT (self, "we requested %dx%d, and got %dx%d", req_width,
+      req_height, in_width, in_height);
+
+  new_st = gst_structure_copy (req_st);
+  /* If new fields have been added, we need to copy them */
+  gst_structure_foreach (in_st, copy_missing_fields, new_st);
+
+  gst_structure_set (new_st, "width", G_TYPE_INT, in_width, "height",
+      G_TYPE_INT, in_height, NULL);
+
+  GST_LOG_OBJECT (self, "new image capture caps: %" GST_PTR_FORMAT, new_st);
+
+  /* Crop if requested aspect ratio differs from incoming frame aspect ratio */
+  if (self->src_zoom_crop) {
+
+    ratio_w = (gdouble) in_width / req_width;
+    ratio_h = (gdouble) in_height / req_height;
+
+    if (ratio_w < ratio_h) {
+      crop = in_height - (req_height * ratio_w);
+      self->base_crop_top = crop / 2;
+      self->base_crop_bottom = crop / 2;
+    } else {
+      crop = in_width - (req_width * ratio_h);
+      self->base_crop_left = crop / 2;
+      self->base_crop_right += crop / 2;
+    }
+
+    GST_INFO_OBJECT (self,
+        "setting base crop: left:%d, right:%d, top:%d, bottom:%d",
+        self->base_crop_left, self->base_crop_right, self->base_crop_top,
+        self->base_crop_bottom);
+    g_object_set (G_OBJECT (self->src_zoom_crop),
+        "top", self->base_crop_top,
+        "bottom", self->base_crop_bottom,
+        "left", self->base_crop_left, "right", self->base_crop_right, NULL);
+  }
+
+  /* Update capsfilters */
+  if (self->image_capture_caps) {
+    gst_caps_unref (self->image_capture_caps);
+  }
+  self->image_capture_caps = gst_caps_new_full (new_st, NULL);
+  set_capsfilter_caps (self, self->image_capture_caps);
+
+  /* Adjust the capsfilter before crop and videoscale elements if necessary */
+  if (in_width == bcamsrc->width && in_height == bcamsrc->height) {
+    GST_DEBUG_OBJECT (self, "no adaptation with resolution needed");
+  } else {
+    GST_DEBUG_OBJECT (self,
+        "changing %" GST_PTR_FORMAT " from %dx%d to %dx%d", self->src_filter,
+        bcamsrc->width, bcamsrc->height, in_width, in_height);
+    /* Apply the width and height to filter caps */
+    g_object_get (G_OBJECT (self->src_filter), "caps", &filter_caps, NULL);
+    filter_caps = gst_caps_make_writable (filter_caps);
+    gst_caps_set_simple (filter_caps, "width", G_TYPE_INT, in_width, "height",
+        G_TYPE_INT, in_height, NULL);
+    g_object_set (G_OBJECT (self->src_filter), "caps", filter_caps, NULL);
+    gst_caps_unref (filter_caps);
+  }
+}
+
+/**
+ * img_capture_prepared:
+ * @data: camerasrc object
+ * @caps: caps describing the prepared image format
+ *
+ * Callback which is called after image capture has been prepared.
+ */
+static void
+img_capture_prepared (gpointer data, GstCaps * caps)
+{
+  GstWrapperCameraBinSrc *self = GST_WRAPPER_CAMERA_BIN_SRC (data);
+
+  GST_INFO_OBJECT (self, "image capture prepared");
+
+  /* It is possible we are about to get something else that we requested */
+  if (!gst_caps_is_equal (self->image_capture_caps, caps)) {
+    adapt_image_capture (self, caps);
+  } else {
+    set_capsfilter_caps (self, self->image_capture_caps);
+  }
+}
+
+/**
+ *
+ */
+static gboolean
+start_image_capture (GstWrapperCameraBinSrc * self)
+{
+  GstBaseCameraSrc *bcamsrc = GST_BASE_CAMERA_SRC (self);
+  GstPhotography *photography = gst_base_camera_src_get_photography (bcamsrc);
+  gboolean ret = FALSE;
+  GstCaps *caps;
+
+  GST_DEBUG_OBJECT (self, "Starting image capture");
+
+  if (self->image_renegotiate) {
+    /* clean capsfilter caps so they don't interfere here */
+    g_object_set (self->src_filter, "caps", NULL, NULL);
+    if (self->src_zoom_filter)
+      g_object_set (self->src_zoom_filter, "caps", NULL, NULL);
+
+    caps = gst_pad_get_allowed_caps (self->imgsrc);
+
+    gst_caps_replace (&self->image_capture_caps, caps);
+    gst_caps_unref (caps);
+
+    self->image_renegotiate = FALSE;
+  }
+
+  if (photography) {
+    GST_DEBUG_OBJECT (self, "prepare image capture caps %" GST_PTR_FORMAT,
+        self->image_capture_caps);
+    ret = gst_photography_prepare_for_capture (photography,
+        (GstPhotoCapturePrepared) img_capture_prepared,
+        self->image_capture_caps, self);
+  } else {
+    g_mutex_unlock (bcamsrc->capturing_mutex);
+    gst_wrapper_camera_bin_reset_video_src_caps (self,
+        self->image_capture_caps);
+    g_mutex_lock (bcamsrc->capturing_mutex);
+    ret = TRUE;
+  }
+
+  return ret;
+}
+
+static gboolean
+gst_wrapper_camera_bin_src_set_mode (GstBaseCameraSrc * bcamsrc,
+    GstCameraBinMode mode)
+{
+  GstPhotography *photography = gst_base_camera_src_get_photography (bcamsrc);
+  GstWrapperCameraBinSrc *self = GST_WRAPPER_CAMERA_BIN_SRC (bcamsrc);
+
+  if (self->output_selector) {
+    if (mode == MODE_IMAGE) {
+      self->image_renegotiate = TRUE;
+      g_object_set (self->output_selector, "active-pad", self->outsel_imgpad,
+          NULL);
+    } else {
+      self->video_renegotiate = TRUE;
+      g_object_set (self->output_selector, "active-pad", self->outsel_vidpad,
+          NULL);
+    }
+  }
+  self->mode = mode;
+
+  if (photography) {
+    if (g_object_class_find_property (G_OBJECT_GET_CLASS (photography),
+            "capture-mode")) {
+      g_object_set (G_OBJECT (photography), "capture-mode", mode, NULL);
+    }
+  } else {
+    gst_wrapper_camera_bin_reset_video_src_caps (self, NULL);
+  }
+
+  return TRUE;
+}
+
+static gboolean
+set_videosrc_zoom (GstWrapperCameraBinSrc * self, gfloat zoom)
+{
+  gboolean ret = FALSE;
+
+  if (g_object_class_find_property (G_OBJECT_GET_CLASS (self->src_vid_src),
+          "zoom")) {
+    g_object_set (G_OBJECT (self->src_vid_src), "zoom", zoom, NULL);
+    ret = TRUE;
+  }
+  return ret;
+}
+
+static gboolean
+set_element_zoom (GstWrapperCameraBinSrc * self, gfloat zoom)
+{
+  gboolean ret = FALSE;
+  GstBaseCameraSrc *bcamsrc = GST_BASE_CAMERA_SRC (self);
+  gint w2_crop = 0, h2_crop = 0;
+  GstPad *pad_zoom_sink = NULL;
+  gint left = self->base_crop_left;
+  gint right = self->base_crop_right;
+  gint top = self->base_crop_top;
+  gint bottom = self->base_crop_bottom;
+
+  if (self->src_zoom_crop) {
+    /* Update capsfilters to apply the zoom */
+    GST_INFO_OBJECT (self, "zoom: %f, orig size: %dx%d", zoom,
+        bcamsrc->width, bcamsrc->height);
+
+    if (zoom != ZOOM_1X) {
+      w2_crop = (bcamsrc->width - (gint) (bcamsrc->width * ZOOM_1X / zoom)) / 2;
+      h2_crop =
+          (bcamsrc->height - (gint) (bcamsrc->height * ZOOM_1X / zoom)) / 2;
+
+      left += w2_crop;
+      right += w2_crop;
+      top += h2_crop;
+      bottom += h2_crop;
+
+      /* force number of pixels cropped from left to be even, to avoid slow code
+       * path on videoscale */
+      left &= 0xFFFE;
+    }
+
+    pad_zoom_sink = gst_element_get_static_pad (self->src_zoom_crop, "sink");
+
+    GST_INFO_OBJECT (self,
+        "sw cropping: left:%d, right:%d, top:%d, bottom:%d", left, right, top,
+        bottom);
+
+    GST_PAD_STREAM_LOCK (pad_zoom_sink);
+    g_object_set (self->src_zoom_crop, "left", left, "right", right, "top",
+        top, "bottom", bottom, NULL);
+    GST_PAD_STREAM_UNLOCK (pad_zoom_sink);
+    gst_object_unref (pad_zoom_sink);
+    ret = TRUE;
+  }
+  return ret;
+}
+
+static void
+gst_wrapper_camera_bin_src_set_zoom (GstBaseCameraSrc * bcamsrc, gfloat zoom)
+{
+  GstWrapperCameraBinSrc *self = GST_WRAPPER_CAMERA_BIN_SRC (bcamsrc);
+
+  GST_INFO_OBJECT (self, "setting zoom %f", zoom);
+
+  if (set_videosrc_zoom (self, zoom)) {
+    set_element_zoom (self, ZOOM_1X);
+    GST_INFO_OBJECT (self, "zoom set using videosrc");
+  } else if (set_element_zoom (self, zoom)) {
+    GST_INFO_OBJECT (self, "zoom set using gst elements");
+  } else {
+    GST_INFO_OBJECT (self, "setting zoom failed");
+  }
+}
+
+static GstCaps *
+gst_wrapper_camera_bin_src_get_allowed_input_caps (GstBaseCameraSrc * bcamsrc)
+{
+  GstWrapperCameraBinSrc *self = GST_WRAPPER_CAMERA_BIN_SRC (bcamsrc);
+  GstCaps *caps = NULL;
+  GstPad *pad = NULL, *peer_pad = NULL;
+  GstState state;
+  GstElement *videosrc;
+
+  videosrc = self->src_vid_src ? self->src_vid_src : self->app_vid_src;
+
+  if (!videosrc) {
+    GST_WARNING_OBJECT (self, "no videosrc, can't get allowed caps");
+    goto failed;
+  }
+
+  if (self->allowed_caps) {
+    GST_DEBUG_OBJECT (self, "returning cached caps");
+    goto done;
+  }
+
+  pad = gst_element_get_static_pad (videosrc, "src");
+
+  if (!pad) {
+    GST_WARNING_OBJECT (self, "no srcpad in videosrc");
+    goto failed;
+  }
+
+  state = GST_STATE (videosrc);
+
+  /* Make this function work also in NULL state */
+  if (state == GST_STATE_NULL) {
+    GST_DEBUG_OBJECT (self, "setting videosrc to ready temporarily");
+    peer_pad = gst_pad_get_peer (pad);
+    if (peer_pad) {
+      gst_pad_unlink (pad, peer_pad);
+    }
+    /* Set videosrc to READY to open video device */
+    gst_element_set_locked_state (videosrc, TRUE);
+    gst_element_set_state (videosrc, GST_STATE_READY);
+  }
+
+  self->allowed_caps = gst_pad_get_caps (pad);
+
+  /* Restore state and re-link if necessary */
+  if (state == GST_STATE_NULL) {
+    GST_DEBUG_OBJECT (self, "restoring videosrc state %d", state);
+    /* Reset videosrc to NULL state, some drivers seem to need this */
+    gst_element_set_state (videosrc, GST_STATE_NULL);
+    if (peer_pad) {
+      gst_pad_link (pad, peer_pad);
+      gst_object_unref (peer_pad);
+    }
+    gst_element_set_locked_state (videosrc, FALSE);
+  }
+
+  gst_object_unref (pad);
+
+done:
+  if (self->allowed_caps) {
+    caps = gst_caps_copy (self->allowed_caps);
+  }
+  GST_DEBUG_OBJECT (self, "allowed caps:%" GST_PTR_FORMAT, caps);
+failed:
+  return caps;
+}
+
+/**
+ * update_aspect_filter:
+ * @self: camerasrc object
+ * @new_caps: new caps of next buffers arriving to view finder sink element
+ *
+ * Updates aspect ratio capsfilter to maintain aspect ratio, if we need to
+ * scale frames for showing them in view finder.
+ */
+static void
+update_aspect_filter (GstWrapperCameraBinSrc * self, GstCaps * new_caps)
+{
+  // XXX why not instead add a preserve-aspect-ratio property to videoscale?
+#if 0
+  if (camera->flags & GST_CAMERABIN_FLAG_VIEWFINDER_SCALE) {
+    GstCaps *sink_caps, *ar_caps;
+    GstStructure *st;
+    gint in_w = 0, in_h = 0, sink_w = 0, sink_h = 0, target_w = 0, target_h = 0;
+    gdouble ratio_w, ratio_h;
+    GstPad *sink_pad;
+    const GValue *range;
+
+    sink_pad = gst_element_get_static_pad (camera->view_sink, "sink");
+
+    if (sink_pad) {
+      sink_caps = gst_pad_get_caps (sink_pad);
+      gst_object_unref (sink_pad);
+      if (sink_caps) {
+        if (!gst_caps_is_any (sink_caps)) {
+          GST_DEBUG_OBJECT (camera, "sink element caps %" GST_PTR_FORMAT,
+              sink_caps);
+          /* Get maximum resolution that view finder sink accepts */
+          st = gst_caps_get_structure (sink_caps, 0);
+          if (gst_structure_has_field_typed (st, "width", GST_TYPE_INT_RANGE)) {
+            range = gst_structure_get_value (st, "width");
+            sink_w = gst_value_get_int_range_max (range);
+          }
+          if (gst_structure_has_field_typed (st, "height", GST_TYPE_INT_RANGE)) {
+            range = gst_structure_get_value (st, "height");
+            sink_h = gst_value_get_int_range_max (range);
+          }
+          GST_DEBUG_OBJECT (camera, "sink element accepts max %dx%d", sink_w,
+              sink_h);
+
+          /* Get incoming frames' resolution */
+          if (sink_h && sink_w) {
+            st = gst_caps_get_structure (new_caps, 0);
+            gst_structure_get_int (st, "width", &in_w);
+            gst_structure_get_int (st, "height", &in_h);
+            GST_DEBUG_OBJECT (camera, "new caps with %dx%d", in_w, in_h);
+          }
+        }
+        gst_caps_unref (sink_caps);
+      }
+    }
+
+    /* If we get bigger frames than view finder sink accepts, then we scale.
+       If we scale we need to adjust aspect ratio capsfilter caps in order
+       to maintain aspect ratio while scaling. */
+    if (in_w && in_h && (in_w > sink_w || in_h > sink_h)) {
+      ratio_w = (gdouble) sink_w / in_w;
+      ratio_h = (gdouble) sink_h / in_h;
+
+      if (ratio_w < ratio_h) {
+        target_w = sink_w;
+        target_h = (gint) (ratio_w * in_h);
+      } else {
+        target_w = (gint) (ratio_h * in_w);
+        target_h = sink_h;
+      }
+
+      GST_DEBUG_OBJECT (camera, "setting %dx%d filter to maintain aspect ratio",
+          target_w, target_h);
+      ar_caps = gst_caps_copy (new_caps);
+      gst_caps_set_simple (ar_caps, "width", G_TYPE_INT, target_w, "height",
+          G_TYPE_INT, target_h, NULL);
+    } else {
+      GST_DEBUG_OBJECT (camera, "no scaling");
+      ar_caps = new_caps;
+    }
+
+    GST_DEBUG_OBJECT (camera, "aspect ratio filter caps %" GST_PTR_FORMAT,
+        ar_caps);
+    g_object_set (G_OBJECT (camera->aspect_filter), "caps", ar_caps, NULL);
+    if (ar_caps != new_caps)
+      gst_caps_unref (ar_caps);
+  }
+#endif
+}
+
+
+/**
+ * set_capsfilter_caps:
+ * @self: camerasrc object
+ * @new_caps: pointer to caps object to set
+ *
+ * Set given caps to camerabin capsfilters.
+ */
+static void
+set_capsfilter_caps (GstWrapperCameraBinSrc * self, GstCaps * new_caps)
+{
+  GST_INFO_OBJECT (self, "new_caps:%" GST_PTR_FORMAT, new_caps);
+
+  /* Update zoom */
+  gst_base_camera_src_setup_zoom (GST_BASE_CAMERA_SRC (self));
+
+  /* Update capsfilters */
+  g_object_set (G_OBJECT (self->src_filter), "caps", new_caps, NULL);
+  if (self->src_zoom_filter)
+    g_object_set (G_OBJECT (self->src_zoom_filter), "caps", new_caps, NULL);
+  update_aspect_filter (self, new_caps);
+  GST_INFO_OBJECT (self, "updated");
+}
+
+static gboolean
+gst_wrapper_camera_bin_src_start_capture (GstBaseCameraSrc * camerasrc)
+{
+  GstWrapperCameraBinSrc *src = GST_WRAPPER_CAMERA_BIN_SRC (camerasrc);
+
+  /* TODO should we access this directly? Maybe a macro is better? */
+  if (src->mode == MODE_IMAGE) {
+    start_image_capture (src);
+    src->image_capture_count = 1;
+  } else if (src->mode == MODE_VIDEO) {
+    GstCaps *caps = NULL;
+
+    if (src->video_renegotiate) {
+      g_mutex_unlock (camerasrc->capturing_mutex);
+      gst_wrapper_camera_bin_reset_video_src_caps (src, NULL);
+      g_mutex_lock (camerasrc->capturing_mutex);
+
+      /* clean capsfilter caps so they don't interfere here */
+      g_object_set (src->src_filter, "caps", NULL, NULL);
+      if (src->src_zoom_filter)
+        g_object_set (src->src_zoom_filter, "caps", NULL, NULL);
+
+      GST_DEBUG_OBJECT (src, "Getting allowed videosrc caps");
+      caps = gst_pad_get_allowed_caps (src->vidsrc);
+      GST_DEBUG_OBJECT (src, "Video src caps %" GST_PTR_FORMAT, caps);
+
+      src->video_renegotiate = FALSE;
+      g_mutex_unlock (camerasrc->capturing_mutex);
+      gst_wrapper_camera_bin_reset_video_src_caps (src, caps);
+      g_mutex_lock (camerasrc->capturing_mutex);
+      gst_caps_unref (caps);
+    }
+    if (src->video_rec_status == GST_VIDEO_RECORDING_STATUS_DONE) {
+      src->video_rec_status = GST_VIDEO_RECORDING_STATUS_STARTING;
+    }
+  } else {
+    g_assert_not_reached ();
+    return FALSE;
+  }
+  return TRUE;
+}
+
+static void
+gst_wrapper_camera_bin_src_stop_capture (GstBaseCameraSrc * camerasrc)
+{
+  GstWrapperCameraBinSrc *src = GST_WRAPPER_CAMERA_BIN_SRC (camerasrc);
+
+  /* TODO shoud we access this directly? Maybe a macro is better? */
+  if (src->mode == MODE_VIDEO) {
+    if (src->video_rec_status == GST_VIDEO_RECORDING_STATUS_STARTING) {
+      GST_DEBUG_OBJECT (src, "Aborting, had not started recording");
+      src->video_rec_status = GST_VIDEO_RECORDING_STATUS_DONE;
+
+    } else if (src->video_rec_status == GST_VIDEO_RECORDING_STATUS_RUNNING) {
+      GST_DEBUG_OBJECT (src, "Marking video recording as finishing");
+      src->video_rec_status = GST_VIDEO_RECORDING_STATUS_FINISHING;
+    }
+  } else {
+    src->image_capture_count = 0;
+  }
+}
+
+static GstStateChangeReturn
+gst_wrapper_camera_bin_src_change_state (GstElement * element,
+    GstStateChange trans)
+{
+  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
+  GstWrapperCameraBinSrc *self = GST_WRAPPER_CAMERA_BIN_SRC (element);
+
+  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, trans);
+
+  if (ret == GST_STATE_CHANGE_FAILURE)
+    goto end;
+
+  switch (trans) {
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      self->video_renegotiate = TRUE;
+      self->image_renegotiate = TRUE;
+      self->drop_newseg = FALSE;
+      break;
+    case GST_STATE_CHANGE_READY_TO_NULL:
+      break;
+    case GST_STATE_CHANGE_NULL_TO_READY:
+      break;
+    default:
+      break;
+  }
+
+end:
+  return ret;
+}
+
+static void
+gst_wrapper_camera_bin_src_base_init (gpointer g_class)
+{
+  GstElementClass *gstelement_class = GST_ELEMENT_CLASS (g_class);
+
+  GST_DEBUG_CATEGORY_INIT (wrapper_camera_bin_src_debug, "wrappercamerabinsrc",
+      0, "V4l2 camera src");
+
+  gst_element_class_set_details_simple (gstelement_class,
+      "V4l2 camera src element for camerabin", "Source/Video",
+      "V4l2 camera src element for camerabin", "Rob Clark <rob@ti.com>");
+}
+
+static void
+gst_wrapper_camera_bin_src_class_init (GstWrapperCameraBinSrcClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *gstelement_class;
+  GstBaseCameraSrcClass *gstbasecamerasrc_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gstelement_class = GST_ELEMENT_CLASS (klass);
+  gstbasecamerasrc_class = GST_BASE_CAMERA_SRC_CLASS (klass);
+
+  gobject_class->dispose = gst_wrapper_camera_bin_src_dispose;
+  gobject_class->finalize =
+      (GObjectFinalizeFunc) gst_wrapper_camera_bin_src_finalize;
+  gobject_class->set_property = gst_wrapper_camera_bin_src_set_property;
+  gobject_class->get_property = gst_wrapper_camera_bin_src_get_property;
+
+  /* g_object_class_install_property .... */
+  g_object_class_install_property (gobject_class, PROP_VIDEO_SRC,
+      g_param_spec_object ("video-src", "Video source",
+          "The video source element to be used",
+          GST_TYPE_ELEMENT, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  gstelement_class->change_state = gst_wrapper_camera_bin_src_change_state;
+
+  gstbasecamerasrc_class->construct_pipeline =
+      gst_wrapper_camera_bin_src_construct_pipeline;
+  gstbasecamerasrc_class->set_zoom = gst_wrapper_camera_bin_src_set_zoom;
+  gstbasecamerasrc_class->set_mode = gst_wrapper_camera_bin_src_set_mode;
+  gstbasecamerasrc_class->get_allowed_input_caps =
+      gst_wrapper_camera_bin_src_get_allowed_input_caps;
+  gstbasecamerasrc_class->start_capture =
+      gst_wrapper_camera_bin_src_start_capture;
+  gstbasecamerasrc_class->stop_capture =
+      gst_wrapper_camera_bin_src_stop_capture;
+}
+
+static void
+gst_wrapper_camera_bin_src_init (GstWrapperCameraBinSrc * self,
+    GstWrapperCameraBinSrcClass * klass)
+{
+  self->vfsrc =
+      gst_ghost_pad_new_no_target (GST_BASE_CAMERA_SRC_VIEWFINDER_PAD_NAME,
+      GST_PAD_SRC);
+  gst_element_add_pad (GST_ELEMENT (self), self->vfsrc);
+
+  self->imgsrc =
+      gst_ghost_pad_new_no_target (GST_BASE_CAMERA_SRC_IMAGE_PAD_NAME,
+      GST_PAD_SRC);
+  gst_element_add_pad (GST_ELEMENT (self), self->imgsrc);
+
+  self->vidsrc =
+      gst_ghost_pad_new_no_target (GST_BASE_CAMERA_SRC_VIDEO_PAD_NAME,
+      GST_PAD_SRC);
+  gst_element_add_pad (GST_ELEMENT (self), self->vidsrc);
+
+  self->srcpad_event_func = GST_PAD_EVENTFUNC (self->vfsrc);
+
+  gst_pad_set_event_function (self->imgsrc, gst_wrapper_camera_bin_src_event);
+  gst_pad_set_event_function (self->vidsrc, gst_wrapper_camera_bin_src_event);
+  gst_pad_set_event_function (self->vfsrc, gst_wrapper_camera_bin_src_event);
+
+  /* TODO where are variables reset? */
+  self->image_capture_count = 0;
+  self->video_rec_status = GST_VIDEO_RECORDING_STATUS_DONE;
+  self->video_renegotiate = TRUE;
+  self->image_renegotiate = TRUE;
+  self->mode = GST_BASE_CAMERA_SRC_CAST (self)->mode;
+}
+
+gboolean
+gst_wrapper_camera_bin_src_plugin_init (GstPlugin * plugin)
+{
+  return gst_element_register (plugin, "wrappercamerabinsrc", GST_RANK_NONE,
+      gst_wrapper_camera_bin_src_get_type ());
+}
diff --git a/gst/camerabin2/gstwrappercamerabinsrc.h b/gst/camerabin2/gstwrappercamerabinsrc.h
new file mode 100644
index 0000000..ccc1ef6
--- /dev/null
+++ b/gst/camerabin2/gstwrappercamerabinsrc.h
@@ -0,0 +1,129 @@
+/*
+ * GStreamer
+ * Copyright (C) 2010 Texas Instruments, Inc
+ * Copyright (C) 2010 Thiago Santos <thiago.sousa.santos@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+
+#ifndef __GST_WRAPPER_CAMERA_BIN_SRC_H__
+#define __GST_WRAPPER_CAMERA_BIN_SRC_H__
+
+#include <gst/gst.h>
+#include <gst/basecamerabinsrc/gstbasecamerasrc.h>
+#include <gst/basecamerabinsrc/gstcamerabinpreview.h>
+#include "camerabingeneral.h"
+
+G_BEGIN_DECLS
+#define GST_TYPE_WRAPPER_CAMERA_BIN_SRC \
+  (gst_wrapper_camera_bin_src_get_type())
+#define GST_WRAPPER_CAMERA_BIN_SRC(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_WRAPPER_CAMERA_BIN_SRC,GstWrapperCameraBinSrc))
+#define GST_WRAPPER_CAMERA_BIN_SRC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_WRAPPER_CAMERA_BIN_SRC,GstWrapperCameraBinSrcClass))
+#define GST_IS_WRAPPER_CAMERA_BIN_SRC(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_WRAPPER_CAMERA_BIN_SRC))
+#define GST_IS_WRAPPER_CAMERA_BIN_SRC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_WRAPPER_CAMERA_BIN_SRC))
+    GType gst_wrapper_camera_bin_src_get_type (void);
+
+typedef struct _GstWrapperCameraBinSrc GstWrapperCameraBinSrc;
+typedef struct _GstWrapperCameraBinSrcClass GstWrapperCameraBinSrcClass;
+
+enum GstVideoRecordingStatus {
+  GST_VIDEO_RECORDING_STATUS_DONE,
+  GST_VIDEO_RECORDING_STATUS_STARTING,
+  GST_VIDEO_RECORDING_STATUS_RUNNING,
+  GST_VIDEO_RECORDING_STATUS_FINISHING
+};
+
+
+/**
+ * GstWrapperCameraBinSrc:
+ *
+ */
+struct _GstWrapperCameraBinSrc
+{
+  GstBaseCameraSrc parent;
+
+  GstCameraBinMode mode;
+
+  GstPad *vfsrc;
+  GstPad *imgsrc;
+  GstPad *vidsrc;
+
+  /* video recording controls */
+  gint video_rec_status;
+
+  /* image capture controls */
+  gint image_capture_count;
+
+  /* source elements */
+  GstElement *src_vid_src;
+  GstElement *src_filter;
+  GstElement *src_zoom_crop;
+  GstElement *src_zoom_scale;
+  GstElement *src_zoom_filter;
+  GstElement *output_selector;
+
+  gboolean elements_created;
+
+  guint src_event_probe_id;
+
+  GstPad *outsel_imgpad;
+  GstPad *outsel_vidpad;
+
+  GstPadEventFunction srcpad_event_func;
+
+  /* For changing caps without losing timestamps */
+  gboolean drop_newseg;
+
+  /* Application configurable elements */
+  GstElement *app_vid_src;
+
+  /* Caps that videosrc supports */
+  GstCaps *allowed_caps;
+
+  /* Optional base crop for frames. Used to crop frames e.g.
+     due to wrong aspect ratio, before the crop related to zooming. */
+  gint base_crop_top;
+  gint base_crop_bottom;
+  gint base_crop_left;
+  gint base_crop_right;
+
+  /* Caps applied to capsfilters when in view finder mode */
+  GstCaps *view_finder_caps;
+
+  /* Caps applied to capsfilters when taking still image */
+  GstCaps *image_capture_caps;
+  gboolean image_renegotiate;
+  gboolean video_renegotiate;
+};
+
+
+/**
+ * GstWrapperCameraBinSrcClass:
+ *
+ */
+struct _GstWrapperCameraBinSrcClass
+{
+  GstBaseCameraSrcClass parent;
+};
+
+gboolean gst_wrapper_camera_bin_src_plugin_init (GstPlugin * plugin);
+
+#endif /* __GST_WRAPPER_CAMERA_BIN_SRC_H__ */
diff --git a/tests/check/Makefile.am b/tests/check/Makefile.am
index 3d0e9cc..aaf77c3 100644
--- a/tests/check/Makefile.am
+++ b/tests/check/Makefile.am
@@ -14,7 +14,7 @@ TESTS_ENVIRONMENT = \
 	GST_PLUGIN_SYSTEM_PATH=					\
 	GST_PLUGIN_PATH=$(top_builddir)/gst:$(top_builddir)/sys:$(top_builddir)/ext:$(top_builddir)/../gst-ffmpeg/ext/ffmpeg:$(top_builddir)/../gst-plugins-good/gst:$(top_builddir)/../gst-plugins-good/sys:$(top_builddir)/../gst-plugins-good/ext:$(top_builddir)/../gst-plugins-ugly/gst:$(top_builddir)/../gst-plugins-ugly/sys:$(top_builddir)/../gst-plugins-ugly/ext:$(GSTPB_PLUGINS_DIR):$(GST_PLUGINS_DIR) \
 	GST_PLUGIN_LOADING_WHITELIST="gstreamer@$(GST_PLUGINS_DIR):gst-plugins-base@$(GSTPB_PLUGINS_DIR):gst-plugins-good:gst-plugins-ugly:gst-ffmpeg:gst-plugins-bad@$(top_builddir)" \
-	STATE_IGNORE_ELEMENTS="alsaspdifsink apexsink camerabin cdaudio dc1394src dccpclientsrc dccpclientsink dccpserversrc dccpserversink dvbsrc dvbbasebin dfbvideosink festival gsettingsvideosrc gsettingsvideosink gsettingsaudiosrc gsettingsaudiosink nassink rsndvdbin sdlaudiosink sdlvideosink vcdsrc rfbsrc vdpauyuvvideo vdpauvideoyuv vdpaumpegdec neonhttpsrc"
+	STATE_IGNORE_ELEMENTS="alsaspdifsink apexsink camerabin camerabin2 cdaudio dc1394src dccpclientsrc dccpclientsink dccpserversrc dccpserversink dvbsrc dvbbasebin dfbvideosink festival gsettingsvideosrc gsettingsvideosink gsettingsaudiosrc gsettingsaudiosink nassink rsndvdbin sdlaudiosink sdlvideosink vcdsrc rfbsrc vdpauyuvvideo vdpauvideoyuv vdpaumpegdec neonhttpsrc"
 
 plugindir = $(libdir)/gstreamer-@GST_MAJORMINOR@
 
@@ -144,7 +144,9 @@ check_PROGRAMS = \
 	elements/autoconvert \
 	elements/asfmux \
 	elements/camerabin \
+	elements/camerabin2 \
 	elements/dataurisrc \
+	elements/imagecapturebin \
 	elements/legacyresample \
         $(check_jifmux) \
 	elements/jpegparse \
@@ -159,7 +161,8 @@ check_PROGRAMS = \
 	elements/rtpmux \
 	$(check_vp8) \
 	$(check_orc) \
-        pipelines/tagschecking
+	pipelines/tagschecking \
+	elements/viewfinderbin
 
 noinst_HEADERS = elements/mxfdemux.h elements/amrparse_data.h elements/aacparse_data.h
 
@@ -180,6 +183,24 @@ elements_camerabin_LDADD = \
          -lgstinterfaces-@GST_MAJORMINOR@
 elements_camerabin_SOURCES = elements/camerabin.c
 
+elements_camerabin2_CFLAGS = \
+  $(GST_PLUGINS_BAD_CFLAGS) $(GST_PLUGINS_BASE_CFLAGS) \
+  $(GST_BASE_CFLAGS) $(GST_CFLAGS) $(AM_CFLAGS) -DGST_USE_UNSTABLE_API
+elements_camerabin2_LDADD = \
+        $(top_builddir)/gst-libs/gst/interfaces/libgstphotography-@GST_MAJORMINOR@.la \
+        $(top_builddir)/gst-libs/gst/basecamerabinsrc/libgstbasecamerabinsrc-@GST_MAJORMINOR@.la \
+        -lgstpbutils-$(GST_MAJORMINOR) \
+        $(GST_PLUGINS_BASE_LIBS) $(GST_BASE_LIBS) $(GST_LIBS) $(LDADD)
+elements_camerabin2_SOURCES = elements/camerabin2.c
+
+elements_imagecapturebin_CFLAGS = \
+  $(GST_PLUGINS_BAD_CFLAGS) $(GST_PLUGINS_BASE_CFLAGS) \
+  $(GST_BASE_CFLAGS) $(GST_CFLAGS) $(AM_CFLAGS) -DGST_USE_UNSTABLE_API
+elements_imagecapturebin_LDADD = \
+  $(GST_PLUGINS_BASE_LIBS) -lgstapp-@GST_MAJORMINOR@ \
+  $(GST_BASE_LIBS) $(GST_LIBS) $(LDADD)
+elements_imagecapturebin_SOURCES = elements/imagecapturebin.c
+
 elements_jifmux_CFLAGS = $(GST_OBJ_CFLAGS) $(GST_CHECK_CFLAGS) $(CHECK_CFLAGS) $(GST_OPTION_CFLAGS) $(AM_CFLAGS) $(EXIF_CFLAGS)
 elements_jifmux_LDADD = $(GST_OBJ_LIBS) $(GST_CHECK_LIBS) $(CHECK_LIBS) $(EXIF_LIBS) $(LDADD)
 elements_jifmux_SOURCES = elements/jifmux.c
diff --git a/tests/check/elements/camerabin2.c b/tests/check/elements/camerabin2.c
new file mode 100644
index 0000000..4fc5caa
--- /dev/null
+++ b/tests/check/elements/camerabin2.c
@@ -0,0 +1,1367 @@
+/* GStreamer
+ *
+ * unit test for camerabin2 basic operations
+ * Copyright (C) 2010 Nokia Corporation <multimedia@maemo.org>
+ * Copyright (C) 2010 Thiago Santos <thiago.sousa.santos@collabora.co.uk>
+ *
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include <unistd.h>
+#include <glib.h>
+#include <gst/gst.h>
+#include <gst/video/video.h>
+#include <gst/check/gstcheck.h>
+#include <gst/basecamerabinsrc/gstbasecamerasrc.h>
+#include <gst/pbutils/encoding-profile.h>
+
+#define IMAGE_FILENAME "image"
+#define VIDEO_FILENAME "video"
+#define CAPTURE_COUNT 3
+#define VIDEO_DURATION 5
+
+#define VIDEO_PAD_SUPPORTED_CAPS GST_VIDEO_CAPS_RGB ", width=600, height=480"
+#define IMAGE_PAD_SUPPORTED_CAPS GST_VIDEO_CAPS_RGB ", width=800, height=600"
+
+/* custom test camera src element */
+#define GST_TYPE_TEST_CAMERA_SRC \
+  (gst_test_camera_src_get_type())
+#define GST_TEST_CAMERA_SRC(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_TEST_CAMERA_SRC,GstTestCameraSrc))
+#define GST_TEST_CAMERA_SRC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_TEST_CAMERA_SRC,GstTestCameraSrcClass))
+#define GST_IS_TEST_REVERSE_NEGOTIATION_SINK(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_TEST_CAMERA_SRC))
+#define GST_IS_TEST_REVERSE_NEGOTIATION_SINK_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_TEST_CAMERA_SRC))
+#define GST_TEST_CAMERA_SRC_CAST(obj) ((GstTestCameraSrc *)obj)
+
+typedef struct _GstTestCameraSrc GstTestCameraSrc;
+typedef struct _GstTestCameraSrcClass GstTestCameraSrcClass;
+struct _GstTestCameraSrc
+{
+  GstBaseCameraSrc element;
+
+  GstPad *vfpad;
+  GstPad *vidpad;
+  GstPad *imgpad;
+
+  GstCameraBinMode mode;
+};
+
+struct _GstTestCameraSrcClass
+{
+  GstBaseCameraSrcClass parent_class;
+};
+
+GType gst_test_camera_src_get_type (void);
+
+GST_BOILERPLATE (GstTestCameraSrc,
+    gst_test_camera_src, GstBaseCameraSrc, GST_TYPE_BASE_CAMERA_SRC);
+
+static gboolean
+gst_test_camera_src_set_mode (GstBaseCameraSrc * src, GstCameraBinMode mode)
+{
+  GstTestCameraSrc *self = GST_TEST_CAMERA_SRC (src);
+
+  self->mode = mode;
+  return TRUE;
+}
+
+static GstCaps *
+gst_test_camera_src_get_caps (GstPad * pad)
+{
+  GstTestCameraSrc *self = (GstTestCameraSrc *) GST_PAD_PARENT (pad);
+  GstCaps *result = NULL;
+
+  if (pad == self->vfpad) {
+    result = gst_caps_new_any ();
+  } else if (pad == self->vidpad) {
+    result = gst_caps_from_string (VIDEO_PAD_SUPPORTED_CAPS);
+  } else if (pad == self->imgpad) {
+    result = gst_caps_from_string (IMAGE_PAD_SUPPORTED_CAPS);
+  } else {
+    g_assert_not_reached ();
+  }
+
+  return result;
+}
+
+static void
+gst_test_camera_src_base_init (gpointer g_class)
+{
+  GstElementClass *gstelement_class = GST_ELEMENT_CLASS (g_class);
+
+  gst_element_class_set_details_simple (gstelement_class,
+      "Test Camera Src",
+      "Camera/Src",
+      "Some test camera src",
+      "Thiago Santos <thiago.sousa.santos@collabora.co.uk>");
+}
+
+static void
+gst_test_camera_src_class_init (GstTestCameraSrcClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *gstelement_class;
+  GstBaseCameraSrcClass *gstbasecamera_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gstelement_class = GST_ELEMENT_CLASS (klass);
+  gstbasecamera_class = GST_BASE_CAMERA_SRC_CLASS (klass);
+
+  gstbasecamera_class->set_mode = gst_test_camera_src_set_mode;
+}
+
+static void
+gst_test_camera_src_init (GstTestCameraSrc * self,
+    GstTestCameraSrcClass * g_class)
+{
+  GstElementClass *gstelement_class = GST_ELEMENT_CLASS (g_class);
+  GstPadTemplate *template;
+
+  /* create pads */
+  template = gst_element_class_get_pad_template (gstelement_class,
+      GST_BASE_CAMERA_SRC_VIEWFINDER_PAD_NAME);
+  self->vfpad = gst_pad_new_from_template (template,
+      GST_BASE_CAMERA_SRC_VIEWFINDER_PAD_NAME);
+  gst_element_add_pad (GST_ELEMENT_CAST (self), self->vfpad);
+
+  template = gst_element_class_get_pad_template (gstelement_class,
+      GST_BASE_CAMERA_SRC_IMAGE_PAD_NAME);
+  self->imgpad = gst_pad_new_from_template (template,
+      GST_BASE_CAMERA_SRC_IMAGE_PAD_NAME);
+  gst_element_add_pad (GST_ELEMENT_CAST (self), self->imgpad);
+
+  template = gst_element_class_get_pad_template (gstelement_class,
+      GST_BASE_CAMERA_SRC_VIDEO_PAD_NAME);
+  self->vidpad = gst_pad_new_from_template (template,
+      GST_BASE_CAMERA_SRC_VIDEO_PAD_NAME);
+  gst_element_add_pad (GST_ELEMENT_CAST (self), self->vidpad);
+
+  /* add get caps functions */
+  gst_pad_set_getcaps_function (self->vfpad, gst_test_camera_src_get_caps);
+  gst_pad_set_getcaps_function (self->vidpad, gst_test_camera_src_get_caps);
+  gst_pad_set_getcaps_function (self->imgpad, gst_test_camera_src_get_caps);
+}
+
+/* end of custom test camera src element */
+
+
+static GstElement *camera;
+static GMainLoop *main_loop;
+guint32 test_id = 0;
+
+static GstBuffer *preview_buffer;
+static GstCaps *preview_caps;
+static GstTagList *tags_found;
+
+static gboolean
+validity_bus_cb (GstBus * bus, GstMessage * message, gpointer data);
+
+static void
+validate_taglist_foreach (const GstTagList * list, const gchar * tag,
+    gpointer user_data)
+{
+  GstTagList *other = GST_TAG_LIST (user_data);
+
+  const GValue *val1 = gst_tag_list_get_value_index (list, tag, 0);
+  const GValue *val2 = gst_tag_list_get_value_index (other, tag, 0);
+
+  fail_if (val1 == NULL);
+  fail_if (val2 == NULL);
+
+  fail_unless (gst_value_can_intersect (val1, val2));
+}
+
+
+/* helper function for filenames */
+static const gchar *
+make_test_file_name (const gchar * base_name, gint num)
+{
+  static gchar file_name[1000];
+
+  /* num == -1 means to keep the %d in the resulting string to be used on
+   * multifilesink like location */
+  if (num == -1) {
+    g_snprintf (file_name, 999, "%s" G_DIR_SEPARATOR_S
+        "gstcamerabin2test_%s_%u_%%03d.cap", g_get_tmp_dir (), base_name,
+        test_id);
+  } else {
+    g_snprintf (file_name, 999, "%s" G_DIR_SEPARATOR_S
+        "gstcamerabin2test_%s_%u_%03d.cap", g_get_tmp_dir (), base_name,
+        test_id, num);
+  }
+
+  GST_INFO ("capturing to: %s", file_name);
+  return file_name;
+}
+
+/* configuration */
+
+static gboolean
+capture_bus_cb (GstBus * bus, GstMessage * message, gpointer data)
+{
+  GMainLoop *loop = (GMainLoop *) data;
+  const GstStructure *st;
+
+  switch (GST_MESSAGE_TYPE (message)) {
+    case GST_MESSAGE_ERROR:{
+      GError *err = NULL;
+      gchar *debug = NULL;
+
+      gst_message_parse_error (message, &err, &debug);
+      GST_WARNING ("ERROR: %s [%s]", err->message, debug);
+      g_error_free (err);
+      g_free (debug);
+      /* Write debug graph to file */
+      GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS (GST_BIN (camera),
+          GST_DEBUG_GRAPH_SHOW_ALL, "camerabin.error");
+
+      fail_if (TRUE, "error while capturing");
+      g_main_loop_quit (loop);
+      break;
+    }
+    case GST_MESSAGE_WARNING:{
+      GError *err = NULL;
+      gchar *debug = NULL;
+
+      gst_message_parse_warning (message, &err, &debug);
+      GST_WARNING ("WARNING: %s [%s]", err->message, debug);
+      g_error_free (err);
+      g_free (debug);
+      /* Write debug graph to file */
+      GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS (GST_BIN (camera),
+          GST_DEBUG_GRAPH_SHOW_ALL, "camerabin.warning");
+      break;
+    }
+    case GST_MESSAGE_EOS:
+      GST_DEBUG ("eos");
+      g_main_loop_quit (loop);
+      break;
+    default:
+      st = gst_message_get_structure (message);
+      if (st && gst_structure_has_name (st, "image-captured")) {
+        gboolean ready = FALSE;
+        GST_INFO ("image captured");
+        g_object_get (camera, "ready-for-capture", &ready, NULL);
+        fail_if (!ready, "not ready for capture");
+      } else if (st && gst_structure_has_name (st,
+              GST_BASE_CAMERA_SRC_PREVIEW_MESSAGE_NAME)) {
+        GstBuffer *buf;
+        const GValue *value;
+
+        value = gst_structure_get_value (st, "buffer");
+        fail_unless (value != NULL);
+        buf = gst_value_get_buffer (value);
+
+        if (preview_buffer)
+          gst_buffer_unref (preview_buffer);
+        preview_buffer = gst_buffer_ref (buf);
+      }
+      break;
+  }
+  return TRUE;
+}
+
+static void
+check_preview_image (void)
+{
+  fail_unless (preview_buffer != NULL);
+  if (preview_caps) {
+    fail_unless (GST_BUFFER_CAPS (preview_buffer) != NULL);
+    fail_unless (gst_caps_can_intersect (GST_BUFFER_CAPS (preview_buffer),
+            preview_caps));
+  }
+}
+
+static void
+extract_jpeg_tags (const gchar * filename, gint num)
+{
+  GstBus *bus;
+  GMainLoop *loop = g_main_loop_new (NULL, FALSE);
+  const gchar *filepath = make_test_file_name (filename, num);
+  gchar *pipeline_str = g_strdup_printf ("filesrc location=%s ! "
+      "jpegparse ! fakesink", filepath);
+  GstElement *pipeline;
+
+  pipeline = gst_parse_launch (pipeline_str, NULL);
+  fail_unless (pipeline != NULL);
+  g_free (pipeline_str);
+
+  bus = gst_pipeline_get_bus (GST_PIPELINE (pipeline));
+  gst_bus_add_watch (bus, (GstBusFunc) validity_bus_cb, loop);
+
+  gst_element_set_state (pipeline, GST_STATE_PLAYING);
+  g_main_loop_run (loop);
+  gst_element_set_state (pipeline, GST_STATE_NULL);
+
+  gst_object_unref (bus);
+  gst_object_unref (pipeline);
+}
+
+static void
+setup_wrappercamerabinsrc_videotestsrc (void)
+{
+  GstBus *bus;
+  GstElement *vfbin;
+  GstElement *fakevideosink;
+  GstElement *src;
+  GstElement *testsrc;
+
+  GST_INFO ("init");
+
+  test_id = g_random_int ();
+
+  main_loop = g_main_loop_new (NULL, TRUE);
+
+  camera = gst_check_setup_element ("camerabin2");
+  fakevideosink = gst_element_factory_make ("fakesink", NULL);
+  src = gst_element_factory_make ("wrappercamerabinsrc", NULL);
+  testsrc = gst_element_factory_make ("videotestsrc", NULL);
+
+  preview_caps = gst_caps_new_simple ("video/x-raw-rgb", "width", G_TYPE_INT,
+      320, "height", G_TYPE_INT, 240, NULL);
+
+  g_object_set (G_OBJECT (testsrc), "is-live", TRUE, "peer-alloc", FALSE, NULL);
+  g_object_set (G_OBJECT (src), "video-src", testsrc, NULL);
+  g_object_set (G_OBJECT (camera), "camera-src", src, "preview-caps",
+      preview_caps, NULL);
+  gst_object_unref (src);
+  gst_object_unref (testsrc);
+
+  vfbin = gst_bin_get_by_name (GST_BIN (camera), "vf-bin");
+  g_object_set (G_OBJECT (vfbin), "video-sink", fakevideosink, NULL);
+  gst_object_unref (vfbin);
+  gst_object_unref (fakevideosink);
+
+  bus = gst_pipeline_get_bus (GST_PIPELINE (camera));
+  gst_bus_add_watch (bus, (GstBusFunc) capture_bus_cb, main_loop);
+  gst_object_unref (bus);
+
+  GST_INFO ("init finished");
+}
+
+static void
+teardown (void)
+{
+  gst_element_set_state (camera, GST_STATE_NULL);
+
+  if (camera)
+    gst_check_teardown_element (camera);
+  camera = NULL;
+
+  if (main_loop)
+    g_main_loop_unref (main_loop);
+  main_loop = NULL;
+
+  if (preview_caps)
+    gst_caps_unref (preview_caps);
+  preview_caps = NULL;
+
+  if (preview_buffer)
+    gst_buffer_unref (preview_buffer);
+  preview_buffer = NULL;
+
+  if (tags_found)
+    gst_tag_list_free (tags_found);
+  tags_found = NULL;
+
+  GST_INFO ("done");
+}
+
+static gboolean
+validity_bus_cb (GstBus * bus, GstMessage * message, gpointer data)
+{
+  GMainLoop *loop = (GMainLoop *) data;
+  switch (GST_MESSAGE_TYPE (message)) {
+    case GST_MESSAGE_ERROR:{
+      GError *err = NULL;
+      gchar *debug = NULL;
+
+      gst_message_parse_error (message, &err, &debug);
+
+      GST_ERROR ("Error: %s : %s", err->message, debug);
+      g_error_free (err);
+      g_free (debug);
+
+      fail_if (TRUE, "validating captured data failed");
+      g_main_loop_quit (loop);
+    }
+      break;
+    case GST_MESSAGE_EOS:
+      g_main_loop_quit (loop);
+      GST_DEBUG ("eos");
+      break;
+    case GST_MESSAGE_TAG:{
+      GstTagList *taglist = NULL;
+
+      gst_message_parse_tag (message, &taglist);
+      if (tags_found) {
+        gst_tag_list_insert (tags_found, taglist, GST_TAG_MERGE_REPLACE);
+        gst_tag_list_free (taglist);
+      } else {
+        tags_found = taglist;
+      }
+    }
+      break;
+    default:
+      break;
+  }
+  return TRUE;
+}
+
+/* checks that tags in @tags_a are in @tags_b */
+static gboolean
+taglist_is_subset (GstTagList * tags_a, GstTagList * tags_b)
+{
+  gst_tag_list_foreach (tags_a, validate_taglist_foreach, tags_b);
+  return TRUE;
+}
+
+/* Validate captured files by playing them with playbin
+ * and checking that no errors occur. */
+#define WITH_AUDIO TRUE
+#define NO_AUDIO FALSE
+static gboolean
+check_file_validity (const gchar * filename, gint num, GstTagList * taglist,
+    gint width, gint height, gboolean has_audio)
+{
+  GstBus *bus;
+  GstPad *pad;
+  GstCaps *caps;
+  gint caps_width, caps_height;
+  GstState state;
+
+  GMainLoop *loop = g_main_loop_new (NULL, FALSE);
+  GstElement *playbin = gst_element_factory_make ("playbin2", NULL);
+  GstElement *fakevideo = gst_element_factory_make ("fakesink", NULL);
+  GstElement *fakeaudio = gst_element_factory_make ("fakesink", NULL);
+  gchar *uri = g_strconcat ("file://", make_test_file_name (filename, num),
+      NULL);
+
+  GST_DEBUG ("checking uri: %s", uri);
+  g_object_set (G_OBJECT (playbin), "uri", uri, "video-sink", fakevideo,
+      "audio-sink", fakeaudio, NULL);
+
+  bus = gst_pipeline_get_bus (GST_PIPELINE (playbin));
+  gst_bus_add_watch (bus, (GstBusFunc) validity_bus_cb, loop);
+
+  gst_element_set_state (playbin, GST_STATE_PAUSED);
+  gst_element_get_state (playbin, &state, NULL, GST_SECOND * 3);
+
+  if (width != 0 && height != 0) {
+    g_signal_emit_by_name (playbin, "get-video-pad", 0, &pad, NULL);
+    g_assert (pad != NULL);
+    caps = gst_pad_get_negotiated_caps (pad);
+
+    g_assert (gst_structure_get_int (gst_caps_get_structure (caps, 0),
+            "width", &caps_width));
+    g_assert (gst_structure_get_int (gst_caps_get_structure (caps, 0),
+            "height", &caps_height));
+
+    g_assert (width == caps_width);
+    g_assert (height == caps_height);
+
+    gst_caps_unref (caps);
+    gst_object_unref (pad);
+  }
+  if (has_audio) {
+    g_signal_emit_by_name (playbin, "get-audio-pad", 0, &pad, NULL);
+    g_assert (pad != NULL);
+    gst_object_unref (pad);
+  }
+
+  gst_element_set_state (playbin, GST_STATE_PLAYING);
+  g_main_loop_run (loop);
+  gst_element_set_state (playbin, GST_STATE_NULL);
+
+  /* special handling for images (jpg) as jpegparse isn't plugged by
+   * default due to its current low rank */
+  if (taglist && strstr (filename, "image")) {
+    extract_jpeg_tags (filename, num);
+  }
+
+  if (taglist) {
+    fail_unless (tags_found != NULL);
+    fail_unless (taglist_is_subset (taglist, tags_found));
+  }
+
+  g_free (uri);
+  gst_object_unref (bus);
+  gst_object_unref (playbin);
+
+  return TRUE;
+}
+
+static gboolean
+filter_buffer_count (GstPad * pad, GstMiniObject * obj, gpointer data)
+{
+  gint *counter = data;
+
+  (*counter)++;
+
+  return TRUE;
+}
+
+GST_START_TEST (test_single_image_capture)
+{
+  gboolean idle;
+  if (!camera)
+    return;
+
+  /* set still image mode */
+  g_object_set (camera, "mode", 1,
+      "location", make_test_file_name (IMAGE_FILENAME, -1), NULL);
+
+  if (gst_element_set_state (GST_ELEMENT (camera), GST_STATE_PLAYING) ==
+      GST_STATE_CHANGE_FAILURE) {
+    GST_WARNING ("setting camerabin to PLAYING failed");
+    gst_element_set_state (GST_ELEMENT (camera), GST_STATE_NULL);
+    gst_object_unref (camera);
+    camera = NULL;
+  }
+  GST_INFO ("starting capture");
+  fail_unless (camera != NULL);
+  g_object_get (camera, "idle", &idle, NULL);
+  fail_unless (idle);
+  g_signal_emit_by_name (camera, "start-capture", NULL);
+
+  g_timeout_add_seconds (3, (GSourceFunc) g_main_loop_quit, main_loop);
+  g_main_loop_run (main_loop);
+
+  /* check that we got a preview image */
+  check_preview_image ();
+
+  g_object_get (camera, "idle", &idle, NULL);
+  fail_unless (idle);
+  gst_element_set_state (GST_ELEMENT (camera), GST_STATE_NULL);
+  check_file_validity (IMAGE_FILENAME, 0, NULL, 0, 0, NO_AUDIO);
+}
+
+GST_END_TEST;
+
+
+GST_START_TEST (test_multiple_image_captures)
+{
+  gboolean idle;
+  gint i;
+  gint widths[] = { 800, 640, 1280 };
+  gint heights[] = { 600, 480, 1024 };
+
+  if (!camera)
+    return;
+
+  /* set still image mode */
+  g_object_set (camera, "mode", 1,
+      "location", make_test_file_name (IMAGE_FILENAME, -1), NULL);
+
+  if (gst_element_set_state (GST_ELEMENT (camera), GST_STATE_PLAYING) ==
+      GST_STATE_CHANGE_FAILURE) {
+    GST_WARNING ("setting camerabin to PLAYING failed");
+    gst_element_set_state (GST_ELEMENT (camera), GST_STATE_NULL);
+    gst_object_unref (camera);
+    camera = NULL;
+  }
+  fail_unless (camera != NULL);
+  g_object_get (camera, "idle", &idle, NULL);
+  fail_unless (idle);
+  GST_INFO ("starting capture");
+
+  for (i = 0; i < 3; i++) {
+    GstCaps *caps;
+
+    caps = gst_caps_new_simple ("video/x-raw-rgb", "width", G_TYPE_INT,
+        widths[i], "height", G_TYPE_INT, heights[i], NULL);
+
+    g_object_set (camera, "image-capture-caps", caps, NULL);
+    gst_caps_unref (caps);
+
+    g_signal_emit_by_name (camera, "start-capture", NULL);
+
+    g_timeout_add_seconds (3, (GSourceFunc) g_main_loop_quit, main_loop);
+    g_main_loop_run (main_loop);
+
+    check_preview_image ();
+  }
+
+  g_usleep (G_USEC_PER_SEC * 3);
+  g_object_get (camera, "idle", &idle, NULL);
+  fail_unless (idle);
+  gst_element_set_state (GST_ELEMENT (camera), GST_STATE_NULL);
+  for (i = 0; i < 3; i++) {
+    check_file_validity (IMAGE_FILENAME, i, NULL, widths[i], heights[i],
+        NO_AUDIO);
+  }
+}
+
+GST_END_TEST;
+
+GST_START_TEST (test_single_video_recording)
+{
+  gboolean idle;
+  if (!camera)
+    return;
+
+  /* Set video recording mode */
+  g_object_set (camera, "mode", 2,
+      "location", make_test_file_name (VIDEO_FILENAME, -1), NULL);
+
+  if (gst_element_set_state (GST_ELEMENT (camera), GST_STATE_PLAYING) ==
+      GST_STATE_CHANGE_FAILURE) {
+    GST_WARNING ("setting camerabin to PLAYING failed");
+    gst_element_set_state (GST_ELEMENT (camera), GST_STATE_NULL);
+    gst_object_unref (camera);
+    camera = NULL;
+  }
+
+  GST_INFO ("starting capture");
+  fail_unless (camera != NULL);
+  g_object_get (camera, "idle", &idle, NULL);
+  fail_unless (idle);
+  g_signal_emit_by_name (camera, "start-capture", NULL);
+
+  g_object_get (camera, "idle", &idle, NULL);
+  fail_unless (!idle);
+
+  /* Record for one seconds  */
+  g_timeout_add_seconds (VIDEO_DURATION, (GSourceFunc) g_main_loop_quit,
+      main_loop);
+  g_main_loop_run (main_loop);
+
+  g_signal_emit_by_name (camera, "stop-capture", NULL);
+
+  check_preview_image ();
+
+  g_usleep (G_USEC_PER_SEC * 3);
+
+  g_object_get (camera, "idle", &idle, NULL);
+  fail_unless (idle);
+  gst_element_set_state (GST_ELEMENT (camera), GST_STATE_NULL);
+
+  check_file_validity (VIDEO_FILENAME, 0, NULL, 0, 0, WITH_AUDIO);
+}
+
+GST_END_TEST;
+
+GST_START_TEST (test_multiple_video_recordings)
+{
+  gboolean idle;
+  gint i;
+  gint widths[] = { 800, 640, 1280 };
+  gint heights[] = { 600, 480, 1024 };
+  gint fr[] = { 20, 30, 5 };
+
+  if (!camera)
+    return;
+
+  /* Set video recording mode */
+  g_object_set (camera, "mode", 2, NULL);
+
+  if (gst_element_set_state (GST_ELEMENT (camera), GST_STATE_PLAYING) ==
+      GST_STATE_CHANGE_FAILURE) {
+    GST_WARNING ("setting camerabin to PLAYING failed");
+    gst_element_set_state (GST_ELEMENT (camera), GST_STATE_NULL);
+    gst_object_unref (camera);
+    camera = NULL;
+  }
+
+  GST_INFO ("starting capture");
+  fail_unless (camera != NULL);
+  g_object_get (camera, "idle", &idle, NULL);
+  fail_unless (idle);
+  for (i = 0; i < 3; i++) {
+    GstCaps *caps;
+
+    caps = gst_caps_new_simple ("video/x-raw-rgb", "width", G_TYPE_INT,
+        widths[i], "height", G_TYPE_INT, heights[i], "framerate",
+        GST_TYPE_FRACTION, fr[i], 1, NULL);
+
+    g_object_set (camera, "video-capture-caps", caps,
+        "location", make_test_file_name (VIDEO_FILENAME, i), NULL);
+
+    gst_caps_unref (caps);
+
+    g_signal_emit_by_name (camera, "start-capture", NULL);
+
+    g_object_get (camera, "idle", &idle, NULL);
+    fail_unless (!idle);
+
+    g_timeout_add_seconds (VIDEO_DURATION, (GSourceFunc) g_main_loop_quit,
+        main_loop);
+    g_main_loop_run (main_loop);
+    g_signal_emit_by_name (camera, "stop-capture", NULL);
+
+    check_preview_image ();
+
+    g_timeout_add_seconds (3, (GSourceFunc) g_main_loop_quit, main_loop);
+    g_main_loop_run (main_loop);
+    g_object_get (camera, "idle", &idle, NULL);
+    fail_unless (idle);
+  }
+  gst_element_set_state (GST_ELEMENT (camera), GST_STATE_NULL);
+
+  for (i = 0; i < 3; i++) {
+    check_file_validity (VIDEO_FILENAME, i, NULL, widths[i], heights[i],
+        WITH_AUDIO);
+  }
+}
+
+GST_END_TEST;
+
+GST_START_TEST (test_image_video_cycle)
+{
+  gboolean idle;
+  gint i;
+
+  if (!camera)
+    return;
+
+  /* set filepaths for image and videos */
+  g_object_set (camera, "mode", 1, NULL);
+  g_object_set (camera, "location", make_test_file_name (IMAGE_FILENAME, -1),
+      NULL);
+  g_object_set (camera, "mode", 2, NULL);
+  g_object_set (camera, "location", make_test_file_name (VIDEO_FILENAME, -1),
+      NULL);
+
+  if (gst_element_set_state (GST_ELEMENT (camera), GST_STATE_PLAYING) ==
+      GST_STATE_CHANGE_FAILURE) {
+    GST_WARNING ("setting camerabin to PLAYING failed");
+    gst_element_set_state (GST_ELEMENT (camera), GST_STATE_NULL);
+    gst_object_unref (camera);
+    camera = NULL;
+  }
+
+  GST_INFO ("starting capture");
+  for (i = 0; i < 2; i++) {
+    g_object_get (camera, "idle", &idle, NULL);
+    fail_unless (idle);
+
+    /* take a picture */
+    g_object_set (camera, "mode", 1, NULL);
+    g_signal_emit_by_name (camera, "start-capture", NULL);
+    g_timeout_add_seconds (3, (GSourceFunc) g_main_loop_quit, main_loop);
+    g_main_loop_run (main_loop);
+
+    check_preview_image ();
+
+    /* now go to video */
+    g_object_set (camera, "mode", 2, NULL);
+    g_signal_emit_by_name (camera, "start-capture", NULL);
+    g_timeout_add_seconds (VIDEO_DURATION, (GSourceFunc) g_main_loop_quit,
+        main_loop);
+    g_main_loop_run (main_loop);
+    g_signal_emit_by_name (camera, "stop-capture", NULL);
+
+    check_preview_image ();
+
+    /* wait for capture to finish */
+    g_usleep (G_USEC_PER_SEC);
+  }
+  gst_element_set_state (GST_ELEMENT (camera), GST_STATE_NULL);
+
+  /* validate all the files */
+  for (i = 0; i < 2; i++) {
+    check_file_validity (IMAGE_FILENAME, i, NULL, 0, 0, NO_AUDIO);
+    check_file_validity (VIDEO_FILENAME, i, NULL, 0, 0, WITH_AUDIO);
+  }
+}
+
+GST_END_TEST;
+
+
+GST_START_TEST (test_image_capture_previews)
+{
+  gint i;
+  gint widths[] = { 800, 640, 1280 };
+  gint heights[] = { 600, 480, 1024 };
+
+  if (!camera)
+    return;
+
+  /* set still image mode */
+  g_object_set (camera, "mode", 1,
+      "location", make_test_file_name (IMAGE_FILENAME, -1), NULL);
+
+  if (gst_element_set_state (GST_ELEMENT (camera), GST_STATE_PLAYING) ==
+      GST_STATE_CHANGE_FAILURE) {
+    GST_WARNING ("setting camerabin to PLAYING failed");
+    gst_element_set_state (GST_ELEMENT (camera), GST_STATE_NULL);
+    gst_object_unref (camera);
+    camera = NULL;
+  }
+  fail_unless (camera != NULL);
+  GST_INFO ("starting capture");
+
+  for (i = 0; i < 3; i++) {
+    GstCaps *caps;
+
+    caps = gst_caps_new_simple ("video/x-raw-rgb", "width", G_TYPE_INT,
+        widths[i], "height", G_TYPE_INT, heights[i], NULL);
+
+    g_object_set (camera, "preview-caps", caps, NULL);
+    gst_caps_replace (&preview_caps, caps);
+    gst_caps_unref (caps);
+
+    g_signal_emit_by_name (camera, "start-capture", NULL);
+
+    g_timeout_add_seconds (3, (GSourceFunc) g_main_loop_quit, main_loop);
+    g_main_loop_run (main_loop);
+
+    check_preview_image ();
+
+    if (preview_buffer)
+      gst_buffer_unref (preview_buffer);
+    preview_buffer = NULL;
+    gst_caps_replace (&preview_caps, NULL);
+  }
+
+  gst_element_set_state (GST_ELEMENT (camera), GST_STATE_NULL);
+}
+
+GST_END_TEST;
+
+
+GST_START_TEST (test_image_capture_with_tags)
+{
+  gint i;
+  GstTagList *taglists[3];
+
+  if (!camera)
+    return;
+
+  taglists[0] = gst_tag_list_new_full (GST_TAG_COMMENT, "test1",
+      GST_TAG_GEO_LOCATION_LATITUDE, 36.6, GST_TAG_GEO_LOCATION_LONGITUDE,
+      -12.5,
+      GST_TAG_COPYRIGHT, "My copyright notice",
+      GST_TAG_DEVICE_MANUFACTURER, "MyFavoriteBrand",
+      GST_TAG_DEVICE_MODEL, "123v42.1",
+      GST_TAG_DESCRIPTION, "some description",
+      GST_TAG_APPLICATION_NAME, "camerabin2 test",
+      GST_TAG_GEO_LOCATION_ELEVATION, 300.85, NULL);
+  taglists[1] = gst_tag_list_new_full (GST_TAG_COMMENT, "test2",
+      GST_TAG_GEO_LOCATION_LATITUDE, 1.6, GST_TAG_GEO_LOCATION_LONGITUDE,
+      0.0,
+      GST_TAG_COPYRIGHT, "some cp",
+      GST_TAG_DEVICE_MANUFACTURER, "ABRAND",
+      GST_TAG_DEVICE_MODEL, "abcd",
+      GST_TAG_DESCRIPTION, "desc",
+      GST_TAG_APPLICATION_NAME, "another cam test",
+      GST_TAG_GEO_LOCATION_ELEVATION, 10.0, NULL);
+  taglists[2] = gst_tag_list_new_full (GST_TAG_COMMENT, "test3",
+      GST_TAG_GEO_LOCATION_LATITUDE, 1.3, GST_TAG_GEO_LOCATION_LONGITUDE,
+      -5.0,
+      GST_TAG_COPYRIGHT, "CC",
+      GST_TAG_DEVICE_MANUFACTURER, "Homemade",
+      GST_TAG_DEVICE_MODEL, "xpto",
+      GST_TAG_DESCRIPTION, "another  description",
+      GST_TAG_APPLICATION_NAME, "cam2 test",
+      GST_TAG_GEO_LOCATION_ELEVATION, 0.0, NULL);
+
+  /* set still image mode */
+  g_object_set (camera, "mode", 1,
+      "location", make_test_file_name (IMAGE_FILENAME, -1), NULL);
+
+  if (gst_element_set_state (GST_ELEMENT (camera), GST_STATE_PLAYING) ==
+      GST_STATE_CHANGE_FAILURE) {
+    GST_WARNING ("setting camerabin to PLAYING failed");
+    gst_element_set_state (GST_ELEMENT (camera), GST_STATE_NULL);
+    gst_object_unref (camera);
+    camera = NULL;
+  }
+  fail_unless (camera != NULL);
+  GST_INFO ("starting capture");
+
+  for (i = 0; i < 3; i++) {
+    gst_tag_setter_merge_tags (GST_TAG_SETTER (camera), taglists[i],
+        GST_TAG_MERGE_REPLACE);
+
+    g_signal_emit_by_name (camera, "start-capture", NULL);
+
+    g_timeout_add_seconds (3, (GSourceFunc) g_main_loop_quit, main_loop);
+    g_main_loop_run (main_loop);
+  }
+
+  gst_element_set_state (GST_ELEMENT (camera), GST_STATE_NULL);
+
+  for (i = 0; i < 3; i++) {
+    check_file_validity (IMAGE_FILENAME, i, taglists[i], 0, 0, NO_AUDIO);
+    gst_tag_list_free (taglists[i]);
+  }
+}
+
+GST_END_TEST;
+
+
+GST_START_TEST (test_video_capture_with_tags)
+{
+  gint i;
+  GstTagList *taglists[3];
+
+  if (!camera)
+    return;
+
+  taglists[0] = gst_tag_list_new_full (GST_TAG_COMMENT, "test1", NULL);
+  taglists[1] = gst_tag_list_new_full (GST_TAG_COMMENT, "test2", NULL);
+  taglists[2] = gst_tag_list_new_full (GST_TAG_COMMENT, "test3", NULL);
+
+  /* set video mode */
+  g_object_set (camera, "mode", 2,
+      "location", make_test_file_name (VIDEO_FILENAME, -1), NULL);
+
+  /* set a profile that has xmp support for more tags being saved */
+  {
+    GstEncodingContainerProfile *profile;
+    GstCaps *caps;
+
+    caps =
+        gst_caps_new_simple ("video/quicktime", "variant", G_TYPE_STRING,
+        "apple", NULL);
+    profile = gst_encoding_container_profile_new ("qt", "jpeg+qt", caps, NULL);
+    gst_caps_unref (caps);
+
+    caps = gst_caps_new_simple ("image/jpeg", NULL);
+    if (!gst_encoding_container_profile_add_profile (profile,
+            (GstEncodingProfile *) gst_encoding_video_profile_new (caps,
+                NULL, NULL, 1))) {
+      GST_WARNING_OBJECT (camera, "Failed to create encoding profiles");
+    }
+    gst_caps_unref (caps);
+
+    g_object_set (camera, "video-profile", profile, NULL);
+    gst_encoding_profile_unref (profile);
+  }
+
+  if (gst_element_set_state (GST_ELEMENT (camera), GST_STATE_PLAYING) ==
+      GST_STATE_CHANGE_FAILURE) {
+    GST_WARNING ("setting camerabin to PLAYING failed");
+    gst_element_set_state (GST_ELEMENT (camera), GST_STATE_NULL);
+    gst_object_unref (camera);
+    camera = NULL;
+  }
+  fail_unless (camera != NULL);
+  GST_INFO ("starting capture");
+
+  for (i = 0; i < 3; i++) {
+    gst_tag_setter_merge_tags (GST_TAG_SETTER (camera), taglists[i],
+        GST_TAG_MERGE_REPLACE);
+
+    g_signal_emit_by_name (camera, "start-capture", NULL);
+
+    g_timeout_add_seconds (3, (GSourceFunc) g_main_loop_quit, main_loop);
+    g_main_loop_run (main_loop);
+
+    g_signal_emit_by_name (camera, "stop-capture", NULL);
+    g_usleep (G_USEC_PER_SEC * 3);
+  }
+
+  gst_element_set_state (GST_ELEMENT (camera), GST_STATE_NULL);
+
+  for (i = 0; i < 3; i++) {
+    check_file_validity (VIDEO_FILENAME, i, taglists[i], 0, 0, NO_AUDIO);
+    gst_tag_list_free (taglists[i]);
+  }
+}
+
+GST_END_TEST;
+
+
+GST_START_TEST (test_supported_caps)
+{
+  GstCaps *padcaps = NULL;
+  GstCaps *expectedcaps;
+  GstElement *src;
+
+  if (!camera)
+    return;
+
+  src = g_object_new (GST_TYPE_TEST_CAMERA_SRC, NULL);
+  g_object_set (camera, "camera-src", src, NULL);
+  gst_object_unref (src);
+
+  if (gst_element_set_state (GST_ELEMENT (camera), GST_STATE_PLAYING) ==
+      GST_STATE_CHANGE_FAILURE) {
+    GST_WARNING ("setting camerabin to PLAYING failed");
+    gst_element_set_state (GST_ELEMENT (camera), GST_STATE_NULL);
+    gst_object_unref (camera);
+    camera = NULL;
+  }
+  g_assert (camera != NULL);
+
+  expectedcaps = gst_caps_from_string (VIDEO_PAD_SUPPORTED_CAPS);
+  g_object_get (G_OBJECT (camera), "video-capture-supported-caps", &padcaps,
+      NULL);
+  g_assert (expectedcaps != NULL);
+  g_assert (padcaps != NULL);
+  g_assert (gst_caps_is_equal (padcaps, expectedcaps));
+  gst_caps_unref (expectedcaps);
+  gst_caps_unref (padcaps);
+
+  expectedcaps = gst_caps_from_string (IMAGE_PAD_SUPPORTED_CAPS);
+  g_object_get (G_OBJECT (camera), "image-capture-supported-caps", &padcaps,
+      NULL);
+  g_assert (expectedcaps != NULL);
+  g_assert (padcaps != NULL);
+  g_assert (gst_caps_is_equal (padcaps, expectedcaps));
+  gst_caps_unref (expectedcaps);
+  gst_caps_unref (padcaps);
+
+  gst_element_set_state (camera, GST_STATE_NULL);
+}
+
+GST_END_TEST;
+
+
+GST_START_TEST (test_idle_property)
+{
+  gboolean idle;
+  if (!camera)
+    return;
+
+  /* Set video recording mode */
+  g_object_set (camera, "mode", 2,
+      "location", make_test_file_name (VIDEO_FILENAME, -1), NULL);
+
+  if (gst_element_set_state (GST_ELEMENT (camera), GST_STATE_PLAYING) ==
+      GST_STATE_CHANGE_FAILURE) {
+    GST_WARNING ("setting camerabin to PLAYING failed");
+    gst_element_set_state (GST_ELEMENT (camera), GST_STATE_NULL);
+    gst_object_unref (camera);
+    camera = NULL;
+  }
+
+  GST_INFO ("starting capture");
+  fail_unless (camera != NULL);
+  g_object_get (camera, "idle", &idle, NULL);
+  fail_unless (idle);
+  g_signal_emit_by_name (camera, "start-capture", NULL);
+  g_object_get (camera, "idle", &idle, NULL);
+  fail_unless (!idle);
+
+  /* emit a second start-capture that should be ignored */
+  g_signal_emit_by_name (camera, "start-capture", NULL);
+  g_object_get (camera, "idle", &idle, NULL);
+  fail_unless (!idle);
+
+  /* Record for one seconds  */
+  g_timeout_add_seconds (VIDEO_DURATION, (GSourceFunc) g_main_loop_quit,
+      main_loop);
+  g_main_loop_run (main_loop);
+
+  g_signal_emit_by_name (camera, "stop-capture", NULL);
+
+  check_preview_image ();
+
+  g_usleep (3 * G_USEC_PER_SEC);
+  g_object_get (camera, "idle", &idle, NULL);
+  fail_unless (idle);
+
+  gst_element_set_state (GST_ELEMENT (camera), GST_STATE_NULL);
+
+  check_file_validity (VIDEO_FILENAME, 0, NULL, 0, 0, WITH_AUDIO);
+}
+
+GST_END_TEST;
+
+
+GST_START_TEST (test_image_custom_filter)
+{
+  GstElement *vf_filter;
+  GstElement *image_filter;
+  GstElement *preview_filter;
+  GstPad *pad;
+  gint vf_probe_counter = 0;
+  gint image_probe_counter = 0;
+  gint preview_probe_counter = 0;
+
+  if (!camera)
+    return;
+
+  vf_filter = gst_element_factory_make ("identity", "vf-filter");
+  image_filter = gst_element_factory_make ("identity", "img-filter");
+  preview_filter = gst_element_factory_make ("identity", "preview-filter");
+
+  pad = gst_element_get_static_pad (vf_filter, "src");
+  gst_pad_add_buffer_probe (pad, (GCallback) filter_buffer_count,
+      &vf_probe_counter);
+  gst_object_unref (pad);
+
+  pad = gst_element_get_static_pad (image_filter, "src");
+  gst_pad_add_buffer_probe (pad, (GCallback) filter_buffer_count,
+      &image_probe_counter);
+  gst_object_unref (pad);
+
+  pad = gst_element_get_static_pad (preview_filter, "src");
+  gst_pad_add_buffer_probe (pad, (GCallback) filter_buffer_count,
+      &preview_probe_counter);
+  gst_object_unref (pad);
+
+  /* set still image mode and filters */
+  g_object_set (camera, "mode", 1,
+      "location", make_test_file_name (IMAGE_FILENAME, -1),
+      "viewfinder-filter", vf_filter, "image-filter", image_filter,
+      "preview-filter", preview_filter, NULL);
+
+  gst_object_unref (vf_filter);
+  gst_object_unref (preview_filter);
+  gst_object_unref (image_filter);
+
+  if (gst_element_set_state (GST_ELEMENT (camera), GST_STATE_PLAYING) ==
+      GST_STATE_CHANGE_FAILURE) {
+    GST_WARNING ("setting camerabin to PLAYING failed");
+    gst_element_set_state (GST_ELEMENT (camera), GST_STATE_NULL);
+    gst_object_unref (camera);
+    camera = NULL;
+  }
+  GST_INFO ("starting capture");
+  fail_unless (camera != NULL);
+  g_signal_emit_by_name (camera, "start-capture", NULL);
+
+  g_timeout_add_seconds (3, (GSourceFunc) g_main_loop_quit, main_loop);
+  g_main_loop_run (main_loop);
+
+  /* check that we got a preview image */
+  check_preview_image ();
+
+  gst_element_set_state (GST_ELEMENT (camera), GST_STATE_NULL);
+  check_file_validity (IMAGE_FILENAME, 0, NULL, 0, 0, NO_AUDIO);
+
+  fail_unless (vf_probe_counter > 0);
+  fail_unless (image_probe_counter == 1);
+  fail_unless (preview_probe_counter == 1);
+}
+
+GST_END_TEST;
+
+
+GST_START_TEST (test_video_custom_filter)
+{
+  GstElement *vf_filter;
+  GstElement *video_filter;
+  GstElement *preview_filter;
+  GstPad *pad;
+  gint vf_probe_counter = 0;
+  gint video_probe_counter = 0;
+  gint preview_probe_counter = 0;
+
+  if (!camera)
+    return;
+
+  vf_filter = gst_element_factory_make ("identity", "vf-filter");
+  video_filter = gst_element_factory_make ("identity", "video-filter");
+  preview_filter = gst_element_factory_make ("identity", "preview-filter");
+
+  pad = gst_element_get_static_pad (vf_filter, "src");
+  gst_pad_add_buffer_probe (pad, (GCallback) filter_buffer_count,
+      &vf_probe_counter);
+  gst_object_unref (pad);
+
+  pad = gst_element_get_static_pad (video_filter, "src");
+  gst_pad_add_buffer_probe (pad, (GCallback) filter_buffer_count,
+      &video_probe_counter);
+  gst_object_unref (pad);
+
+  pad = gst_element_get_static_pad (preview_filter, "src");
+  gst_pad_add_buffer_probe (pad, (GCallback) filter_buffer_count,
+      &preview_probe_counter);
+  gst_object_unref (pad);
+
+  /* set still image mode and filters */
+  g_object_set (camera, "mode", 2,
+      "location", make_test_file_name (VIDEO_FILENAME, -1),
+      "viewfinder-filter", vf_filter, "video-filter", video_filter,
+      "preview-filter", preview_filter, NULL);
+
+  gst_object_unref (vf_filter);
+  gst_object_unref (preview_filter);
+  gst_object_unref (video_filter);
+
+  if (gst_element_set_state (GST_ELEMENT (camera), GST_STATE_PLAYING) ==
+      GST_STATE_CHANGE_FAILURE) {
+    GST_WARNING ("setting camerabin to PLAYING failed");
+    gst_element_set_state (GST_ELEMENT (camera), GST_STATE_NULL);
+    gst_object_unref (camera);
+    camera = NULL;
+  }
+  GST_INFO ("starting capture");
+  fail_unless (camera != NULL);
+  g_signal_emit_by_name (camera, "start-capture", NULL);
+
+  g_timeout_add_seconds (VIDEO_DURATION, (GSourceFunc) g_main_loop_quit,
+      main_loop);
+  g_main_loop_run (main_loop);
+  g_signal_emit_by_name (camera, "stop-capture", NULL);
+
+  /* check that we got a preview image */
+  check_preview_image ();
+
+  gst_element_set_state (GST_ELEMENT (camera), GST_STATE_NULL);
+  check_file_validity (VIDEO_FILENAME, 0, NULL, 0, 0, WITH_AUDIO);
+
+  fail_unless (vf_probe_counter > 0);
+  fail_unless (video_probe_counter > 0);
+  fail_unless (preview_probe_counter == 1);
+}
+
+GST_END_TEST;
+
+
+GST_START_TEST (test_image_custom_encoder_muxer)
+{
+  GstElement *enc;
+  GstElement *mux;
+  GstElement *test;
+  GstPad *pad;
+  gint enc_probe_counter = 0;
+  gint mux_probe_counter = 0;
+
+  if (!camera)
+    return;
+
+  enc = gst_element_factory_make ("pngenc", "enc");
+  mux = gst_element_factory_make ("identity", "mux");
+
+  g_object_set (enc, "snapshot", FALSE, NULL);
+
+  pad = gst_element_get_static_pad (enc, "src");
+  gst_pad_add_buffer_probe (pad, (GCallback) filter_buffer_count,
+      &enc_probe_counter);
+  gst_object_unref (pad);
+
+  pad = gst_element_get_static_pad (mux, "src");
+  gst_pad_add_buffer_probe (pad, (GCallback) filter_buffer_count,
+      &mux_probe_counter);
+  gst_object_unref (pad);
+
+  /* set still image mode and filters */
+  g_object_set (camera, "mode", 1,
+      "location", make_test_file_name (IMAGE_FILENAME, -1),
+      "image-capture-encoder", enc, "image-capture-muxer", mux, NULL);
+
+  if (gst_element_set_state (GST_ELEMENT (camera), GST_STATE_PLAYING) ==
+      GST_STATE_CHANGE_FAILURE) {
+    GST_WARNING ("setting camerabin to PLAYING failed");
+    gst_element_set_state (GST_ELEMENT (camera), GST_STATE_NULL);
+    gst_object_unref (camera);
+    camera = NULL;
+  }
+  GST_INFO ("starting capture");
+  fail_unless (camera != NULL);
+
+  g_object_get (camera, "image-capture-encoder", &test, NULL);
+  fail_unless (test == enc);
+  g_object_get (camera, "image-capture-muxer", &test, NULL);
+  fail_unless (test == mux);
+
+  g_signal_emit_by_name (camera, "start-capture", NULL);
+
+  g_timeout_add_seconds (3, (GSourceFunc) g_main_loop_quit, main_loop);
+  g_main_loop_run (main_loop);
+
+  /* check that we got a preview image */
+  check_preview_image ();
+
+  gst_element_set_state (GST_ELEMENT (camera), GST_STATE_NULL);
+  check_file_validity (IMAGE_FILENAME, 0, NULL, 0, 0, NO_AUDIO);
+
+  fail_unless (enc_probe_counter == 1);
+  fail_unless (mux_probe_counter == 1);
+  gst_object_unref (enc);
+  gst_object_unref (mux);
+}
+
+GST_END_TEST;
+
+
+
+
+typedef struct _TestCaseDef
+{
+  const gchar *name;
+  gpointer setup_func;
+} TestCaseDef;
+
+TestCaseDef tests[] = {
+  {"wrappercamerabinsrc", setup_wrappercamerabinsrc_videotestsrc}
+};
+
+static Suite *
+camerabin_suite (void)
+{
+  GstElementFactory *jpegenc_factory;
+  GstElementFactory *pngenc_factory;
+  Suite *s = suite_create ("camerabin2");
+  gint i;
+  TCase *tc_generic = tcase_create ("generic");
+
+  jpegenc_factory = gst_element_factory_find ("jpegenc");
+  if (jpegenc_factory == NULL) {
+    GST_WARNING ("Skipping camerabin2 tests because jpegenc is missing");
+    goto end;
+  }
+  pngenc_factory = gst_element_factory_find ("pngenc");
+
+  suite_add_tcase (s, tc_generic);
+  tcase_add_checked_fixture (tc_generic, setup_wrappercamerabinsrc_videotestsrc,
+      teardown);
+  tcase_add_test (tc_generic, test_supported_caps);
+
+  for (i = 0; i < G_N_ELEMENTS (tests); i++) {
+    TCase *tc_basic = tcase_create (tests[i].name);
+    suite_add_tcase (s, tc_basic);
+
+    /* Increase timeout due to video recording */
+    tcase_set_timeout (tc_basic, 60);
+    tcase_add_checked_fixture (tc_basic, tests[i].setup_func, teardown);
+
+    tcase_add_test (tc_basic, test_single_image_capture);
+    tcase_add_test (tc_basic, test_single_video_recording);
+    tcase_add_test (tc_basic, test_image_video_cycle);
+    if (gst_plugin_feature_check_version ((GstPluginFeature *) jpegenc_factory,
+            0, 10, 27))
+      tcase_add_test (tc_basic, test_multiple_image_captures);
+    else
+      GST_WARNING ("Skipping image capture test because -good 0.10.27 is "
+          "needed");
+    tcase_add_test (tc_basic, test_multiple_video_recordings);
+
+    tcase_add_test (tc_basic, test_image_capture_previews);
+    tcase_add_test (tc_basic, test_image_capture_with_tags);
+
+    tcase_add_test (tc_basic, test_video_capture_with_tags);
+
+    tcase_add_test (tc_basic, test_idle_property);
+
+    tcase_add_test (tc_basic, test_image_custom_filter);
+    tcase_add_test (tc_basic, test_video_custom_filter);
+
+    if (pngenc_factory)
+      tcase_add_test (tc_basic, test_image_custom_encoder_muxer);
+    else
+      GST_WARNING ("Skipping custom encoder test because pngenc is missing");
+  }
+
+end:
+  return s;
+}
+
+GST_CHECK_MAIN (camerabin);
diff --git a/tests/examples/Makefile.am b/tests/examples/Makefile.am
index 562b361..436a55c 100644
--- a/tests/examples/Makefile.am
+++ b/tests/examples/Makefile.am
@@ -1,5 +1,5 @@
 if HAVE_GTK
-GTK_EXAMPLES=camerabin mxf scaletempo
+GTK_EXAMPLES=camerabin camerabin2 mxf scaletempo
 else
 GTK_EXAMPLES=
 endif
diff --git a/tests/examples/camerabin2/.gitignore b/tests/examples/camerabin2/.gitignore
new file mode 100644
index 0000000..715a3e2
--- /dev/null
+++ b/tests/examples/camerabin2/.gitignore
@@ -0,0 +1,5 @@
+gst-camera2
+gst-camerabin2-test
+test_*.jpg
+vid_*
+img_*
diff --git a/tests/examples/camerabin2/Makefile.am b/tests/examples/camerabin2/Makefile.am
new file mode 100644
index 0000000..b5a0064
--- /dev/null
+++ b/tests/examples/camerabin2/Makefile.am
@@ -0,0 +1,51 @@
+GST_CAMERABIN_UI_FILES = gst-camera2.ui
+
+if HAVE_GTK
+
+GST_CAMERABIN_GTK_EXAMPLES = gst-camera2
+
+gst_camera2_SOURCES = gst-camera2.h gst-camera2.c
+gst_camera2_CFLAGS  = \
+        $(GST_PLUGINS_BAD_CFLAGS) \
+        $(GST_PLUGINS_BASE_CFLAGS) $(GST_CFLAGS) \
+	$(GTK_CFLAGS) \
+	$(GMODULE_EXPORT_CFLAGS) \
+        -DGST_USE_UNSTABLE_API
+gst_camera2_LDADD   = \
+        $(top_builddir)/gst-libs/gst/interfaces/libgstphotography-@GST_MAJORMINOR@.la \
+        $(GST_PLUGINS_BASE_LIBS) \
+        -lgstinterfaces-@GST_MAJORMINOR@ \
+        $(GST_LIBS) \
+	$(GTK_LIBS) \
+	$(GMODULE_EXPORT_LIBS)
+
+noinst_DATA = $(GST_CAMERABIN_UI_FILES)
+
+INCLUDES = -DCAMERA_APPS_UIDIR=\""$(srcdir)"\"
+
+else
+GST_CAMERABIN_GTK_EXAMPLES =
+endif
+
+if HAVE_X11
+
+GST_CAMERABIN_X11_EXAMPLES = gst-camerabin2-test
+
+gst_camerabin2_test_SOURCES = gst-camerabin2-test.c
+gst_camerabin2_test_CFLAGS  = $(GST_CFLAGS) $(GST_PLUGINS_BASE_CFLAGS) $(GST_PLUGINS_BAD_CFLAGS)
+gst_camerabin2_test_LDADD   = \
+	$(top_builddir)/gst-libs/gst/interfaces/libgstphotography-@GST_MAJORMINOR@.la \
+	$(GST_PLUGINS_BASE_LIBS) \
+	-lgstinterfaces-@GST_MAJORMINOR@ \
+	-lgstpbutils-@GST_MAJORMINOR@ \
+	$(GST_LIBS) \
+	$(X11_LIBS)
+
+else
+GST_CAMERABIN_X11_EXAMPLES =
+endif
+
+noinst_PROGRAMS = $(GST_CAMERABIN_GTK_EXAMPLES) $(GST_CAMERABIN_X11_EXAMPLES)
+
+EXTRA_DIST = $(GST_CAMERABIN_UI_FILES)
+
diff --git a/tests/examples/camerabin2/gst-camera2.c b/tests/examples/camerabin2/gst-camera2.c
new file mode 100644
index 0000000..14e3be1
--- /dev/null
+++ b/tests/examples/camerabin2/gst-camera2.c
@@ -0,0 +1,186 @@
+/*
+ * GStreamer
+ * Copyright (C) 2010 Thiago Santos <thiago.sousa.santos@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+/*
+ * This is a demo application to test the camerabin element.
+ * If you have question don't hesitate in contact me edgard.lima@indt.org.br
+ */
+
+/*
+ * Includes
+ */
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include "gst-camera2.h"
+
+#include <gst/gst.h>
+#include <gst/interfaces/xoverlay.h>
+#include <gtk/gtk.h>
+#include <gdk/gdkx.h>
+#include <gdk/gdkkeysyms.h>
+
+#define UI_FILE CAMERA_APPS_UIDIR G_DIR_SEPARATOR_S "gst-camera2.ui"
+
+static GstElement *camera;
+static GtkBuilder *builder;
+
+void
+on_mainWindow_delete_event (GtkWidget * widget, GdkEvent * event, gpointer data)
+{
+  gtk_main_quit ();
+}
+
+void
+on_captureButton_clicked (GtkButton * button, gpointer user_data)
+{
+  g_signal_emit_by_name (camera, "start-capture", NULL);
+}
+
+void
+on_stopCaptureButton_clicked (GtkButton * button, gpointer user_data)
+{
+  g_signal_emit_by_name (camera, "stop-capture", NULL);
+}
+
+void
+on_imageRButton_toggled (GtkToggleButton * button, gpointer user_data)
+{
+  if (gtk_toggle_button_get_active (button)) {
+    g_object_set (camera, "mode", 1, NULL);     /* Image mode */
+  }
+}
+
+void
+on_videoRButton_toggled (GtkToggleButton * button, gpointer user_data)
+{
+  if (gtk_toggle_button_get_active (button)) {
+    g_object_set (camera, "mode", 2, NULL);     /* Video mode */
+  }
+}
+
+void
+on_viewfinderArea_realize (GtkWidget * widget, gpointer data)
+{
+#if GTK_CHECK_VERSION (2, 18, 0)
+  gdk_window_ensure_native (gtk_widget_get_window (widget));
+#endif
+}
+
+static GstBusSyncReply
+bus_sync_callback (GstBus * bus, GstMessage * message, gpointer data)
+{
+  GtkWidget *ui_drawing;
+
+  if (GST_MESSAGE_TYPE (message) != GST_MESSAGE_ELEMENT)
+    return GST_BUS_PASS;
+
+  if (!gst_structure_has_name (message->structure, "prepare-xwindow-id"))
+    return GST_BUS_PASS;
+
+  /* FIXME: make sure to get XID in main thread */
+  ui_drawing = GTK_WIDGET (gtk_builder_get_object (builder, "viewfinderArea"));
+  gst_x_overlay_set_window_handle (GST_X_OVERLAY (message->src),
+      GDK_WINDOW_XWINDOW (gtk_widget_get_window (ui_drawing)));
+
+  gst_message_unref (message);
+  return GST_BUS_DROP;
+}
+
+
+static gboolean
+bus_callback (GstBus * bus, GstMessage * message, gpointer data)
+{
+  switch (GST_MESSAGE_TYPE (message)) {
+    case GST_MESSAGE_WARNING:{
+      GError *err;
+      gchar *debug;
+
+      gst_message_parse_warning (message, &err, &debug);
+      g_print ("Warning: %s\n", err->message);
+      g_error_free (err);
+      g_free (debug);
+      break;
+    }
+    case GST_MESSAGE_ERROR:{
+      GError *err = NULL;
+      gchar *debug = NULL;
+
+      gst_message_parse_error (message, &err, &debug);
+      g_print ("Error: %s : %s\n", err->message, debug);
+      g_error_free (err);
+      g_free (debug);
+
+      gtk_main_quit ();
+      break;
+    }
+    case GST_MESSAGE_EOS:
+      /* end-of-stream */
+      g_print ("Eos\n");
+      gtk_main_quit ();
+      break;
+    case GST_MESSAGE_ELEMENT:
+    {
+      //handle_element_message (message);
+      break;
+    }
+    default:
+      /* unhandled message */
+      break;
+  }
+  return TRUE;
+}
+
+int
+main (int argc, char *argv[])
+{
+  int ret = 0;
+  GtkWidget *ui_main_window;
+  GError *error = NULL;
+  GstBus *bus;
+
+  gst_init (&argc, &argv);
+  gtk_init (&argc, &argv);
+
+  builder = gtk_builder_new ();
+  if (!gtk_builder_add_from_file (builder, UI_FILE, &error)) {
+    g_warning ("Error: %s", error->message);
+    g_error_free (error);
+    return 1;
+  }
+
+  camera = gst_element_factory_make ("camerabin2", "camera");
+  bus = gst_pipeline_get_bus (GST_PIPELINE (camera));
+  gst_bus_add_watch (bus, bus_callback, NULL);
+  gst_bus_set_sync_handler (bus, bus_sync_callback, NULL);
+  gst_object_unref (bus);
+
+  ui_main_window = GTK_WIDGET (gtk_builder_get_object (builder, "mainWindow"));
+  gtk_builder_connect_signals (builder, NULL);
+  gtk_widget_show_all (ui_main_window);
+
+  gst_element_set_state (camera, GST_STATE_PLAYING);
+
+  gtk_main ();
+
+  gst_element_set_state (camera, GST_STATE_NULL);
+  gst_object_unref (camera);
+  return ret;
+}
diff --git a/tests/examples/camerabin2/gst-camera2.h b/tests/examples/camerabin2/gst-camera2.h
new file mode 100644
index 0000000..d96e2de
--- /dev/null
+++ b/tests/examples/camerabin2/gst-camera2.h
@@ -0,0 +1,48 @@
+/*
+ * GStreamer
+ * Copyright (C) 2008 Nokia Corporation <multimedia@maemo.org>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+/*
+ * This is a demo application to test the camerabin element.
+ * If you have question don't hesitate in contact me edgard.lima@indt.org.br
+ */
+
+#ifndef __GST_CAMERA_BIN_H__
+#define __GST_CAMERA_BIN_H__
+
+#include <gtk/gtk.h>
+
+void
+on_mainWindow_delete_event (GtkWidget * widget, GdkEvent * event, gpointer data);
+
+void
+on_captureButton_clicked (GtkButton * button, gpointer user_data);
+
+void
+on_stopCaptureButton_clicked (GtkButton * button, gpointer user_data);
+
+void
+on_imageRButton_toggled (GtkToggleButton * button, gpointer user_data);
+
+void
+on_videoRButton_toggled (GtkToggleButton * button, gpointer user_data);
+
+void
+on_viewfinderArea_realize (GtkWidget * widget, gpointer data);
+
+#endif /* __GST_CAMERA_BIN_H__ */
diff --git a/tests/examples/camerabin2/gst-camera2.ui b/tests/examples/camerabin2/gst-camera2.ui
new file mode 100644
index 0000000..48fe141
--- /dev/null
+++ b/tests/examples/camerabin2/gst-camera2.ui
@@ -0,0 +1,109 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<interface>
+  <requires lib="gtk+" version="2.16"/>
+  <!-- interface-naming-policy project-wide -->
+  <object class="GtkWindow" id="mainWindow">
+    <property name="default_width">800</property>
+    <property name="default_height">600</property>
+    <signal name="delete_event" handler="on_mainWindow_delete_event"/>
+    <child>
+      <object class="GtkVBox" id="vbox1">
+        <property name="visible">True</property>
+        <child>
+          <object class="GtkHBox" id="hbox1">
+            <property name="visible">True</property>
+            <child>
+              <object class="GtkRadioButton" id="imageRButton">
+                <property name="label" translatable="yes">Image</property>
+                <property name="visible">True</property>
+                <property name="can_focus">True</property>
+                <property name="receives_default">False</property>
+                <property name="active">True</property>
+                <property name="draw_indicator">True</property>
+                <signal name="toggled" handler="on_imageRButton_toggled"/>
+              </object>
+              <packing>
+                <property name="position">0</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkRadioButton" id="videoRButton">
+                <property name="label" translatable="yes">Video</property>
+                <property name="visible">True</property>
+                <property name="can_focus">True</property>
+                <property name="receives_default">False</property>
+                <property name="active">True</property>
+                <property name="draw_indicator">True</property>
+                <property name="group">imageRButton</property>
+                <signal name="toggled" handler="on_videoRButton_toggled"/>
+              </object>
+              <packing>
+                <property name="position">1</property>
+              </packing>
+            </child>
+          </object>
+          <packing>
+            <property name="expand">False</property>
+            <property name="fill">False</property>
+            <property name="position">0</property>
+          </packing>
+        </child>
+        <child>
+          <object class="GtkHBox" id="hbox2">
+            <property name="visible">True</property>
+            <child>
+              <object class="GtkDrawingArea" id="viewfinderArea">
+                <property name="visible">True</property>
+                <signal name="realize" handler="on_viewfinderArea_realize"/>
+              </object>
+              <packing>
+                <property name="position">0</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkVBox" id="vbox2">
+                <property name="visible">True</property>
+                <child>
+                  <object class="GtkButton" id="captureButton">
+                    <property name="label" translatable="yes">Capture</property>
+                    <property name="visible">True</property>
+                    <property name="can_focus">True</property>
+                    <property name="receives_default">True</property>
+                    <signal name="clicked" handler="on_captureButton_clicked"/>
+                  </object>
+                  <packing>
+                    <property name="expand">False</property>
+                    <property name="fill">False</property>
+                    <property name="position">0</property>
+                  </packing>
+                </child>
+                <child>
+                  <object class="GtkButton" id="stopCaptureButton">
+                    <property name="label" translatable="yes">Stop Capture</property>
+                    <property name="visible">True</property>
+                    <property name="can_focus">True</property>
+                    <property name="receives_default">True</property>
+                    <signal name="clicked" handler="on_stopCaptureButton_clicked"/>
+                  </object>
+                  <packing>
+                    <property name="expand">False</property>
+                    <property name="fill">False</property>
+                    <property name="position">1</property>
+                  </packing>
+                </child>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+                <property name="fill">False</property>
+                <property name="position">1</property>
+              </packing>
+            </child>
+          </object>
+          <packing>
+            <property name="position">1</property>
+          </packing>
+        </child>
+      </object>
+    </child>
+  </object>
+</interface>
diff --git a/tests/examples/camerabin2/gst-camerabin2-test.c b/tests/examples/camerabin2/gst-camerabin2-test.c
new file mode 100644
index 0000000..6b01419
--- /dev/null
+++ b/tests/examples/camerabin2/gst-camerabin2-test.c
@@ -0,0 +1,858 @@
+/*
+ * GStreamer
+ * Copyright (C) 2010 Nokia Corporation <multimedia@maemo.org>
+ * Copyright (C) 2011 Thiago Santos <thiago.sousa.santos@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+ /*
+    TODO review
+    Examples:
+    ./gst-camerabin2-test --image-width=2048 --image-height=1536
+    ./gst-camerabin2-test --mode=2 --capture-time=10 --image-width=848 --image-height=480 --view-framerate-num=2825 \
+    --view-framerate-den=100
+
+    gst-camerabin2-test --help
+    Usage:
+    gst-camerabin2-test [OPTION...]
+
+    camerabin command line test application.
+
+    Help Options:
+    -h, --help                        Show help options
+    --help-all                        Show all help options
+    --help-gst                        Show GStreamer Options
+
+    Application Options:
+    --ev-compensation                 EV compensation (-2.5..2.5, default = 0)
+    --aperture                        Aperture (size of lens opening, default = 0 (auto))
+    --flash-mode                      Flash mode (default = 0 (auto))
+    --scene-mode                      Scene mode (default = 6 (auto))
+    --exposure                        Exposure (default = 0 (auto))
+    --iso-speed                       ISO speed (default = 0 (auto))
+    --white-balance-mode              White balance mode (default = 0 (auto))
+    --colour-tone-mode                Colour tone mode (default = 0 (auto))
+    --directory                       Directory for capture file(s) (default is current directory)
+    --mode                            Capture mode (default = 0 (image), 1 = video)
+    --capture-time                    Time to capture video in seconds (default = 10)
+    --capture-total                   Total number of captures to be done (default = 1)
+    --zoom                            Zoom (100 = 1x (default), 200 = 2x etc.)
+    --wrapper-source                  Camera source wrapper used for setting the video source
+    --video-source                    Video source used in still capture and video recording
+    --image-pp                        List of image post-processing elements separated with comma
+    --viewfinder-sink                 Viewfinder sink (default = fakesink)
+    --image-width                     Width for image capture
+    --image-height                    Height for image capture
+    --view-framerate-num              Framerate numerator for viewfinder
+    --view-framerate-den              Framerate denominator for viewfinder
+    --preview-caps                    Preview caps (e.g. video/x-raw-rgb,width=864,height=480)
+    --viewfinder-filter               Filter to process all frames going to viewfinder sink
+    --x-width                         X window width (default = 864)
+    --x-height                        X window height (default = 480)
+    --no-xwindow                      Do not create XWindow
+    --encoding-target                 Video encoding target name
+    --encoding-profile                Video encoding profile name
+    --encoding-profile-filename       Video encoding profile filename
+
+  */
+
+/*
+ * Includes
+ */
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#define GST_USE_UNSTABLE_API 1
+
+#include <gst/gst.h>
+#include <gst/interfaces/xoverlay.h>
+#include <gst/interfaces/photography.h>
+#include <string.h>
+#include <sys/time.h>
+#include <time.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <glib.h>
+#include <glib/gstdio.h>
+#include <gst/pbutils/encoding-profile.h>
+#include <gst/pbutils/encoding-target.h>
+#include <X11/Xlib.h>
+#include <X11/Xatom.h>
+/*
+ * debug logging
+ */
+GST_DEBUG_CATEGORY_STATIC (camerabin_test);
+#define GST_CAT_DEFAULT camerabin_test
+typedef struct _ResultType
+{
+  GstClockTime avg;
+  GstClockTime min;
+  GstClockTime max;
+  guint32 times;
+} ResultType;
+
+/*
+ * Global vars
+ */
+static GstElement *camerabin = NULL;
+static GMainLoop *loop = NULL;
+
+/* commandline options */
+static gchar *videosrc_name = NULL;
+static gchar *wrappersrc_name = NULL;
+static gchar *imagepp_name = NULL;
+static gchar *vfsink_name = NULL;
+static gint image_width = 0;
+static gint image_height = 0;
+static gint view_framerate_num = 0;
+static gint view_framerate_den = 0;
+static gboolean no_xwindow = FALSE;
+static gchar *gep_targetname = NULL;
+static gchar *gep_profilename = NULL;
+static gchar *gep_filename = NULL;
+
+
+#define MODE_VIDEO 2
+#define MODE_IMAGE 1
+static gint mode = MODE_IMAGE;
+static gint zoom = 100;
+
+static gint capture_time = 10;
+static gint capture_count = 0;
+static gint capture_total = 1;
+static gulong stop_capture_cb_id = 0;
+
+/* photography interface command line options */
+#define EV_COMPENSATION_NONE -G_MAXFLOAT
+#define APERTURE_NONE -G_MAXINT
+#define FLASH_MODE_NONE -G_MAXINT
+#define SCENE_MODE_NONE -G_MAXINT
+#define EXPOSURE_NONE -G_MAXINT64
+#define ISO_SPEED_NONE -G_MAXINT
+#define WHITE_BALANCE_MODE_NONE -G_MAXINT
+#define COLOR_TONE_MODE_NONE -G_MAXINT
+static gfloat ev_compensation = EV_COMPENSATION_NONE;
+static gint aperture = APERTURE_NONE;
+static gint flash_mode = FLASH_MODE_NONE;
+static gint scene_mode = SCENE_MODE_NONE;
+static gint64 exposure = EXPOSURE_NONE;
+static gint iso_speed = ISO_SPEED_NONE;
+static gint wb_mode = WHITE_BALANCE_MODE_NONE;
+static gint color_mode = COLOR_TONE_MODE_NONE;
+
+static gchar *viewfinder_filter = NULL;
+
+static int x_width = 864;
+static int x_height = 480;
+
+/* test configuration for common callbacks */
+static GString *filename = NULL;
+
+static gchar *preview_caps_name = NULL;
+
+/* X window variables */
+static Display *display = NULL;
+static Window window = 0;
+
+GTimer *timer = NULL;
+
+/*
+ * Prototypes
+ */
+static gboolean run_pipeline (gpointer user_data);
+static void set_metadata (GstElement * camera);
+
+static void
+create_host_window (void)
+{
+  unsigned long valuemask;
+  XSetWindowAttributes attributes;
+
+  display = XOpenDisplay (NULL);
+  if (display) {
+    window =
+        XCreateSimpleWindow (display, DefaultRootWindow (display), 0, 0,
+        x_width, x_height, 0, 0, 0);
+    if (window) {
+      valuemask = CWOverrideRedirect;
+      attributes.override_redirect = True;
+      XChangeWindowAttributes (display, window, valuemask, &attributes);
+      XSetWindowBackgroundPixmap (display, window, None);
+      XMapRaised (display, window);
+      XSync (display, FALSE);
+    } else {
+      GST_DEBUG ("could not create X window!");
+    }
+  } else {
+    GST_DEBUG ("could not open display!");
+  }
+}
+
+static GstBusSyncReply
+sync_bus_callback (GstBus * bus, GstMessage * message, gpointer data)
+{
+  const GstStructure *st;
+  const GValue *image;
+  GstBuffer *buf = NULL;
+  guint8 *data_buf = NULL;
+  gchar *caps_string;
+  guint size = 0;
+  gchar *preview_filename = NULL;
+  FILE *f = NULL;
+  size_t written;
+
+  switch (GST_MESSAGE_TYPE (message)) {
+    case GST_MESSAGE_ELEMENT:{
+      st = gst_message_get_structure (message);
+      if (st) {
+        if (gst_structure_has_name (message->structure, "prepare-xwindow-id")) {
+          if (!no_xwindow && window) {
+            gst_x_overlay_set_window_handle (GST_X_OVERLAY (GST_MESSAGE_SRC
+                    (message)), window);
+            gst_message_unref (message);
+            message = NULL;
+            return GST_BUS_DROP;
+          }
+        } else if (gst_structure_has_name (st, "preview-image")) {
+          GST_DEBUG ("preview-image");
+          /* extract preview-image from msg */
+          image = gst_structure_get_value (st, "buffer");
+          if (image) {
+            buf = gst_value_get_buffer (image);
+            data_buf = GST_BUFFER_DATA (buf);
+            size = GST_BUFFER_SIZE (buf);
+            preview_filename = g_strdup_printf ("test_vga.rgb");
+            caps_string = gst_caps_to_string (GST_BUFFER_CAPS (buf));
+            g_print ("writing buffer to %s, elapsed: %.2fs, buffer caps: %s\n",
+                preview_filename, g_timer_elapsed (timer, NULL), caps_string);
+            g_free (caps_string);
+            f = g_fopen (preview_filename, "w");
+            if (f) {
+              written = fwrite (data_buf, size, 1, f);
+              if (!written) {
+                g_print ("error writing file\n");
+              }
+              fclose (f);
+            } else {
+              g_print ("error opening file for raw image writing\n");
+            }
+            g_free (preview_filename);
+          }
+        }
+      }
+      break;
+    }
+    default:
+      /* unhandled message */
+      break;
+  }
+  return GST_BUS_PASS;
+}
+
+static gboolean
+bus_callback (GstBus * bus, GstMessage * message, gpointer data)
+{
+  switch (GST_MESSAGE_TYPE (message)) {
+    case GST_MESSAGE_ERROR:{
+      GError *err;
+      gchar *debug;
+
+      gst_message_parse_error (message, &err, &debug);
+      g_print ("Error: %s\n", err->message);
+      g_error_free (err);
+      g_free (debug);
+
+      /* Write debug graph to file */
+      GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS (GST_BIN (camerabin),
+          GST_DEBUG_GRAPH_SHOW_ALL, "camerabin.error");
+
+      g_main_loop_quit (loop);
+      break;
+    }
+    case GST_MESSAGE_STATE_CHANGED:
+      if (GST_IS_BIN (GST_MESSAGE_SRC (message))) {
+        GstState oldstate, newstate;
+
+        gst_message_parse_state_changed (message, &oldstate, &newstate, NULL);
+        GST_DEBUG_OBJECT (GST_MESSAGE_SRC (message), "state-changed: %s -> %s",
+            gst_element_state_get_name (oldstate),
+            gst_element_state_get_name (newstate));
+      }
+      break;
+    case GST_MESSAGE_EOS:
+      /* end-of-stream */
+      GST_INFO ("got eos() - should not happen");
+      g_main_loop_quit (loop);
+      break;
+    case GST_MESSAGE_ELEMENT:
+      if (GST_MESSAGE_SRC (message) == (GstObject *) camerabin) {
+        const GstStructure *structure = gst_message_get_structure (message);
+
+        if (gst_structure_has_name (structure, "image-done")) {
+          const gchar *fname = gst_structure_get_string (structure, "filename");
+
+          GST_DEBUG ("image done: %s", fname);
+          if (capture_count < capture_total) {
+            g_idle_add ((GSourceFunc) run_pipeline, NULL);
+          } else {
+            g_main_loop_quit (loop);
+          }
+        }
+      }
+      break;
+    default:
+      /* unhandled message */
+      break;
+  }
+  return TRUE;
+}
+
+/*
+ * Helpers
+ */
+
+static void
+cleanup_pipeline (void)
+{
+  if (camerabin) {
+    GST_INFO_OBJECT (camerabin, "stopping and destroying");
+    gst_element_set_state (camerabin, GST_STATE_NULL);
+    gst_object_unref (camerabin);
+    camerabin = NULL;
+  }
+}
+
+static GstElement *
+create_ipp_bin (void)
+{
+  GstElement *bin = NULL, *element = NULL;
+  GstPad *pad = NULL;
+  gchar **elements;
+  GList *element_list = NULL, *current = NULL, *next = NULL;
+  int i;
+
+  bin = gst_bin_new ("ippbin");
+
+  elements = g_strsplit (imagepp_name, ",", 0);
+
+  for (i = 0; elements[i] != NULL; i++) {
+    element = gst_element_factory_make (elements[i], NULL);
+    if (element) {
+      element_list = g_list_append (element_list, element);
+      gst_bin_add (GST_BIN (bin), element);
+    } else
+      GST_WARNING ("Could create element %s for ippbin", elements[i]);
+  }
+
+  for (i = 1; i < g_list_length (element_list); i++) {
+    current = g_list_nth (element_list, i - 1);
+    next = g_list_nth (element_list, i);
+    gst_element_link (current->data, next->data);
+  }
+
+  current = g_list_first (element_list);
+  pad = gst_element_get_static_pad (current->data, "sink");
+  gst_element_add_pad (bin, gst_ghost_pad_new ("sink", pad));
+  gst_object_unref (GST_OBJECT (pad));
+
+  current = g_list_last (element_list);
+  pad = gst_element_get_static_pad (current->data, "src");
+  gst_element_add_pad (bin, gst_ghost_pad_new ("src", pad));
+  gst_object_unref (GST_OBJECT (pad));
+
+  g_list_free (element_list);
+  g_strfreev (elements);
+
+  return bin;
+}
+
+static GstEncodingProfile *
+load_encoding_profile (void)
+{
+  GstEncodingProfile *prof = NULL;
+  GstEncodingTarget *target = NULL;
+  GError *error = NULL;
+
+  /* if profile file was given, try to load profile from there */
+  if (gep_filename && gep_profilename) {
+    target = gst_encoding_target_load_from_file (gep_filename, &error);
+    if (!target) {
+      GST_WARNING ("Could not load target %s from file %s", gep_targetname,
+          gep_filename);
+      if (error) {
+        GST_WARNING ("Error from file loading: %s", error->message);
+        g_error_free (error);
+        error = NULL;
+      }
+    } else {
+      prof = gst_encoding_target_get_profile (target, gep_profilename);
+      if (prof)
+        GST_DEBUG ("Loaded encoding profile %s from %s", gep_profilename,
+            gep_filename);
+      else
+        GST_WARNING
+            ("Could not load specified encoding profile %s from file %s",
+            gep_profilename, gep_filename);
+    }
+    /* if we could not load profile from file then try to find one from system */
+  } else if (gep_profilename && gep_targetname) {
+    prof = gst_encoding_profile_find (gep_targetname, gep_profilename, NULL);
+    if (prof)
+      GST_DEBUG ("Loaded encoding profile %s from target %s", gep_profilename,
+          gep_targetname);
+  } else
+    GST_DEBUG
+        ("Encoding profile not set, using camerabin2 default encoding profile");
+
+  return prof;
+}
+
+static gboolean
+setup_pipeline_element (GstElement * element, const gchar * property_name,
+    const gchar * element_name, GstElement ** res_elem)
+{
+  gboolean res = TRUE;
+  GstElement *elem = NULL;
+
+  if (element_name) {
+    elem = gst_element_factory_make (element_name, NULL);
+    if (elem) {
+      if (g_object_class_find_property (G_OBJECT_GET_CLASS (elem), "device")) {
+        g_object_set (elem, "device", "/dev/video1", NULL);
+      }
+      if (g_object_class_find_property (G_OBJECT_GET_CLASS (elem), "queue-size")) {
+        g_object_set (elem, "queue-size", 15, NULL);
+      }
+      if (g_object_class_find_property (G_OBJECT_GET_CLASS (elem), "sync")) {
+        g_object_set (elem, "sync", FALSE, NULL);
+      }
+      if (g_object_class_find_property (G_OBJECT_GET_CLASS (elem), "enable-last-buffer")) {
+        g_object_set (elem, "enable-last-buffer", FALSE, NULL);
+      }
+      g_object_set (element, property_name, elem, NULL);
+    } else {
+      GST_WARNING ("can't create element '%s' for property '%s'", element_name,
+          property_name);
+      res = FALSE;
+    }
+  } else {
+    GST_DEBUG ("no element for property '%s' given", property_name);
+  }
+  if (res_elem)
+    *res_elem = elem;
+  return res;
+}
+
+
+static gboolean
+setup_pipeline (void)
+{
+  gboolean res = TRUE;
+  GstBus *bus;
+  GstElement *sink = NULL, *ipp = NULL;
+  GstElement *stride;
+  GstEncodingProfile *prof = NULL;
+  camerabin = gst_element_factory_make ("camerabin2", NULL);
+  if (NULL == camerabin) {
+    g_warning ("can't create camerabin element\n");
+    goto error;
+  }
+
+  stride = gst_element_factory_make ("stridetransform", "capsfilter-stride");
+  g_object_set (camerabin, "preview-filter", stride, NULL);
+
+  bus = gst_pipeline_get_bus (GST_PIPELINE (camerabin));
+  /* Add sync handler for time critical messages that need to be handled fast */
+  gst_bus_set_sync_handler (bus, sync_bus_callback, NULL);
+  /* Handle normal messages asynchronously */
+  gst_bus_add_watch (bus, bus_callback, NULL);
+  gst_object_unref (bus);
+
+  GST_INFO_OBJECT (camerabin, "camerabin2 created");
+
+  if (videosrc_name) {
+    GstElement *wrapper;
+
+    if (wrappersrc_name)
+      wrapper = gst_element_factory_make (wrappersrc_name, NULL);
+    else
+      wrapper = gst_element_factory_make ("wrappercamerabinsrc", NULL);
+
+    if (setup_pipeline_element (wrapper, "video-src", videosrc_name, NULL)) {
+      g_object_set (camerabin, "camera-src", wrapper, NULL);
+    } else {
+      GST_WARNING ("Failed to set videosrc to %s", videosrc_name);
+    }
+  }
+
+  /* configure used elements */
+  res &= setup_pipeline_element (camerabin, "viewfinder-sink", vfsink_name,
+      &sink);
+  res &= setup_pipeline_element (camerabin, "viewfinder-filter",
+      viewfinder_filter, NULL);
+
+  if (imagepp_name) {
+    ipp = create_ipp_bin ();
+    if (ipp)
+      g_object_set (camerabin, "image-filter", ipp, NULL);
+    else
+      GST_WARNING ("Could not create ipp elements");
+  }
+
+  prof = load_encoding_profile ();
+  if (prof)
+    g_object_set (G_OBJECT (camerabin), "video-profile", prof, NULL);
+
+  GST_INFO_OBJECT (camerabin, "elements created");
+
+#if 0
+  if (sink)
+    g_object_set (sink, "sync", TRUE, NULL);
+#endif
+
+  GST_INFO_OBJECT (camerabin, "elements configured");
+
+  /* configure a resolution and framerate */
+  if (image_width > 0 && image_height > 0) {
+    if (mode == MODE_VIDEO) {
+      GstCaps *caps = NULL;
+      if (view_framerate_num > 0)
+        caps = gst_caps_new_full (gst_structure_new ("video/x-raw-yuv",
+                "width", G_TYPE_INT, image_width,
+                "height", G_TYPE_INT, image_height,
+                "framerate", GST_TYPE_FRACTION, view_framerate_num,
+                view_framerate_den, NULL),
+            gst_structure_new ("video/x-raw-rgb",
+                "width", G_TYPE_INT, image_width,
+                "height", G_TYPE_INT, image_height,
+                "framerate", GST_TYPE_FRACTION, view_framerate_num,
+                view_framerate_den, NULL), NULL);
+      else {
+        caps = gst_caps_new_full (gst_structure_new ("video/x-raw-yuv-strided",
+                "width", G_TYPE_INT, image_width,
+                "height", G_TYPE_INT, image_height, NULL),
+            gst_structure_new ("video/x-raw-rgb",
+                "width", G_TYPE_INT, image_width,
+                "height", G_TYPE_INT, image_height, NULL), NULL);
+      }
+
+      //g_object_set (camerabin, "video-capture-caps", caps, NULL);
+      g_object_set (camerabin, "viewfinder-caps", caps, NULL);
+      gst_caps_unref (caps);
+    } else {
+      GstCaps *caps = gst_caps_new_full (gst_structure_new ("image/jpeg",
+              "width", G_TYPE_INT, image_width,
+              "height", G_TYPE_INT, image_height, NULL),
+		NULL);
+      g_object_set (camerabin, "image-capture-caps", caps, NULL);
+      gst_caps_unref (caps);
+    }
+  }
+  
+g_object_set (camerabin, "mode", mode, NULL);
+
+  if (GST_STATE_CHANGE_FAILURE ==
+      gst_element_set_state (camerabin, GST_STATE_READY)) {
+    g_warning ("can't set camerabin to ready\n");
+    goto error;
+  }
+  GST_INFO_OBJECT (camerabin, "camera ready");
+
+  if (GST_STATE_CHANGE_FAILURE ==
+      gst_element_set_state (camerabin, GST_STATE_PLAYING)) {
+    g_warning ("can't set camerabin to playing\n");
+    goto error;
+  }
+
+  GST_INFO_OBJECT (camerabin, "camera started");
+  return TRUE;
+error:
+  cleanup_pipeline ();
+  return FALSE;
+}
+
+static void
+stop_capture_cb (GObject * self, GParamSpec * pspec, gpointer user_data)
+{
+  gboolean idle = FALSE;
+
+  g_object_get (camerabin, "idle", &idle, NULL);
+
+  if (idle) {
+    if (capture_count < capture_total) {
+      g_idle_add ((GSourceFunc) run_pipeline, NULL);
+    } else {
+      g_main_loop_quit (loop);
+    }
+  }
+
+  g_signal_handler_disconnect (camerabin, stop_capture_cb_id);
+}
+
+static gboolean
+stop_capture (gpointer user_data)
+{
+  stop_capture_cb_id = g_signal_connect (camerabin, "notify::idle",
+      (GCallback) stop_capture_cb, camerabin);
+  g_signal_emit_by_name (camerabin, "stop-capture", 0);
+  return FALSE;
+}
+
+static void
+set_metadata (GstElement * camera)
+{
+  GstTagSetter *setter = GST_TAG_SETTER (camera);
+  GTimeVal time = { 0, 0 };
+  gchar *desc_str;
+  GDate *date = g_date_new ();
+
+  g_get_current_time (&time);
+  g_date_set_time_val (date, &time);
+
+  desc_str = g_strdup_printf ("captured by %s", g_get_real_name ());
+
+  gst_tag_setter_add_tags (setter, GST_TAG_MERGE_REPLACE,
+      GST_TAG_DATE, date,
+      GST_TAG_DESCRIPTION, desc_str,
+      GST_TAG_TITLE, "gst-camerabin-test capture",
+      GST_TAG_GEO_LOCATION_LONGITUDE, 1.0,
+      GST_TAG_GEO_LOCATION_LATITUDE, 2.0,
+      GST_TAG_GEO_LOCATION_ELEVATION, 3.0,
+      GST_TAG_DEVICE_MANUFACTURER, "gst-camerabin-test manufacturer",
+      GST_TAG_DEVICE_MODEL, "gst-camerabin-test model", NULL);
+
+  g_free (desc_str);
+  g_date_free (date);
+}
+
+static gboolean
+run_pipeline (gpointer user_data)
+{
+  GstCaps *preview_caps = NULL;
+  gchar *filename_str = NULL;
+  GstElement *video_source = NULL;
+  const gchar *filename_suffix;
+
+  g_object_set (camerabin, "mode", mode, NULL);
+
+  if (preview_caps_name != NULL) {
+    preview_caps = gst_caps_from_string (preview_caps_name);
+    if (preview_caps) {
+      g_object_set (camerabin, "preview-caps", preview_caps, NULL);
+      GST_DEBUG ("Preview caps set");
+    } else
+      GST_DEBUG ("Preview caps set but could not create caps from string");
+  }
+
+  set_metadata (camerabin);
+
+  /* Construct filename */
+  if (mode == MODE_VIDEO)
+    filename_suffix = ".mp4";
+  else
+    filename_suffix = ".jpg";
+  filename_str =
+      g_strdup_printf ("%s/test_%04u%s", filename->str, capture_count,
+      filename_suffix);
+  GST_DEBUG ("Setting filename: %s", filename_str);
+  g_object_set (camerabin, "location", filename_str, NULL);
+  g_free (filename_str);
+
+  g_object_get (camerabin, "camera-src", &video_source, NULL);
+  if (video_source) {
+    if (GST_IS_ELEMENT (video_source) &&
+        gst_element_implements_interface (video_source, GST_TYPE_PHOTOGRAPHY)) {
+      /* Set GstPhotography interface options. If option not given as
+         command-line parameter use default of the source element. */
+      if (scene_mode != SCENE_MODE_NONE)
+        g_object_set (video_source, "scene-mode", scene_mode, NULL);
+      if (ev_compensation != EV_COMPENSATION_NONE)
+        g_object_set (video_source, "ev-compensation", ev_compensation, NULL);
+      if (aperture != APERTURE_NONE)
+        g_object_set (video_source, "aperture", aperture, NULL);
+      if (flash_mode != FLASH_MODE_NONE)
+        g_object_set (video_source, "flash-mode", flash_mode, NULL);
+      if (exposure != EXPOSURE_NONE)
+        g_object_set (video_source, "exposure", exposure, NULL);
+      if (iso_speed != ISO_SPEED_NONE)
+        g_object_set (video_source, "iso-speed", iso_speed, NULL);
+      if (wb_mode != WHITE_BALANCE_MODE_NONE)
+        g_object_set (video_source, "white-balance-mode", wb_mode, NULL);
+      if (color_mode != COLOR_TONE_MODE_NONE)
+        g_object_set (video_source, "colour-tone-mode", color_mode, NULL);
+    }
+    g_object_unref (video_source);
+  }
+  g_object_set (camerabin, "zoom", zoom / 100.0f, NULL);
+
+  capture_count++;
+  g_timer_start (timer);
+  g_signal_emit_by_name (camerabin, "start-capture", 0);
+
+
+  if (mode == MODE_VIDEO) {
+    g_timeout_add ((capture_time * 1000), (GSourceFunc) stop_capture, NULL);
+  }
+
+  return FALSE;
+}
+
+int
+main (int argc, char *argv[])
+{
+  gchar *target_times = NULL;
+  gchar *ev_option = NULL;
+  gchar *fn_option = NULL;
+
+  GOptionEntry options[] = {
+    {"ev-compensation", '\0', G_OPTION_FLAG_OPTIONAL_ARG, G_OPTION_ARG_STRING,
+          &ev_option,
+        "EV compensation for source element GstPhotography interface", NULL},
+    {"aperture", '\0', G_OPTION_FLAG_OPTIONAL_ARG, G_OPTION_ARG_INT, &aperture,
+          "Aperture (size of lens opening) for source element GstPhotography interface",
+        NULL},
+    {"flash-mode", '\0', G_OPTION_FLAG_OPTIONAL_ARG, G_OPTION_ARG_INT,
+          &flash_mode,
+        "Flash mode for source element GstPhotography interface", NULL},
+    {"scene-mode", '\0', G_OPTION_FLAG_OPTIONAL_ARG, G_OPTION_ARG_INT,
+          &scene_mode,
+        "Scene mode for source element GstPhotography interface", NULL},
+    {"exposure", '\0', G_OPTION_FLAG_OPTIONAL_ARG, G_OPTION_ARG_INT64,
+          &exposure,
+          "Exposure time (in ms) for source element GstPhotography interface",
+        NULL},
+    {"iso-speed", '\0', G_OPTION_FLAG_OPTIONAL_ARG, G_OPTION_ARG_INT,
+          &iso_speed,
+        "ISO speed for source element GstPhotography interface", NULL},
+    {"white-balance-mode", '\0', G_OPTION_FLAG_OPTIONAL_ARG, G_OPTION_ARG_INT,
+          &wb_mode,
+        "White balance mode for source element GstPhotography interface", NULL},
+    {"colour-tone-mode", '\0', G_OPTION_FLAG_OPTIONAL_ARG, G_OPTION_ARG_INT,
+          &color_mode,
+        "Colour tone mode for source element GstPhotography interface", NULL},
+    {"directory", '\0', 0, G_OPTION_ARG_STRING, &fn_option,
+        "Directory for capture file(s) (default is current directory)", NULL},
+    {"mode", '\0', G_OPTION_FLAG_OPTIONAL_ARG, G_OPTION_ARG_INT, &mode,
+        "Capture mode (default = 1 (image), 2 = video)", NULL},
+    {"capture-time", '\0', G_OPTION_FLAG_OPTIONAL_ARG, G_OPTION_ARG_INT,
+          &capture_time,
+        "Time to capture video in seconds (default = 10)", NULL},
+    {"capture-total", '\0', 0, G_OPTION_ARG_INT, &capture_total,
+        "Total number of captures to be done (default = 1)", NULL},
+    {"zoom", '\0', G_OPTION_FLAG_OPTIONAL_ARG, G_OPTION_ARG_INT, &zoom,
+        "Zoom (100 = 1x (default), 200 = 2x etc.)", NULL},
+    {"wrapper-source", '\0', 0, G_OPTION_ARG_STRING, &wrappersrc_name,
+          "Camera source wrapper used for setting the video source (default is wrappercamerabinsrc)",
+        NULL},
+    {"video-source", '\0', 0, G_OPTION_ARG_STRING, &videosrc_name,
+        "Video source used in still capture and video recording", NULL},
+    {"image-pp", '\0', 0, G_OPTION_ARG_STRING, &imagepp_name,
+        "List of image post-processing elements separated with comma", NULL},
+    {"viewfinder-sink", '\0', 0, G_OPTION_ARG_STRING, &vfsink_name,
+        "Viewfinder sink (default = fakesink)", NULL},
+    {"image-width", '\0', 0, G_OPTION_ARG_INT, &image_width,
+        "Width for image capture", NULL},
+    {"image-height", '\0', 0, G_OPTION_ARG_INT, &image_height,
+        "Height for image capture", NULL},
+    {"view-framerate-num", '\0', 0, G_OPTION_ARG_INT, &view_framerate_num,
+        "Framerate numerator for viewfinder", NULL},
+    {"view-framerate-den", '\0', 0, G_OPTION_ARG_INT, &view_framerate_den,
+        "Framerate denominator for viewfinder", NULL},
+    {"preview-caps", '\0', 0, G_OPTION_ARG_STRING, &preview_caps_name,
+        "Preview caps (e.g. video/x-raw-rgb,width=864,height=480)", NULL},
+    {"viewfinder-filter", '\0', 0, G_OPTION_ARG_STRING, &viewfinder_filter,
+        "Filter to process all frames going to viewfinder sink", NULL},
+    {"x-width", '\0', 0, G_OPTION_ARG_INT, &x_width,
+        "X window width (default = 864)", NULL},
+    {"x-height", '\0', 0, G_OPTION_ARG_INT, &x_height,
+        "X window height (default = 480)", NULL},
+    {"no-xwindow", '\0', 0, G_OPTION_ARG_NONE, &no_xwindow,
+        "Do not create XWindow", NULL},
+    {"encoding-target", '\0', 0, G_OPTION_ARG_STRING, &gep_targetname,
+        "Video encoding target name", NULL},
+    {"encoding-profile", '\0', 0, G_OPTION_ARG_STRING, &gep_profilename,
+        "Video encoding profile name", NULL},
+    {"encoding-profile-filename", '\0', 0, G_OPTION_ARG_STRING, &gep_filename,
+        "Video encoding profile filename", NULL},
+    {NULL}
+  };
+
+  GOptionContext *ctx;
+  GError *err = NULL;
+
+  if (!g_thread_supported ())
+    g_thread_init (NULL);
+
+  ctx = g_option_context_new ("\n\ncamerabin command line test application.");
+  g_option_context_add_main_entries (ctx, options, NULL);
+  g_option_context_add_group (ctx, gst_init_get_option_group ());
+  if (!g_option_context_parse (ctx, &argc, &argv, &err)) {
+    g_print ("Error initializing: %s\n", err->message);
+    exit (1);
+  }
+  g_option_context_free (ctx);
+
+  GST_DEBUG_CATEGORY_INIT (camerabin_test, "camerabin-test", 0,
+      "camerabin test");
+
+  /* if we fail to create xwindow should we care? */
+  if (!no_xwindow)
+    create_host_window ();
+
+  /* FIXME: error handling */
+  if (ev_option != NULL)
+    ev_compensation = strtod (ev_option, (char **) NULL);
+
+  if (vfsink_name == NULL)
+    vfsink_name = g_strdup ("fakesink");
+
+  filename = g_string_new (fn_option);
+  if (filename->len == 0)
+    filename = g_string_append (filename, ".");
+
+  timer = g_timer_new ();
+
+  /* init */
+  if (setup_pipeline ()) {
+    loop = g_main_loop_new (NULL, FALSE);
+    g_idle_add ((GSourceFunc) run_pipeline, NULL);
+    g_main_loop_run (loop);
+    cleanup_pipeline ();
+    g_main_loop_unref (loop);
+  }
+  /* free */
+  g_string_free (filename, TRUE);
+  g_free (ev_option);
+  g_free (wrappersrc_name);
+  g_free (videosrc_name);
+  g_free (imagepp_name);
+  g_free (vfsink_name);
+  g_free (target_times);
+  g_free (gep_targetname);
+  g_free (gep_profilename);
+  g_free (gep_filename);
+  g_timer_destroy (timer);
+
+  if (window)
+    XDestroyWindow (display, window);
+
+  if (display)
+    XCloseDisplay (display);
+
+  return 0;
+}
-- 
1.7.1

