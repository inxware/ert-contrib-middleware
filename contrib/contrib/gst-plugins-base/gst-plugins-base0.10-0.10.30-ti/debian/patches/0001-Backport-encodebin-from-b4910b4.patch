From 92ab9360892b2e9ce79ddaf67bb8b4a1b0e44e9d Mon Sep 17 00:00:00 2001
From: Alessandro Decina <alessandro.decina@collabora.co.uk>
Date: Fri, 6 May 2011 00:16:05 +0200
Subject: [PATCH 1/4] Backport encodebin from b4910b4

---
 configure.ac                            |    8 +
 gst-libs/gst/pbutils/Makefile.am        |    4 +
 gst-libs/gst/pbutils/encoding-profile.c |  966 +++++++++++++++++
 gst-libs/gst/pbutils/encoding-profile.h |  187 ++++
 gst-libs/gst/pbutils/encoding-target.c  | 1204 +++++++++++++++++++++
 gst-libs/gst/pbutils/encoding-target.h  |  147 +++
 gst-libs/gst/pbutils/pbutils.h          |    2 +
 gst/encoding/.gitignore                 |    1 +
 gst/encoding/Makefile.am                |   41 +
 gst/encoding/gstencode-marshal.list     |    1 +
 gst/encoding/gstencodebin.c             | 1783 +++++++++++++++++++++++++++++++
 gst/encoding/gstencodebin.h             |   39 +
 gst/encoding/gstsmartencoder.c          |  701 ++++++++++++
 gst/encoding/gstsmartencoder.h          |   71 ++
 gst/encoding/gststreamcombiner.c        |  276 +++++
 gst/encoding/gststreamcombiner.h        |   60 +
 gst/encoding/gststreamsplitter.c        |  435 ++++++++
 gst/encoding/gststreamsplitter.h        |   62 ++
 tests/examples/Makefile.am              |    4 +-
 tests/examples/encoding/.gitignore      |    1 +
 tests/examples/encoding/Makefile.am     |   12 +
 tests/examples/encoding/encoding.c      |  512 +++++++++
 tests/examples/encoding/gstcapslist.c   |  286 +++++
 tests/examples/encoding/gstcapslist.h   |   35 +
 24 files changed, 6836 insertions(+), 2 deletions(-)
 create mode 100644 gst-libs/gst/pbutils/encoding-profile.c
 create mode 100644 gst-libs/gst/pbutils/encoding-profile.h
 create mode 100644 gst-libs/gst/pbutils/encoding-target.c
 create mode 100644 gst-libs/gst/pbutils/encoding-target.h
 create mode 100644 gst/encoding/.gitignore
 create mode 100644 gst/encoding/Makefile.am
 create mode 100644 gst/encoding/gstencode-marshal.list
 create mode 100644 gst/encoding/gstencodebin.c
 create mode 100644 gst/encoding/gstencodebin.h
 create mode 100644 gst/encoding/gstsmartencoder.c
 create mode 100644 gst/encoding/gstsmartencoder.h
 create mode 100644 gst/encoding/gststreamcombiner.c
 create mode 100644 gst/encoding/gststreamcombiner.h
 create mode 100644 gst/encoding/gststreamsplitter.c
 create mode 100644 gst/encoding/gststreamsplitter.h
 create mode 100644 tests/examples/encoding/.gitignore
 create mode 100644 tests/examples/encoding/Makefile.am
 create mode 100644 tests/examples/encoding/encoding.c
 create mode 100644 tests/examples/encoding/gstcapslist.c
 create mode 100644 tests/examples/encoding/gstcapslist.h

diff --git a/configure.ac b/configure.ac
index 10be6be..d088e93 100644
--- a/configure.ac
+++ b/configure.ac
@@ -345,6 +345,11 @@ AG_GST_SET_LEVEL_DEFAULT($GST_GIT)
 dnl used in examples
 AG_GST_DEFAULT_ELEMENTS
 
+dnl needed for encoding-target
+GST_DATADIR="$GST_PREFIX/share"
+AC_DEFINE_UNQUOTED(GST_DATADIR, "$GST_DATADIR", [system wide data directory])
+AC_DEFINE_UNQUOTED(GST_MAJORMINOR, "$GST_MAJORMINOR", [major/minor version])
+
 dnl behaviour of speex based audio resampler
 AC_MSG_CHECKING(which audio resample format to use for integer)
 AC_ARG_WITH([audioresample_format],
@@ -373,6 +378,7 @@ AG_GST_CHECK_PLUGIN(app)
 AG_GST_CHECK_PLUGIN(audioconvert)
 AG_GST_CHECK_PLUGIN(audiorate)
 AG_GST_CHECK_PLUGIN(audiotestsrc)
+AG_GST_CHECK_PLUGIN(encoding)
 AG_GST_CHECK_PLUGIN(ffmpegcolorspace)
 AG_GST_CHECK_PLUGIN(gdp)
 AG_GST_CHECK_PLUGIN(playback)
@@ -872,6 +878,7 @@ gst/app/Makefile
 gst/audioconvert/Makefile
 gst/audiorate/Makefile
 gst/audiotestsrc/Makefile
+gst/encoding/Makefile
 gst/ffmpegcolorspace/Makefile
 gst/gdp/Makefile
 gst/playback/Makefile
@@ -951,6 +958,7 @@ tests/check/Makefile
 tests/examples/Makefile
 tests/examples/app/Makefile
 tests/examples/dynamic/Makefile
+tests/examples/encoding/Makefile
 tests/examples/overlay/Makefile
 tests/examples/seek/Makefile
 tests/examples/volume/Makefile
diff --git a/gst-libs/gst/pbutils/Makefile.am b/gst-libs/gst/pbutils/Makefile.am
index fe635e5..cb1c455 100644
--- a/gst-libs/gst/pbutils/Makefile.am
+++ b/gst-libs/gst/pbutils/Makefile.am
@@ -3,6 +3,8 @@ lib_LTLIBRARIES = libgstpbutils-@GST_MAJORMINOR@.la
 headers_pbutils = \
 	pbutils.h         \
 	descriptions.h    \
+	encoding-profile.h	\
+	encoding-target.h	\
 	install-plugins.h \
 	missing-plugins.h
 
@@ -21,6 +23,8 @@ built_headers = \
 libgstpbutils_@GST_MAJORMINOR@_la_SOURCES = \
 	pbutils.c         \
 	descriptions.c    \
+	encoding-profile.c	\
+	encoding-target.c	\
 	install-plugins.c \
 	missing-plugins.c
 
diff --git a/gst-libs/gst/pbutils/encoding-profile.c b/gst-libs/gst/pbutils/encoding-profile.c
new file mode 100644
index 0000000..eaa7507
--- /dev/null
+++ b/gst-libs/gst/pbutils/encoding-profile.c
@@ -0,0 +1,966 @@
+/* GStreamer encoding profiles library
+ * Copyright (C) 2009-2010 Edward Hervey <edward.hervey@collabora.co.uk>
+ *           (C) 2009-2010 Nokia Corporation
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/**
+ * SECTION:encoding-profile
+ * @short_description: Encoding profile library
+ *
+ * <refsect2>
+ * <para>
+ * Functions to create and handle encoding profiles.
+ * </para>
+ * <para>
+ * Encoding profiles describe the media types and settings one wishes to use for
+ * an encoding process. The top-level profiles are commonly
+ * #GstEncodingContainerProfile(s) (which contains a user-readable name and
+ * description along with which container format to use). These, in turn,
+ * reference one or more #GstEncodingProfile(s) which indicate which encoding
+ * format should be used on each individual streams.
+ * </para>
+ * <para>
+ * #GstEncodingProfile(s) can be provided to the 'encodebin' element, which will take
+ * care of selecting and setting up the required elements to produce an output stream
+ * conforming to the specifications of the profile.
+ * </para>
+ * <para>
+ * Unlike other systems, the encoding profiles do not specify which #GstElement to use
+ * for the various encoding and muxing steps, but instead relies on specifying the format
+ * one wishes to use.
+ * </para>
+ * <para>
+ * Encoding profiles can be created at runtime by the application or loaded from (and saved
+ * to) file using the #GstEncodingTarget API.
+ * </para>
+ * </refsect2>
+ * <refsect2>
+ * <title>Example: Creating a profile</title>
+ * <para>
+ * |[
+ * #include <gst/pbutils/encoding-profile.h>
+ * ...
+ * GstEncodingProfile *
+ * create_ogg_theora_profile(void)
+ *{
+ *  GstEncodingContainerProfile *prof;
+ *  GstCaps *caps;
+ *
+ *  caps = gst_caps_from_string("application/ogg");
+ *  prof = gst_encoding_container_profile_new("Ogg audio/video",
+ *     "Standard OGG/THEORA/VORBIS",
+ *     caps, NULL);
+ *  gst_caps_unref (caps);
+ *
+ *  caps = gst_caps_from_string("video/x-theora");
+ *  gst_encoding_container_profile_add_profile(prof,
+ *       (GstEncodingProfile*) gst_encoding_video_profile_new(caps, NULL, NULL, 0));
+ *  gst_caps_unref (caps);
+ *
+ *  caps = gst_caps_from_string("audio/x-vorbis");
+ *  gst_encoding_container_profile_add_profile(prof,
+ *       (GstEncodingProfile*) gst_encoding_audio_profile_new(caps, NULL, NULL, 0));
+ *  gst_caps_unref (caps);
+ *
+ *  return (GstEncodingProfile*) prof;
+ *}
+ *
+ *
+ * ]|
+ * </para>
+ * </refsect2>
+ * <refsect2>
+ * <title>Example: Listing categories, targets and profiles</title>
+ * <para>
+ * |[
+ * #include <gst/pbutils/encoding-profile.h>
+ * ...
+ * GstEncodingProfile *prof;
+ * GList *categories, *tmpc;
+ * GList *targets, *tmpt;
+ * ...
+ * categories = gst_encoding_target_list_available_categories();
+ *
+ * ... Show available categories to user ...
+ *
+ * for (tmpc = categories; tmpc; tmpc = tmpc->next) {
+ *   gchar *category = (gchar *) tmpc->data;
+ *
+ *   ... and we can list all targets within that category ...
+ *   
+ *   targets = gst_encoding_target_list_all (category);
+ *
+ *   ... and show a list to our users ...
+ *
+ *   g_list_foreach (targets, (GFunc) gst_encoding_target_unref, NULL);
+ *   g_list_free (targets);
+ * }
+ *
+ * g_list_foreach (categories, (GFunc) g_free, NULL);
+ * g_list_free (categories);
+ *
+ * ...
+ * ]|
+ * </para>
+ * </refsect2>
+ *
+ * Since: 0.10.32
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include "encoding-profile.h"
+#include "encoding-target.h"
+
+/* GstEncodingProfile API */
+
+struct _GstEncodingProfile
+{
+  GstMiniObject parent;
+
+  /*< public > */
+  gchar *name;
+  gchar *description;
+  GstCaps *format;
+  gchar *preset;
+  guint presence;
+  GstCaps *restriction;
+};
+
+static void string_to_profile_transform (const GValue * src_value,
+    GValue * dest_value);
+static gboolean gst_encoding_profile_deserialize_valfunc (GValue * value,
+    const gchar * s);
+
+static void gst_encoding_profile_class_init (GstEncodingProfileClass * klass);
+static gpointer gst_encoding_profile_parent_class = NULL;
+
+static void
+gst_encoding_profile_class_intern_init (gpointer klass)
+{
+  gst_encoding_profile_parent_class = g_type_class_peek_parent (klass);
+  gst_encoding_profile_class_init ((GstEncodingProfileClass *) klass);
+}
+
+GType
+gst_encoding_profile_get_type (void)
+{
+  static volatile gsize g_define_type_id__volatile = 0;
+
+  if (g_once_init_enter (&g_define_type_id__volatile)) {
+    GType g_define_type_id =
+        g_type_register_static_simple (GST_TYPE_MINI_OBJECT,
+        g_intern_static_string ("GstEncodingProfile"),
+        sizeof (GstEncodingProfileClass),
+        (GClassInitFunc) gst_encoding_profile_class_intern_init,
+        sizeof (GstEncodingProfile),
+        NULL,
+        (GTypeFlags) 0);
+    static GstValueTable gstvtable = {
+      G_TYPE_NONE,
+      (GstValueCompareFunc) NULL,
+      (GstValueSerializeFunc) NULL,
+      (GstValueDeserializeFunc) gst_encoding_profile_deserialize_valfunc
+    };
+
+    gstvtable.type = g_define_type_id;
+
+    /* Register a STRING=>PROFILE GValueTransformFunc */
+    g_value_register_transform_func (G_TYPE_STRING, g_define_type_id,
+        string_to_profile_transform);
+    /* Register gst-specific GValue functions */
+    gst_value_register (&gstvtable);
+
+    g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
+  }
+  return g_define_type_id__volatile;
+}
+
+static void
+gst_encoding_profile_finalize (GstEncodingProfile * prof)
+{
+  if (prof->name)
+    g_free (prof->name);
+  if (prof->format)
+    gst_caps_unref (prof->format);
+  if (prof->preset)
+    g_free (prof->preset);
+  if (prof->description)
+    g_free (prof->description);
+  if (prof->restriction)
+    gst_caps_unref (prof->restriction);
+}
+
+static void
+gst_encoding_profile_class_init (GstMiniObjectClass * klass)
+{
+  klass->finalize =
+      (GstMiniObjectFinalizeFunction) gst_encoding_profile_finalize;
+}
+
+/**
+ * gst_encoding_profile_get_name:
+ * @profile: a #GstEncodingProfile
+ *
+ * Since: 0.10.32
+ *
+ * Returns: the name of the profile, can be %NULL.
+ */
+const gchar *
+gst_encoding_profile_get_name (GstEncodingProfile * profile)
+{
+  return profile->name;
+}
+
+/**
+ * gst_encoding_profile_get_description:
+ * @profile: a #GstEncodingProfile
+ *
+ * Since: 0.10.32
+ *
+ * Returns: the description of the profile, can be %NULL.
+ */
+const gchar *
+gst_encoding_profile_get_description (GstEncodingProfile * profile)
+{
+  return profile->description;
+}
+
+/**
+ * gst_encoding_profile_get_format:
+ * @profile: a #GstEncodingProfile
+ *
+ * Since: 0.10.32
+ *
+ * Returns: the #GstCaps corresponding to the media format used in the profile.
+ */
+const GstCaps *
+gst_encoding_profile_get_format (GstEncodingProfile * profile)
+{
+  return profile->format;
+}
+
+/**
+ * gst_encoding_profile_get_preset:
+ * @profile: a #GstEncodingProfile
+ *
+ * Since: 0.10.32
+ *
+ * Returns: the name of the #GstPreset to be used in the profile.
+ */
+const gchar *
+gst_encoding_profile_get_preset (GstEncodingProfile * profile)
+{
+  return profile->preset;
+}
+
+/**
+ * gst_encoding_profile_get_presence:
+ * @profile: a #GstEncodingProfile
+ *
+ * Since: 0.10.32
+ *
+ * Returns: The number of times the profile is used in its parent
+ * container profile. If 0, it is not a mandatory stream.
+ */
+guint
+gst_encoding_profile_get_presence (GstEncodingProfile * profile)
+{
+  return profile->presence;
+}
+
+/**
+ * gst_encoding_profile_get_restriction:
+ * @profile: a #GstEncodingProfile
+ *
+ * Since: 0.10.32
+ *
+ * Returns: The restriction #GstCaps to apply before the encoder
+ * that will be used in the profile. The fields present in restriction caps are
+ * properties of the raw stream (that is before encoding), such as height and
+ * width for video and depth and sampling rate for audio. Does not apply to
+ * #GstEncodingContainerProfile (since there is no corresponding raw stream).
+ * Can be %NULL.
+ */
+const GstCaps *
+gst_encoding_profile_get_restriction (GstEncodingProfile * profile)
+{
+  return profile->restriction;
+}
+
+/**
+ * gst_encoding_profile_set_name:
+ * @profile: a #GstEncodingProfile
+ * @name: the name to set on the profile
+ *
+ * Set @name as the given name for the @profile. A copy of @name will be made
+ * internally.
+ *
+ * Since: 0.10.32
+ */
+void
+gst_encoding_profile_set_name (GstEncodingProfile * profile, const gchar * name)
+{
+  if (profile->name)
+    g_free (profile->name);
+  profile->name = g_strdup (name);
+}
+
+/**
+ * gst_encoding_profile_set_description:
+ * @profile: a #GstEncodingProfile
+ * @description: the description to set on the profile
+ *
+ * Set @description as the given description for the @profile. A copy of @description will be made
+ * internally.
+ *
+ * Since: 0.10.32
+ */
+void
+gst_encoding_profile_set_description (GstEncodingProfile * profile,
+    const gchar * description)
+{
+  if (profile->description)
+    g_free (profile->description);
+  profile->description = g_strdup (description);
+}
+
+/**
+ * gst_encoding_profile_set_format:
+ * @profile: a #GstEncodingProfile
+ * @format: the media format to use in the profile.
+ *
+ * Sets the media format used in the profile.
+ *
+ * Since: 0.10.32
+ */
+void
+gst_encoding_profile_set_format (GstEncodingProfile * profile, GstCaps * format)
+{
+  if (profile->format)
+    gst_caps_unref (profile->format);
+  profile->format = gst_caps_ref (format);
+}
+
+/**
+ * gst_encoding_profile_set_preset:
+ * @profile: a #GstEncodingProfile
+ * @preset: the element preset to use
+ *
+ * Sets the preset to use for the profile.
+ *
+ * Since: 0.10.32
+ */
+void
+gst_encoding_profile_set_preset (GstEncodingProfile * profile,
+    const gchar * preset)
+{
+  if (profile->preset)
+    g_free (profile->preset);
+  profile->preset = g_strdup (preset);
+}
+
+/**
+ * gst_encoding_profile_set_presence:
+ * @profile: a #GstEncodingProfile
+ * @presence: the number of time the profile can be used
+ *
+ * Set the number of time the profile is used in its parent
+ * container profile. If 0, it is not a mandatory stream
+ *
+ * Since: 0.10.32
+ */
+void
+gst_encoding_profile_set_presence (GstEncodingProfile * profile, guint presence)
+{
+  profile->presence = presence;
+}
+
+/**
+ * gst_encoding_profile_set_restriction:
+ * @profile: a #GstEncodingProfile
+ * @restriction: the restriction to apply
+ *
+ * Set the restriction #GstCaps to apply before the encoder
+ * that will be used in the profile. See gst_encoding_profile_set_restriction()
+ * for more about restrictions. Does not apply to #GstEncodingContainerProfile.
+ *
+ * Since: 0.10.32
+ */
+void
+gst_encoding_profile_set_restriction (GstEncodingProfile * profile,
+    GstCaps * restriction)
+{
+  if (profile->restriction)
+    gst_caps_unref (profile->restriction);
+  profile->restriction = restriction;
+}
+
+/* Container profiles */
+
+struct _GstEncodingContainerProfile
+{
+  GstEncodingProfile parent;
+
+  GList *encodingprofiles;
+};
+
+G_DEFINE_TYPE (GstEncodingContainerProfile, gst_encoding_container_profile,
+    GST_TYPE_ENCODING_PROFILE);
+
+static void
+gst_encoding_container_profile_init (GstEncodingContainerProfile * prof)
+{
+  /* Nothing to initialize */
+}
+
+static void
+gst_encoding_container_profile_finalize (GstEncodingContainerProfile * prof)
+{
+  g_list_foreach (prof->encodingprofiles, (GFunc) gst_mini_object_unref, NULL);
+  g_list_free (prof->encodingprofiles);
+
+  GST_MINI_OBJECT_CLASS (gst_encoding_container_profile_parent_class)->finalize
+      ((GstMiniObject *) prof);
+}
+
+static void
+gst_encoding_container_profile_class_init (GstMiniObjectClass * klass)
+{
+  klass->finalize =
+      (GstMiniObjectFinalizeFunction) gst_encoding_container_profile_finalize;
+}
+
+const GList *
+gst_encoding_container_profile_get_profiles (GstEncodingContainerProfile *
+    profile)
+{
+  return profile->encodingprofiles;
+}
+
+/* Video profiles */
+
+struct _GstEncodingVideoProfile
+{
+  GstEncodingProfile parent;
+
+  guint pass;
+  gboolean variableframerate;
+};
+
+G_DEFINE_TYPE (GstEncodingVideoProfile, gst_encoding_video_profile,
+    GST_TYPE_ENCODING_PROFILE);
+
+static void
+gst_encoding_video_profile_init (GstEncodingVideoProfile * prof)
+{
+  /* Nothing to initialize */
+}
+
+static void
+gst_encoding_video_profile_class_init (GstMiniObjectClass * klass)
+{
+}
+
+/**
+ * gst_encoding_video_profile_get_pass:
+ * @prof: a #GstEncodingVideoProfile
+ *
+ * Since: 0.10.32
+ *
+ * Returns: The pass number if this is part of a multi-pass profile. Starts at
+ * 1 for multi-pass. 0 if this is not a multi-pass profile
+ **/
+guint
+gst_encoding_video_profile_get_pass (GstEncodingVideoProfile * prof)
+{
+  return prof->pass;
+}
+
+/**
+ * gst_encoding_video_profile_get_variableframerate:
+ * @prof: a #GstEncodingVideoProfile
+ *
+ * Since: 0.10.32
+ *
+ * Returns: Whether non-constant video framerate is allowed for encoding.
+ */
+gboolean
+gst_encoding_video_profile_get_variableframerate (GstEncodingVideoProfile *
+    prof)
+{
+  return prof->variableframerate;
+}
+
+/**
+ * gst_encoding_video_profile_set_pass:
+ * @prof: a #GstEncodingVideoProfile
+ * @pass: the pass number for this profile
+ *
+ * Sets the pass number of this video profile. The first pass profile should have
+ * this value set to 1. If this video profile isn't part of a multi-pass profile,
+ * you may set it to 0 (the default value).
+ *
+ * Since: 0.10.32
+ */
+void
+gst_encoding_video_profile_set_pass (GstEncodingVideoProfile * prof, guint pass)
+{
+  prof->pass = pass;
+}
+
+/**
+ * gst_encoding_video_profile_set_variableframerate:
+ * @prof: a #GstEncodingVideoProfile
+ * @variableframerate: a boolean
+ *
+ * If set to %TRUE, then the incoming streamm will be allowed to have non-constant
+ * framerate. If set to %FALSE (default value), then the incoming stream will
+ * be normalized by dropping/duplicating frames in order to produce a
+ * constance framerate.
+ *
+ * Since: 0.10.32
+ */
+void
+gst_encoding_video_profile_set_variableframerate (GstEncodingVideoProfile *
+    prof, gboolean variableframerate)
+{
+  prof->variableframerate = variableframerate;
+}
+
+/* Audio profiles */
+
+struct _GstEncodingAudioProfile
+{
+  GstEncodingProfile parent;
+};
+
+G_DEFINE_TYPE (GstEncodingAudioProfile, gst_encoding_audio_profile,
+    GST_TYPE_ENCODING_PROFILE);
+
+static void
+gst_encoding_audio_profile_init (GstEncodingAudioProfile * prof)
+{
+  /* Nothing to initialize */
+}
+
+static void
+gst_encoding_audio_profile_class_init (GstMiniObjectClass * klass)
+{
+}
+
+static inline gboolean
+_gst_caps_is_equal_safe (GstCaps * a, GstCaps * b)
+{
+  if (a == b)
+    return TRUE;
+  if ((a == NULL) || (b == NULL))
+    return FALSE;
+  return gst_caps_is_equal (a, b);
+}
+
+static gint
+_compare_container_encoding_profiles (GstEncodingContainerProfile * ca,
+    GstEncodingContainerProfile * cb)
+{
+  GList *tmp;
+
+  if (g_list_length (ca->encodingprofiles) !=
+      g_list_length (cb->encodingprofiles))
+    return -1;
+
+  for (tmp = ca->encodingprofiles; tmp; tmp = tmp->next) {
+    GstEncodingProfile *prof = (GstEncodingProfile *) tmp->data;
+    if (!gst_encoding_container_profile_contains_profile (ca, prof))
+      return -1;
+  }
+
+  return 0;
+}
+
+static gint
+_compare_encoding_profiles (const GstEncodingProfile * a,
+    const GstEncodingProfile * b)
+{
+  if ((G_TYPE_FROM_INSTANCE (a) != G_TYPE_FROM_INSTANCE (b)) ||
+      !_gst_caps_is_equal_safe (a->format, b->format) ||
+      (g_strcmp0 (a->preset, b->preset) != 0) ||
+      (g_strcmp0 (a->name, b->name) != 0) ||
+      (g_strcmp0 (a->description, b->description) != 0))
+    return -1;
+
+  if (GST_IS_ENCODING_CONTAINER_PROFILE (a))
+    return
+        _compare_container_encoding_profiles (GST_ENCODING_CONTAINER_PROFILE
+        (a), GST_ENCODING_CONTAINER_PROFILE (b));
+
+  if (GST_IS_ENCODING_VIDEO_PROFILE (a)) {
+    GstEncodingVideoProfile *va = (GstEncodingVideoProfile *) a;
+    GstEncodingVideoProfile *vb = (GstEncodingVideoProfile *) b;
+
+    if ((va->pass != vb->pass)
+        || (va->variableframerate != vb->variableframerate))
+      return -1;
+  }
+
+  return 0;
+}
+
+/**
+ * gst_encoding_container_profile_contains_profile:
+ * @container: a #GstEncodingContainerProfile
+ * @profile: a #GstEncodingProfile
+ *
+ * Checks if @container contains a #GstEncodingProfile identical to
+ * @profile.
+ *
+ * Since: 0.10.32
+ *
+ * Returns: %TRUE if @container contains a #GstEncodingProfile identical
+ * to @profile, else %FALSE.
+ */
+gboolean
+gst_encoding_container_profile_contains_profile (GstEncodingContainerProfile *
+    container, GstEncodingProfile * profile)
+{
+  g_return_val_if_fail (GST_IS_ENCODING_CONTAINER_PROFILE (container), FALSE);
+  g_return_val_if_fail (GST_IS_ENCODING_PROFILE (profile), FALSE);
+
+  return (g_list_find_custom (container->encodingprofiles, profile,
+          (GCompareFunc) _compare_encoding_profiles) != NULL);
+}
+
+/**
+ * gst_encoding_container_profile_add_profile:
+ * @container: the #GstEncodingContainerProfile to use
+ * @profile: the #GstEncodingProfile to add.
+ *
+ * Add a #GstEncodingProfile to the list of profiles handled by @container.
+ * 
+ * No copy of @profile will be made, if you wish to use it elsewhere after this
+ * method you should increment its reference count.
+ *
+ * Since: 0.10.32
+ *
+ * Returns: %TRUE if the @stream was properly added, else %FALSE.
+ */
+gboolean
+gst_encoding_container_profile_add_profile (GstEncodingContainerProfile *
+    container, GstEncodingProfile * profile)
+{
+  g_return_val_if_fail (GST_IS_ENCODING_CONTAINER_PROFILE (container), FALSE);
+  g_return_val_if_fail (GST_IS_ENCODING_PROFILE (profile), FALSE);
+
+  if (g_list_find_custom (container->encodingprofiles, profile,
+          (GCompareFunc) _compare_encoding_profiles)) {
+    GST_ERROR
+        ("Encoding profile already contains an identical GstEncodingProfile");
+    return FALSE;
+  }
+
+  container->encodingprofiles =
+      g_list_append (container->encodingprofiles, profile);
+
+  return TRUE;
+}
+
+static GstEncodingProfile *
+common_creation (GType objtype, GstCaps * format, const gchar * preset,
+    const gchar * name, const gchar * description, GstCaps * restriction,
+    guint presence)
+{
+  GstEncodingProfile *prof;
+
+  prof = (GstEncodingProfile *) gst_mini_object_new (objtype);
+
+  if (name)
+    prof->name = g_strdup (name);
+  if (description)
+    prof->description = g_strdup (description);
+  if (preset)
+    prof->preset = g_strdup (preset);
+  if (format)
+    prof->format = gst_caps_ref (format);
+  if (restriction)
+    prof->restriction = gst_caps_ref (restriction);
+  prof->presence = presence;
+
+  return prof;
+}
+
+/**
+ * gst_encoding_container_profile_new:
+ * @name: The name of the container profile, can be %NULL
+ * @description: The description of the container profile, can be %NULL
+ * @format: The format to use for this profile
+ * @preset: The preset to use for this profile
+ *
+ * Creates a new #GstEncodingContainerProfile.
+ *
+ * Since: 0.10.32
+ *
+ * Returns: The newly created #GstEncodingContainerProfile.
+ */
+GstEncodingContainerProfile *
+gst_encoding_container_profile_new (const gchar * name,
+    const gchar * description, GstCaps * format, const gchar * preset)
+{
+  g_return_val_if_fail (GST_IS_CAPS (format), NULL);
+
+  return (GstEncodingContainerProfile *)
+      common_creation (GST_TYPE_ENCODING_CONTAINER_PROFILE, format, preset,
+      name, description, NULL, 0);
+}
+
+/**
+ * gst_encoding_video_profile_new:
+ * @format: the #GstCaps
+ * @preset: the preset(s) to use on the encoder, can be #NULL
+ * @restriction: the #GstCaps used to restrict the input to the encoder, can be
+ * NULL. See gst_encoding_profile_get_restriction() for more details.
+ * @presence: the number of time this stream must be used. 0 means any number of
+ *  times (including never)
+ *
+ * Creates a new #GstEncodingVideoProfile
+ *
+ * All provided allocatable arguments will be internally copied, so can be
+ * safely freed/unreferenced after calling this method.
+ *
+ * If you wish to control the pass number (in case of multi-pass scenarios),
+ * please refer to the gst_encoding_video_profile_set_pass() documentation.
+ *
+ * If you wish to use/force a constant framerate please refer to the
+ * gst_encoding_video_profile_set_variableframerate() documentation.
+ *
+ * Since: 0.10.32
+ *
+ * Returns: the newly created #GstEncodingVideoProfile.
+ */
+GstEncodingVideoProfile *
+gst_encoding_video_profile_new (GstCaps * format, const gchar * preset,
+    GstCaps * restriction, guint presence)
+{
+  return (GstEncodingVideoProfile *)
+      common_creation (GST_TYPE_ENCODING_VIDEO_PROFILE, format, preset, NULL,
+      NULL, restriction, presence);
+}
+
+/**
+ * gst_encoding_audio_profile_new:
+ * @format: the #GstCaps
+ * @preset: the preset(s) to use on the encoder, can be #NULL
+ * @restriction: the #GstCaps used to restrict the input to the encoder, can be
+ * NULL. See gst_encoding_profile_get_restriction() for more details.
+ * @presence: the number of time this stream must be used. 0 means any number of
+ *  times (including never)
+ *
+ * Creates a new #GstEncodingAudioProfile
+ *
+ * All provided allocatable arguments will be internally copied, so can be
+ * safely freed/unreferenced after calling this method.
+ *
+ * Since: 0.10.32
+ *
+ * Returns: the newly created #GstEncodingAudioProfile.
+ */
+GstEncodingAudioProfile *
+gst_encoding_audio_profile_new (GstCaps * format, const gchar * preset,
+    GstCaps * restriction, guint presence)
+{
+  return (GstEncodingAudioProfile *)
+      common_creation (GST_TYPE_ENCODING_AUDIO_PROFILE, format, preset, NULL,
+      NULL, restriction, presence);
+}
+
+
+/**
+ * gst_encoding_profile_is_equal:
+ * @a: a #GstEncodingProfile
+ * @b: a #GstEncodingProfile
+ *
+ * Checks whether the two #GstEncodingProfile are equal
+ *
+ * Since: 0.10.32
+ *
+ * Returns: %TRUE if @a and @b are equal, else %FALSE.
+ */
+gboolean
+gst_encoding_profile_is_equal (GstEncodingProfile * a, GstEncodingProfile * b)
+{
+  return (_compare_encoding_profiles (a, b) == 0);
+}
+
+
+/**
+ * gst_encoding_profile_get_input_caps:
+ * @profile: a #GstEncodingProfile
+ *
+ * Computes the full output caps that this @profile will be able to consume.
+ *
+ * Since: 0.10.32
+ *
+ * Returns: The full caps the given @profile can consume. Call gst_caps_unref()
+ * when you are done with the caps.
+ */
+GstCaps *
+gst_encoding_profile_get_input_caps (GstEncodingProfile * profile)
+{
+  GstCaps *out, *tmp;
+  GList *ltmp;
+  GstStructure *st, *outst;
+  GQuark out_name;
+  guint i, len;
+  const GstCaps *fcaps;
+
+  if (GST_IS_ENCODING_CONTAINER_PROFILE (profile)) {
+    GstCaps *res = gst_caps_new_empty ();
+
+    for (ltmp = GST_ENCODING_CONTAINER_PROFILE (profile)->encodingprofiles;
+        ltmp; ltmp = ltmp->next) {
+      GstEncodingProfile *sprof = (GstEncodingProfile *) ltmp->data;
+      gst_caps_merge (res, gst_encoding_profile_get_input_caps (sprof));
+    }
+    return res;
+  }
+
+  fcaps = profile->format;
+
+  /* fast-path */
+  if ((profile->restriction == NULL) || gst_caps_is_any (profile->restriction))
+    return gst_caps_copy (fcaps);
+
+  /* Combine the format with the restriction caps */
+  outst = gst_caps_get_structure (fcaps, 0);
+  out_name = gst_structure_get_name_id (outst);
+  tmp = gst_caps_new_empty ();
+  len = gst_caps_get_size (profile->restriction);
+
+  for (i = 0; i < len; i++) {
+    st = gst_structure_copy (gst_caps_get_structure (profile->restriction, i));
+    st->name = out_name;
+    gst_caps_append_structure (tmp, st);
+  }
+
+  out = gst_caps_intersect (tmp, fcaps);
+  gst_caps_unref (tmp);
+
+  return out;
+}
+
+/**
+ * gst_encoding_profile_get_type_nick:
+ * @profile: a #GstEncodingProfile
+ *
+ * Since: 0.10.32
+ *
+ * Returns: the human-readable name of the type of @profile.
+ */
+const gchar *
+gst_encoding_profile_get_type_nick (GstEncodingProfile * profile)
+{
+  if (GST_IS_ENCODING_CONTAINER_PROFILE (profile))
+    return "container";
+  if (GST_IS_ENCODING_VIDEO_PROFILE (profile))
+    return "video";
+  if (GST_IS_ENCODING_AUDIO_PROFILE (profile))
+    return "audio";
+  return NULL;
+}
+
+/**
+ * gst_encoding_profile_find:
+ * @targetname: (transfer none): The name of the target
+ * @profilename: (transfer none): The name of the profile
+ * @category: (transfer none) (allow-none): The target category. Can be %NULL
+ *
+ * Find the #GstEncodingProfile with the specified name and category.
+ *
+ * Returns: (transfer full): The matching #GstEncodingProfile or %NULL.
+ *
+ * Since: 0.10.32
+ */
+GstEncodingProfile *
+gst_encoding_profile_find (const gchar * targetname, const gchar * profilename,
+    const gchar * category)
+{
+  GstEncodingProfile *res = NULL;
+  GstEncodingTarget *target;
+
+  g_return_val_if_fail (targetname != NULL, NULL);
+  g_return_val_if_fail (profilename != NULL, NULL);
+
+  /* FIXME : how do we handle profiles named the same in several
+   * categories but of which only one has the required profile ? */
+  target = gst_encoding_target_load (targetname, category, NULL);
+  if (target) {
+    res = gst_encoding_target_get_profile (target, profilename);
+    gst_encoding_target_unref (target);
+  }
+
+  return res;
+}
+
+static GstEncodingProfile *
+combo_search (const gchar * pname)
+{
+  GstEncodingProfile *res;
+  gchar **split;
+
+  /* Splitup */
+  split = g_strsplit (pname, "/", 2);
+  if (g_strv_length (split) != 2)
+    return NULL;
+
+  res = gst_encoding_profile_find (split[0], split[1], NULL);
+
+  g_strfreev (split);
+
+  return res;
+}
+
+/* GValue transform function */
+static void
+string_to_profile_transform (const GValue * src_value, GValue * dest_value)
+{
+  const gchar *profilename;
+  GstEncodingProfile *profile;
+
+  profilename = g_value_get_string (src_value);
+
+  profile = combo_search (profilename);
+
+  if (profile)
+    gst_value_take_mini_object (dest_value, (GstMiniObject *) profile);
+}
+
+static gboolean
+gst_encoding_profile_deserialize_valfunc (GValue * value, const gchar * s)
+{
+  GstEncodingProfile *profile;
+
+  profile = combo_search (s);
+
+  if (profile) {
+    gst_value_take_mini_object (value, (GstMiniObject *) profile);
+    return TRUE;
+  }
+
+  return FALSE;
+}
diff --git a/gst-libs/gst/pbutils/encoding-profile.h b/gst-libs/gst/pbutils/encoding-profile.h
new file mode 100644
index 0000000..86becca
--- /dev/null
+++ b/gst-libs/gst/pbutils/encoding-profile.h
@@ -0,0 +1,187 @@
+/* GStreamer encoding profiles library
+ * Copyright (C) 2009-2010 Edward Hervey <edward.hervey@collabora.co.uk>
+ *           (C) 2009-2010 Nokia Corporation
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_PROFILE_H__
+#define __GST_PROFILE_H__
+
+#include <gst/gst.h>
+
+G_BEGIN_DECLS
+
+#include <gst/pbutils/pbutils-enumtypes.h>
+
+/**
+ * GstEncodingProfile:
+ *
+ * The opaque base class object for all encoding profiles. This contains generic
+ * information like name, description, format and preset.
+ *
+ * Since: 0.10.32
+ */
+
+#define GST_TYPE_ENCODING_PROFILE			\
+  (gst_encoding_profile_get_type ())
+#define GST_ENCODING_PROFILE(obj)			\
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ENCODING_PROFILE, GstEncodingProfile))
+#define GST_IS_ENCODING_PROFILE(obj)			\
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ENCODING_PROFILE))
+typedef struct _GstEncodingProfile GstEncodingProfile;
+typedef GstMiniObjectClass GstEncodingProfileClass;
+GType gst_encoding_profile_get_type (void);
+
+
+
+/**
+ * GstEncodingContainerProfile:
+ *
+ * Encoding profiles for containers. Keeps track of a list of #GstEncodingProfile
+ *
+ * Since: 0.10.32
+ */
+#define GST_TYPE_ENCODING_CONTAINER_PROFILE			\
+  (gst_encoding_container_profile_get_type ())
+#define GST_ENCODING_CONTAINER_PROFILE(obj)			\
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ENCODING_CONTAINER_PROFILE, GstEncodingContainerProfile))
+#define GST_IS_ENCODING_CONTAINER_PROFILE(obj)			\
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ENCODING_CONTAINER_PROFILE))
+typedef struct _GstEncodingContainerProfile GstEncodingContainerProfile;
+typedef GstEncodingProfileClass GstEncodingContainerProfileClass;
+GType gst_encoding_container_profile_get_type (void);
+
+
+
+/**
+ * GstEncodingVideoProfile:
+ *
+ * Variant of #GstEncodingProfile for video streams, allows specifying the @pass.
+ *
+ * Since: 0.10.32
+ */
+#define GST_TYPE_ENCODING_VIDEO_PROFILE			\
+  (gst_encoding_video_profile_get_type ())
+#define GST_ENCODING_VIDEO_PROFILE(obj)			\
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ENCODING_VIDEO_PROFILE, GstEncodingVideoProfile))
+#define GST_IS_ENCODING_VIDEO_PROFILE(obj)			\
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ENCODING_VIDEO_PROFILE))
+typedef struct _GstEncodingVideoProfile GstEncodingVideoProfile;
+typedef GstEncodingProfileClass GstEncodingVideoProfileClass;
+GType gst_encoding_video_profile_get_type (void);
+
+
+
+/**
+ * GstEncodingAudioProfile:
+ *
+ * Variant of #GstEncodingProfile for audio streams.
+ *
+ * Since: 0.10.32
+ */
+#define GST_TYPE_ENCODING_AUDIO_PROFILE			\
+  (gst_encoding_audio_profile_get_type ())
+#define GST_ENCODING_AUDIO_PROFILE(obj)			\
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ENCODING_AUDIO_PROFILE, GstEncodingAudioProfile))
+#define GST_IS_ENCODING_AUDIO_PROFILE(obj)			\
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ENCODING_AUDIO_PROFILE))
+typedef struct _GstEncodingAudioProfile GstEncodingAudioProfile;
+typedef GstEncodingProfileClass GstEncodingAudioProfileClass;
+GType gst_encoding_audio_profile_get_type (void);
+
+
+
+/* GstEncodingProfile API */
+
+/**
+ * gst_encoding_profile_unref:
+ * @profile: a #GstEncodingProfile
+ *
+ * Decreases the reference count of the @profile, possibly freeing the @profile.
+ *
+ * Since: 0.10.32
+ */
+#define gst_encoding_profile_unref(profile) (gst_mini_object_unref ((GstMiniObject*) profile))
+
+/**
+ * gst_encoding_profile_ref:
+ * @profile: a #GstEncodingProfile
+ *
+ * Increases the reference count of the @profile.
+ *
+ * Since: 0.10.32
+ */
+#define gst_encoding_profile_ref(profile) (gst_mini_object_ref ((GstMiniObject*) profile))
+
+const gchar *	gst_encoding_profile_get_name(GstEncodingProfile *profile);
+const gchar *	gst_encoding_profile_get_description(GstEncodingProfile *profile);
+const GstCaps *	gst_encoding_profile_get_format(GstEncodingProfile *profile);
+const gchar *	gst_encoding_profile_get_preset(GstEncodingProfile *profile);
+guint	gst_encoding_profile_get_presence(GstEncodingProfile *profile);
+const GstCaps *	gst_encoding_profile_get_restriction(GstEncodingProfile *profile);
+
+void	gst_encoding_profile_set_name(GstEncodingProfile *profile, const gchar *name);
+void	gst_encoding_profile_set_description(GstEncodingProfile *profile, const gchar *description);
+void	gst_encoding_profile_set_format(GstEncodingProfile *profile, GstCaps *format);
+void	gst_encoding_profile_set_preset(GstEncodingProfile *profile, const gchar *preset);
+void	gst_encoding_profile_set_restriction(GstEncodingProfile *profile, GstCaps *restriction);
+void	gst_encoding_profile_set_presence(GstEncodingProfile *profile, guint presence);
+
+gboolean gst_encoding_profile_is_equal (GstEncodingProfile *a,
+					GstEncodingProfile *b);
+GstCaps * gst_encoding_profile_get_input_caps (GstEncodingProfile *profile);
+
+const gchar *gst_encoding_profile_get_type_nick (GstEncodingProfile *profile);
+
+GstEncodingProfile * gst_encoding_profile_find (const gchar *targetname,
+						const gchar *profilename,
+						const gchar *category);
+
+/* GstEncodingContainerProfile API */
+gboolean  gst_encoding_container_profile_add_profile       (GstEncodingContainerProfile *container,
+							    GstEncodingProfile *profile);
+gboolean  gst_encoding_container_profile_contains_profile  (GstEncodingContainerProfile * container,
+							    GstEncodingProfile *profile);
+const GList *gst_encoding_container_profile_get_profiles   (GstEncodingContainerProfile *profile);
+
+
+GstEncodingContainerProfile *  gst_encoding_container_profile_new (const gchar *name,
+								   const gchar *description,
+								   GstCaps *format,
+								   const gchar *preset);
+
+
+/* Invidual stream encodingprofile API */
+GstEncodingVideoProfile * gst_encoding_video_profile_new (GstCaps *format,
+							  const gchar *preset,
+							  GstCaps *restriction,
+							  guint presence);
+GstEncodingAudioProfile * gst_encoding_audio_profile_new (GstCaps *format,
+							  const gchar *preset,
+							  GstCaps *restriction,
+							  guint presence);
+
+guint    gst_encoding_video_profile_get_pass              (GstEncodingVideoProfile *prof);
+gboolean gst_encoding_video_profile_get_variableframerate (GstEncodingVideoProfile *prof);
+
+void     gst_encoding_video_profile_set_pass              (GstEncodingVideoProfile *prof,
+							   guint pass);
+void     gst_encoding_video_profile_set_variableframerate (GstEncodingVideoProfile *prof,
+							   gboolean variableframerate);
+G_END_DECLS
+
+#endif /* __GST_PROFILE_H__ */
diff --git a/gst-libs/gst/pbutils/encoding-target.c b/gst-libs/gst/pbutils/encoding-target.c
new file mode 100644
index 0000000..229dbf3
--- /dev/null
+++ b/gst-libs/gst/pbutils/encoding-target.c
@@ -0,0 +1,1204 @@
+/* GStreamer encoding profile registry
+ * Copyright (C) 2010 Edward Hervey <edward.hervey@collabora.co.uk>
+ *           (C) 2010 Nokia Corporation
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <locale.h>
+#include <string.h>
+#include "encoding-target.h"
+
+/*
+ * File format
+ *
+ * GKeyFile style.
+ *
+ * [GStreamer Encoding Target]
+ * name : <name>
+ * category : <category>
+ * description : <description> #translatable
+ *
+ * [profile-<profile1name>]
+ * name : <name>
+ * description : <description> #optional
+ * format : <format>
+ * preset : <preset>
+ *
+ * [streamprofile-<id>]
+ * parent : <encodingprofile.name>[,<encodingprofile.name>..]
+ * type : <type> # "audio", "video", "text"
+ * format : <format>
+ * preset : <preset>
+ * restriction : <restriction>
+ * presence : <presence>
+ * pass : <pass>
+ * variableframerate : <variableframerate>
+ *  */
+
+/*
+ * Location of profile files
+ *
+ * $GST_DATADIR/gstreamer-GST_MAJORMINOR/encoding-profile
+ * $HOME/gstreamer-GST_MAJORMINOR/encoding-profile
+ *
+ * Naming convention
+ *   $(target.category)/$(target.name).gep
+ *
+ * Naming restrictions:
+ *  lowercase ASCII letter for the first character
+ *  Same for all other characters + numerics + hyphens
+ */
+
+
+#define GST_ENCODING_TARGET_HEADER "GStreamer Encoding Target"
+#define GST_ENCODING_TARGET_DIRECTORY "encoding-profiles"
+#define GST_ENCODING_TARGET_SUFFIX ".gep"
+
+struct _GstEncodingTarget
+{
+  GstMiniObject parent;
+
+  gchar *name;
+  gchar *category;
+  gchar *description;
+  GList *profiles;
+
+  /*< private > */
+  gchar *keyfile;
+};
+
+G_DEFINE_TYPE (GstEncodingTarget, gst_encoding_target, GST_TYPE_MINI_OBJECT);
+
+static void
+gst_encoding_target_init (GstEncodingTarget * target)
+{
+  /* Nothing to initialize */
+}
+
+static void
+gst_encoding_target_finalize (GstEncodingTarget * target)
+{
+  GST_DEBUG ("Finalizing");
+
+  if (target->name)
+    g_free (target->name);
+  if (target->category)
+    g_free (target->category);
+  if (target->description)
+    g_free (target->description);
+
+  g_list_foreach (target->profiles, (GFunc) gst_mini_object_unref, NULL);
+  g_list_free (target->profiles);
+}
+
+static void
+gst_encoding_target_class_init (GstMiniObjectClass * klass)
+{
+  klass->finalize =
+      (GstMiniObjectFinalizeFunction) gst_encoding_target_finalize;
+}
+
+/**
+ * gst_encoding_target_get_name:
+ * @target: a #GstEncodingTarget
+ *
+ * Since: 0.10.32
+ *
+ * Returns: (transfer none): The name of the @target.
+ */
+const gchar *
+gst_encoding_target_get_name (GstEncodingTarget * target)
+{
+  return target->name;
+}
+
+/**
+ * gst_encoding_target_get_category:
+ * @target: a #GstEncodingTarget
+ *
+ * Since: 0.10.32
+ *
+ * Returns: (transfer none): The category of the @target. For example:
+ * #GST_ENCODING_CATEGORY_DEVICE.
+ */
+const gchar *
+gst_encoding_target_get_category (GstEncodingTarget * target)
+{
+  return target->category;
+}
+
+/**
+ * gst_encoding_target_get_description:
+ * @target: a #GstEncodingTarget
+ *
+ * Since: 0.10.32
+ *
+ * Returns: (transfer none): The description of the @target.
+ */
+const gchar *
+gst_encoding_target_get_description (GstEncodingTarget * target)
+{
+  return target->description;
+}
+
+/**
+ * gst_encoding_target_get_profiles:
+ * @target: a #GstEncodingTarget
+ *
+ * Since: 0.10.32
+ *
+ * Returns: (transfer none) (element-type Gst.EncodingProfile): A list of
+ * #GstEncodingProfile(s) this @target handles.
+ */
+const GList *
+gst_encoding_target_get_profiles (GstEncodingTarget * target)
+{
+  return target->profiles;
+}
+
+/**
+ * gst_encoding_target_get_profile:
+ * @target: a #GstEncodingTarget
+ * @name: the name of the profile to retrieve
+ *
+ * Since: 0.10.32
+ *
+ * Returns: (transfer full): The matching #GstEncodingProfile, or %NULL.
+ */
+GstEncodingProfile *
+gst_encoding_target_get_profile (GstEncodingTarget * target, const gchar * name)
+{
+  GList *tmp;
+
+  g_return_val_if_fail (GST_IS_ENCODING_TARGET (target), NULL);
+  g_return_val_if_fail (name != NULL, NULL);
+
+  for (tmp = target->profiles; tmp; tmp = tmp->next) {
+    GstEncodingProfile *tprof = (GstEncodingProfile *) tmp->data;
+
+    if (!g_strcmp0 (gst_encoding_profile_get_name (tprof), name)) {
+      gst_encoding_profile_ref (tprof);
+      return tprof;
+    }
+  }
+
+  return NULL;
+}
+
+static inline gboolean
+validate_name (const gchar * name)
+{
+  guint i, len;
+
+  len = strlen (name);
+  if (len == 0)
+    return FALSE;
+
+  /* First character can only be a lower case ASCII character */
+  if (!g_ascii_isalpha (name[0]) || !g_ascii_islower (name[0]))
+    return FALSE;
+
+  /* All following characters can only by:
+   * either a lower case ASCII character
+   * or an hyphen
+   * or a numeric */
+  for (i = 1; i < len; i++) {
+    /* if uppercase ASCII letter, return */
+    if (g_ascii_isupper (name[i]))
+      return FALSE;
+    /* if a digit, continue */
+    if (g_ascii_isdigit (name[i]))
+      continue;
+    /* if an hyphen, continue */
+    if (name[i] == '-')
+      continue;
+    /* remaining should only be ascii letters */
+    if (!g_ascii_isalpha (name[i]))
+      return FALSE;
+  }
+
+  return TRUE;
+}
+
+/**
+ * gst_encoding_target_new:
+ * @name: The name of the target.
+ * @category: (transfer none): The name of the category to which this @target
+ * belongs. For example: #GST_ENCODING_CATEGORY_DEVICE.
+ * @description: (transfer none): A description of #GstEncodingTarget in the
+ * current locale.
+ * @profiles: (transfer none) (element-type Gst.EncodingProfile): A #GList of
+ * #GstEncodingProfile.
+ *
+ * Creates a new #GstEncodingTarget.
+ *
+ * The name and category can only consist of lowercase ASCII letters for the
+ * first character, followed by either lowercase ASCII letters, digits or
+ * hyphens ('-').
+ *
+ * The @category <emphasis>should</emphasis> be one of the existing
+ * well-defined categories, like #GST_ENCODING_CATEGORY_DEVICE, but it
+ * <emphasis>can</emphasis> be a application or user specific category if
+ * needed.
+ *
+ * Since: 0.10.32
+ *
+ * Returns: (transfer full): The newly created #GstEncodingTarget or %NULL if
+ * there was an error.
+ */
+
+GstEncodingTarget *
+gst_encoding_target_new (const gchar * name, const gchar * category,
+    const gchar * description, const GList * profiles)
+{
+  GstEncodingTarget *res;
+
+  g_return_val_if_fail (name != NULL, NULL);
+  g_return_val_if_fail (category != NULL, NULL);
+  g_return_val_if_fail (description != NULL, NULL);
+
+  /* Validate name */
+  if (!validate_name (name))
+    goto invalid_name;
+  if (!validate_name (category))
+    goto invalid_category;
+
+  res = (GstEncodingTarget *) gst_mini_object_new (GST_TYPE_ENCODING_TARGET);
+  res->name = g_strdup (name);
+  res->category = g_strdup (category);
+  res->description = g_strdup (description);
+
+  while (profiles) {
+    GstEncodingProfile *prof = (GstEncodingProfile *) profiles->data;
+
+    res->profiles =
+        g_list_append (res->profiles, gst_encoding_profile_ref (prof));
+    profiles = profiles->next;
+  }
+
+  return res;
+
+invalid_name:
+  {
+    GST_ERROR ("Invalid name for encoding target : '%s'", name);
+    return NULL;
+  }
+
+invalid_category:
+  {
+    GST_ERROR ("Invalid name for encoding category : '%s'", category);
+    return NULL;
+  }
+}
+
+/**
+ * gst_encoding_target_add_profile:
+ * @target: the #GstEncodingTarget to add a profile to
+ * @profile: (transfer full): the #GstEncodingProfile to add
+ *
+ * Adds the given @profile to the @target. Each added profile must have
+ * a unique name within the profile.
+ *
+ * The @target will steal a reference to the @profile. If you wish to use
+ * the profile after calling this method, you should increase its reference
+ * count.
+ *
+ * Since: 0.10.32
+ *
+ * Returns: %TRUE if the profile was added, else %FALSE.
+ **/
+
+gboolean
+gst_encoding_target_add_profile (GstEncodingTarget * target,
+    GstEncodingProfile * profile)
+{
+  GList *tmp;
+
+  g_return_val_if_fail (GST_IS_ENCODING_TARGET (target), FALSE);
+  g_return_val_if_fail (GST_IS_ENCODING_PROFILE (profile), FALSE);
+
+  /* Make sure profile isn't already controlled by this target */
+  for (tmp = target->profiles; tmp; tmp = tmp->next) {
+    GstEncodingProfile *prof = (GstEncodingProfile *) tmp->data;
+
+    if (!g_strcmp0 (gst_encoding_profile_get_name (profile),
+            gst_encoding_profile_get_name (prof))) {
+      GST_WARNING ("Profile already present in target");
+      return FALSE;
+    }
+  }
+
+  target->profiles = g_list_append (target->profiles, profile);
+
+  return TRUE;
+}
+
+static gboolean
+serialize_stream_profiles (GKeyFile * out, GstEncodingProfile * sprof,
+    const gchar * profilename, guint id)
+{
+  gchar *sprofgroupname;
+  gchar *tmpc;
+  const GstCaps *format, *restriction;
+  const gchar *preset, *name, *description;
+
+  sprofgroupname = g_strdup_printf ("streamprofile-%s-%d", profilename, id);
+
+  /* Write the parent profile */
+  g_key_file_set_value (out, sprofgroupname, "parent", profilename);
+
+  g_key_file_set_value (out, sprofgroupname, "type",
+      gst_encoding_profile_get_type_nick (sprof));
+
+  format = gst_encoding_profile_get_format (sprof);
+  if (format) {
+    tmpc = gst_caps_to_string (format);
+    g_key_file_set_value (out, sprofgroupname, "format", tmpc);
+    g_free (tmpc);
+  }
+
+  name = gst_encoding_profile_get_name (sprof);
+  if (name)
+    g_key_file_set_string (out, sprofgroupname, "name", name);
+
+  description = gst_encoding_profile_get_description (sprof);
+  if (description)
+    g_key_file_set_string (out, sprofgroupname, "description", description);
+
+  preset = gst_encoding_profile_get_preset (sprof);
+  if (preset)
+    g_key_file_set_string (out, sprofgroupname, "preset", preset);
+
+  restriction = gst_encoding_profile_get_restriction (sprof);
+  if (restriction) {
+    tmpc = gst_caps_to_string (restriction);
+    g_key_file_set_value (out, sprofgroupname, "restriction", tmpc);
+    g_free (tmpc);
+  }
+  g_key_file_set_integer (out, sprofgroupname, "presence",
+      gst_encoding_profile_get_presence (sprof));
+
+  if (GST_IS_ENCODING_VIDEO_PROFILE (sprof)) {
+    GstEncodingVideoProfile *vp = (GstEncodingVideoProfile *) sprof;
+
+    g_key_file_set_integer (out, sprofgroupname, "pass",
+        gst_encoding_video_profile_get_pass (vp));
+    g_key_file_set_boolean (out, sprofgroupname, "variableframerate",
+        gst_encoding_video_profile_get_variableframerate (vp));
+  }
+
+  g_free (sprofgroupname);
+  return TRUE;
+}
+
+static gchar *
+get_locale (void)
+{
+  const char *loc = NULL;
+  gchar *ret;
+
+#ifdef ENABLE_NLS
+#if defined(LC_MESSAGES)
+  loc = setlocale (LC_MESSAGES, NULL);
+//  GST_LOG ("LC_MESSAGES: %s", GST_STR_NULL (loc));
+#elif defined(LC_ALL)
+  loc = setlocale (LC_ALL, NULL);
+  GST_LOG ("LC_ALL: %s", GST_STR_NULL (loc));
+#else
+  GST_LOG ("Neither LC_ALL nor LC_MESSAGES defined");
+#endif
+#else /* !ENABLE_NLS */
+  GST_LOG ("i18n disabled");
+#endif
+
+  if (loc == NULL || g_ascii_strncasecmp (loc, "en", 2) == 0)
+    return NULL;
+
+  /* en_GB.UTF-8 => en */
+  ret = g_ascii_strdown (loc, -1);
+  ret = g_strcanon (ret, "abcdefghijklmnopqrstuvwxyz", '\0');
+  GST_LOG ("using locale: %s", ret);
+  return ret;
+}
+
+/* Serialize the top-level profiles
+ * Note: They don't have to be containerprofiles */
+static gboolean
+serialize_encoding_profile (GKeyFile * out, GstEncodingProfile * prof)
+{
+  gchar *profgroupname;
+  const GList *tmp;
+  guint i;
+  const gchar *profname, *profdesc, *profpreset, *proftype;
+  const GstCaps *profformat, *profrestriction;
+
+  profname = gst_encoding_profile_get_name (prof);
+  profdesc = gst_encoding_profile_get_description (prof);
+  profformat = gst_encoding_profile_get_format (prof);
+  profpreset = gst_encoding_profile_get_preset (prof);
+  proftype = gst_encoding_profile_get_type_nick (prof);
+  profrestriction = gst_encoding_profile_get_restriction (prof);
+
+  profgroupname = g_strdup_printf ("profile-%s", profname);
+
+  g_key_file_set_string (out, profgroupname, "name", profname);
+
+  g_key_file_set_value (out, profgroupname, "type",
+      gst_encoding_profile_get_type_nick (prof));
+
+  if (profdesc) {
+    gchar *locale;
+
+    locale = get_locale ();
+    if (locale != NULL) {
+      g_key_file_set_locale_string (out, profgroupname, "description",
+          locale, profdesc);
+      g_free (locale);
+    } else {
+      g_key_file_set_string (out, profgroupname, "description", profdesc);
+    }
+  }
+  if (profformat) {
+    gchar *tmpc = gst_caps_to_string (profformat);
+    g_key_file_set_string (out, profgroupname, "format", tmpc);
+    g_free (tmpc);
+  }
+  if (profpreset)
+    g_key_file_set_string (out, profgroupname, "preset", profpreset);
+
+  /* stream profiles */
+  if (GST_IS_ENCODING_CONTAINER_PROFILE (prof)) {
+    for (tmp =
+        gst_encoding_container_profile_get_profiles
+        (GST_ENCODING_CONTAINER_PROFILE (prof)), i = 0; tmp;
+        tmp = tmp->next, i++) {
+      GstEncodingProfile *sprof = (GstEncodingProfile *) tmp->data;
+
+      if (!serialize_stream_profiles (out, sprof, profname, i))
+        return FALSE;
+    }
+  }
+  g_free (profgroupname);
+  return TRUE;
+}
+
+static gboolean
+serialize_target (GKeyFile * out, GstEncodingTarget * target)
+{
+  GList *tmp;
+
+  g_key_file_set_string (out, GST_ENCODING_TARGET_HEADER, "name", target->name);
+  g_key_file_set_string (out, GST_ENCODING_TARGET_HEADER, "category",
+      target->category);
+  g_key_file_set_string (out, GST_ENCODING_TARGET_HEADER, "description",
+      target->description);
+
+  for (tmp = target->profiles; tmp; tmp = tmp->next) {
+    GstEncodingProfile *prof = (GstEncodingProfile *) tmp->data;
+    if (!serialize_encoding_profile (out, prof))
+      return FALSE;
+  }
+
+  return TRUE;
+}
+
+/**
+ * parse_encoding_profile:
+ * @in: a #GKeyFile
+ * @parentprofilename: the parent profile name (including 'profile-' or 'streamprofile-' header)
+ * @profilename: the profile name group to parse
+ * @nbgroups: the number of top-level groups
+ * @groups: the top-level groups
+ */
+static GstEncodingProfile *
+parse_encoding_profile (GKeyFile * in, gchar * parentprofilename,
+    gchar * profilename, gsize nbgroups, gchar ** groups)
+{
+  GstEncodingProfile *sprof = NULL;
+  gchar **parent;
+  gchar *proftype, *format, *preset, *restriction, *pname, *description;
+  GstCaps *formatcaps = NULL;
+  GstCaps *restrictioncaps = NULL;
+  gboolean variableframerate;
+  gint pass, presence;
+  gsize i, nbencprofiles;
+
+  GST_DEBUG ("parentprofilename : %s , profilename : %s",
+      parentprofilename, profilename);
+
+  if (parentprofilename) {
+    gboolean found = FALSE;
+
+    parent =
+        g_key_file_get_string_list (in, profilename, "parent",
+        &nbencprofiles, NULL);
+    if (!parent || !nbencprofiles) {
+      return NULL;
+    }
+
+    /* Check if this streamprofile is used in <profilename> */
+    for (i = 0; i < nbencprofiles; i++) {
+      if (!g_strcmp0 (parent[i], parentprofilename)) {
+        found = TRUE;
+        break;
+      }
+    }
+    g_strfreev (parent);
+
+    if (!found) {
+      GST_DEBUG ("Stream profile '%s' isn't used in profile '%s'",
+          profilename, parentprofilename);
+      return NULL;
+    }
+  }
+
+  pname = g_key_file_get_value (in, profilename, "name", NULL);
+
+  /* First try to get localized description */
+  {
+    gchar *locale;
+
+    locale = get_locale ();
+    if (locale != NULL) {
+      /* will try to fall back to untranslated string if no translation found */
+      description = g_key_file_get_locale_string (in, profilename,
+          "description", locale, NULL);
+      g_free (locale);
+    } else {
+      description =
+          g_key_file_get_string (in, profilename, "description", NULL);
+    }
+  }
+
+  /* Note: a missing description is normal for non-container profiles */
+  if (description == NULL) {
+    GST_LOG ("Missing 'description' field for streamprofile %s", profilename);
+  }
+
+  /* Parse the remaining fields */
+  proftype = g_key_file_get_value (in, profilename, "type", NULL);
+  if (!proftype) {
+    GST_WARNING ("Missing 'type' field for streamprofile %s", profilename);
+    return NULL;
+  }
+
+  format = g_key_file_get_value (in, profilename, "format", NULL);
+  if (format) {
+    formatcaps = gst_caps_from_string (format);
+    g_free (format);
+  }
+
+  preset = g_key_file_get_value (in, profilename, "preset", NULL);
+
+  restriction = g_key_file_get_value (in, profilename, "restriction", NULL);
+  if (restriction) {
+    restrictioncaps = gst_caps_from_string (restriction);
+    g_free (restriction);
+  }
+
+  presence = g_key_file_get_integer (in, profilename, "presence", NULL);
+  pass = g_key_file_get_integer (in, profilename, "pass", NULL);
+  variableframerate =
+      g_key_file_get_boolean (in, profilename, "variableframerate", NULL);
+
+  /* Build the streamprofile ! */
+  if (!g_strcmp0 (proftype, "container")) {
+    GstEncodingProfile *pprof;
+
+    sprof =
+        (GstEncodingProfile *) gst_encoding_container_profile_new (pname,
+        description, formatcaps, preset);
+    /* Now look for the stream profiles */
+    for (i = 0; i < nbgroups; i++) {
+      if (!g_ascii_strncasecmp (groups[i], "streamprofile-", 13)) {
+        pprof = parse_encoding_profile (in, pname, groups[i], nbgroups, groups);
+        if (pprof) {
+          gst_encoding_container_profile_add_profile (
+              (GstEncodingContainerProfile *) sprof, pprof);
+        }
+      }
+    }
+  } else if (!g_strcmp0 (proftype, "video")) {
+    sprof =
+        (GstEncodingProfile *) gst_encoding_video_profile_new (formatcaps,
+        preset, restrictioncaps, presence);
+    gst_encoding_video_profile_set_variableframerate ((GstEncodingVideoProfile
+            *) sprof, variableframerate);
+    gst_encoding_video_profile_set_pass ((GstEncodingVideoProfile *) sprof,
+        pass);
+  } else if (!g_strcmp0 (proftype, "audio")) {
+    sprof =
+        (GstEncodingProfile *) gst_encoding_audio_profile_new (formatcaps,
+        preset, restrictioncaps, presence);
+  } else
+    GST_ERROR ("Unknown profile format '%s'", proftype);
+
+  if (restrictioncaps)
+    gst_caps_unref (restrictioncaps);
+  if (formatcaps)
+    gst_caps_unref (formatcaps);
+
+  if (pname)
+    g_free (pname);
+  if (description)
+    g_free (description);
+  if (preset)
+    g_free (preset);
+  if (proftype)
+    g_free (proftype);
+
+  return sprof;
+}
+
+static GstEncodingTarget *
+parse_keyfile (GKeyFile * in, gchar * targetname, gchar * categoryname,
+    gchar * description)
+{
+  GstEncodingTarget *res = NULL;
+  GstEncodingProfile *prof;
+  gchar **groups;
+  gsize i, nbgroups;
+
+  res = gst_encoding_target_new (targetname, categoryname, description, NULL);
+
+  /* Figure out the various profiles */
+  groups = g_key_file_get_groups (in, &nbgroups);
+  for (i = 0; i < nbgroups; i++) {
+    if (!g_ascii_strncasecmp (groups[i], "profile-", 8)) {
+      prof = parse_encoding_profile (in, NULL, groups[i], nbgroups, groups);
+      if (prof)
+        gst_encoding_target_add_profile (res, prof);
+    }
+  }
+
+  g_strfreev (groups);
+
+  if (targetname)
+    g_free (targetname);
+  if (categoryname)
+    g_free (categoryname);
+  if (description)
+    g_free (description);
+
+  return res;
+}
+
+static GKeyFile *
+load_file_and_read_header (const gchar * path, gchar ** targetname,
+    gchar ** categoryname, gchar ** description, GError ** error)
+{
+  GKeyFile *in;
+  gboolean res;
+  GError *key_error = NULL;
+
+  g_return_val_if_fail (error == NULL || *error == NULL, NULL);
+
+  in = g_key_file_new ();
+
+  GST_DEBUG ("path:%s", path);
+
+  res =
+      g_key_file_load_from_file (in, path,
+      G_KEY_FILE_KEEP_COMMENTS | G_KEY_FILE_KEEP_TRANSLATIONS, &key_error);
+  if (!res || key_error != NULL)
+    goto load_error;
+
+  key_error = NULL;
+  *targetname =
+      g_key_file_get_value (in, GST_ENCODING_TARGET_HEADER, "name", &key_error);
+  if (!*targetname)
+    goto empty_name;
+
+  *categoryname =
+      g_key_file_get_value (in, GST_ENCODING_TARGET_HEADER, "category", NULL);
+  *description =
+      g_key_file_get_value (in, GST_ENCODING_TARGET_HEADER, "description",
+      NULL);
+
+  return in;
+
+load_error:
+  {
+    GST_WARNING ("Unable to read GstEncodingTarget file %s: %s",
+        path, key_error->message);
+    g_propagate_error (error, key_error);
+    g_key_file_free (in);
+    return NULL;
+  }
+
+empty_name:
+  {
+    GST_WARNING ("Wrong header in file %s: %s", path, key_error->message);
+    g_propagate_error (error, key_error);
+    g_key_file_free (in);
+    return NULL;
+  }
+}
+
+/**
+ * gst_encoding_target_load_from_file:
+ * @filepath: The file location to load the #GstEncodingTarget from
+ * @error: If an error occured, this field will be filled in.
+ *
+ * Opens the provided file and returns the contained #GstEncodingTarget.
+ *
+ * Since: 0.10.32
+ *
+ * Returns: (transfer full): The #GstEncodingTarget contained in the file, else
+ * %NULL
+ */
+
+GstEncodingTarget *
+gst_encoding_target_load_from_file (const gchar * filepath, GError ** error)
+{
+  GKeyFile *in;
+  gchar *targetname, *categoryname, *description;
+  GstEncodingTarget *res = NULL;
+
+  in = load_file_and_read_header (filepath, &targetname, &categoryname,
+      &description, error);
+  if (!in)
+    goto beach;
+
+  res = parse_keyfile (in, targetname, categoryname, description);
+
+  g_key_file_free (in);
+
+beach:
+  return res;
+}
+
+/*
+ * returned list contents must be freed
+ */
+static GList *
+get_matching_filenames (gchar * path, gchar * filename)
+{
+  GList *res = NULL;
+  GDir *topdir;
+  const gchar *subdirname;
+
+  topdir = g_dir_open (path, 0, NULL);
+  if (G_UNLIKELY (topdir == NULL))
+    return NULL;
+
+  while ((subdirname = g_dir_read_name (topdir))) {
+    gchar *ltmp = g_build_filename (path, subdirname, NULL);
+
+    if (g_file_test (ltmp, G_FILE_TEST_IS_DIR)) {
+      gchar *tmp = g_build_filename (path, subdirname, filename, NULL);
+      /* Test to see if we have a file named like that in that directory */
+      if (g_file_test (tmp, G_FILE_TEST_EXISTS))
+        res = g_list_append (res, tmp);
+      else
+        g_free (tmp);
+    }
+    g_free (ltmp);
+  }
+
+  g_dir_close (topdir);
+
+  return res;
+}
+
+static GstEncodingTarget *
+gst_encoding_target_subload (gchar * path, const gchar * category,
+    gchar * lfilename, GError ** error)
+{
+  GstEncodingTarget *target = NULL;
+
+  if (category) {
+    gchar *filename;
+
+    filename = g_build_filename (path, category, lfilename, NULL);
+    target = gst_encoding_target_load_from_file (filename, error);
+    g_free (filename);
+  } else {
+    GList *tmp, *tries = get_matching_filenames (path, lfilename);
+
+    /* Try to find a file named %s.gstprofile in any subdirectories */
+    for (tmp = tries; tmp; tmp = tmp->next) {
+      target = gst_encoding_target_load_from_file ((gchar *) tmp->data, NULL);
+      if (target)
+        break;
+    }
+    g_list_foreach (tries, (GFunc) g_free, NULL);
+    if (tries)
+      g_list_free (tries);
+  }
+
+  return target;
+}
+
+/**
+ * gst_encoding_target_load:
+ * @name: the name of the #GstEncodingTarget to load.
+ * @category: (allow-none): the name of the target category, like
+ * #GST_ENCODING_CATEGORY_DEVICE. Can be %NULL
+ * @error: If an error occured, this field will be filled in.
+ *
+ * Searches for the #GstEncodingTarget with the given name, loads it
+ * and returns it.
+ *
+ * If the category name is specified only targets from that category will be
+ * searched for.
+ *
+ * Since: 0.10.32
+ *
+ * Returns: (transfer full): The #GstEncodingTarget if available, else %NULL.
+ */
+GstEncodingTarget *
+gst_encoding_target_load (const gchar * name, const gchar * category,
+    GError ** error)
+{
+  gchar *lfilename, *tldir;
+  GstEncodingTarget *target = NULL;
+
+  g_return_val_if_fail (name != NULL, NULL);
+
+  if (!validate_name (name))
+    goto invalid_name;
+
+  if (category && !validate_name (category))
+    goto invalid_category;
+
+  lfilename = g_strdup_printf ("%s" GST_ENCODING_TARGET_SUFFIX, name);
+
+  /* Try from local profiles */
+  tldir =
+      g_build_filename (g_get_home_dir (), ".gstreamer-" GST_MAJORMINOR,
+      GST_ENCODING_TARGET_DIRECTORY, NULL);
+  target = gst_encoding_target_subload (tldir, category, lfilename, error);
+  g_free (tldir);
+
+  if (target == NULL) {
+    /* Try from system-wide profiles */
+    tldir =
+        g_build_filename (GST_DATADIR, "gstreamer-" GST_MAJORMINOR,
+        GST_ENCODING_TARGET_DIRECTORY, NULL);
+    target = gst_encoding_target_subload (tldir, category, lfilename, error);
+    g_free (tldir);
+  }
+
+  g_free (lfilename);
+
+  return target;
+
+invalid_name:
+  {
+    GST_ERROR ("Invalid name for encoding target : '%s'", name);
+    return NULL;
+  }
+invalid_category:
+  {
+    GST_ERROR ("Invalid name for encoding category : '%s'", category);
+    return NULL;
+  }
+}
+
+/**
+ * gst_encoding_target_save_to_file:
+ * @target: a #GstEncodingTarget
+ * @filepath: the location to store the @target at.
+ * @error: If an error occured, this field will be filled in.
+ *
+ * Saves the @target to the provided file location.
+ *
+ * Since: 0.10.32
+ *
+ * Returns: %TRUE if the target was correctly saved, else %FALSE.
+ **/
+
+gboolean
+gst_encoding_target_save_to_file (GstEncodingTarget * target,
+    const gchar * filepath, GError ** error)
+{
+  GKeyFile *out;
+  gchar *data;
+  gsize data_size;
+
+  g_return_val_if_fail (GST_IS_ENCODING_TARGET (target), FALSE);
+  g_return_val_if_fail (filepath != NULL, FALSE);
+
+  /* FIXME : Check filepath is valid and writable
+   * FIXME : Strip out profiles already present in system target */
+
+  /* Get unique name... */
+
+  /* Create output GKeyFile */
+  out = g_key_file_new ();
+
+  if (!serialize_target (out, target))
+    goto serialize_failure;
+
+  if (!(data = g_key_file_to_data (out, &data_size, error)))
+    goto convert_failed;
+
+  if (!g_file_set_contents (filepath, data, data_size, error))
+    goto write_failed;
+
+  g_key_file_free (out);
+  g_free (data);
+
+  return TRUE;
+
+serialize_failure:
+  {
+    GST_ERROR ("Failure serializing target");
+    g_key_file_free (out);
+    return FALSE;
+  }
+
+convert_failed:
+  {
+    GST_ERROR ("Failure converting keyfile: %s", (*error)->message);
+    g_key_file_free (out);
+    g_free (data);
+    return FALSE;
+  }
+
+write_failed:
+  {
+    GST_ERROR ("Unable to write file %s: %s", filepath, (*error)->message);
+    g_key_file_free (out);
+    g_free (data);
+    return FALSE;
+  }
+}
+
+/**
+ * gst_encoding_target_save:
+ * @target: a #GstEncodingTarget
+ * @error: If an error occured, this field will be filled in.
+ *
+ * Saves the @target to a default user-local directory.
+ *
+ * Since: 0.10.32
+ *
+ * Returns: %TRUE if the target was correctly saved, else %FALSE.
+ **/
+
+gboolean
+gst_encoding_target_save (GstEncodingTarget * target, GError ** error)
+{
+  gchar *filename;
+  gchar *lfilename;
+  gboolean res;
+
+  g_return_val_if_fail (GST_IS_ENCODING_TARGET (target), FALSE);
+  g_return_val_if_fail (target->category != NULL, FALSE);
+
+  lfilename = g_strdup_printf ("%s" GST_ENCODING_TARGET_SUFFIX, target->name);
+  filename =
+      g_build_filename (g_get_home_dir (), ".gstreamer-" GST_MAJORMINOR,
+      GST_ENCODING_TARGET_DIRECTORY, target->category, lfilename, NULL);
+  g_free (lfilename);
+
+  res = gst_encoding_target_save_to_file (target, filename, error);
+  g_free (filename);
+
+  return TRUE;
+}
+
+static GList *
+get_categories (gchar * path)
+{
+  GList *res = NULL;
+  GDir *topdir;
+  const gchar *subdirname;
+
+  topdir = g_dir_open (path, 0, NULL);
+  if (G_UNLIKELY (topdir == NULL))
+    return NULL;
+
+  while ((subdirname = g_dir_read_name (topdir))) {
+    gchar *ltmp = g_build_filename (path, subdirname, NULL);
+
+    if (g_file_test (ltmp, G_FILE_TEST_IS_DIR)) {
+      res = g_list_append (res, (gpointer) g_strdup (subdirname));
+    }
+    g_free (ltmp);
+  }
+
+  g_dir_close (topdir);
+
+  return res;
+}
+
+/**
+ * gst_encoding_list_available_categories:
+ *
+ * Lists all #GstEncodingTarget categories present on disk.
+ *
+ * Returns: (transfer full) (element-type gchar*): A list
+ * of #GstEncodingTarget categories.
+ *
+ * Since: 0.10.32
+ */
+GList *
+gst_encoding_list_available_categories (void)
+{
+  GList *res = NULL;
+  GList *tmp1, *tmp2;
+  gchar *topdir;
+
+  /* First try user-local categories */
+  topdir = g_build_filename (g_get_home_dir (), ".gstreamer-" GST_MAJORMINOR,
+      GST_ENCODING_TARGET_DIRECTORY, NULL);
+  res = get_categories (topdir);
+  g_free (topdir);
+
+  /* Extend with system-wide categories */
+  topdir = g_build_filename (GST_DATADIR, "gstreamer-" GST_MAJORMINOR,
+      GST_ENCODING_TARGET_DIRECTORY, NULL);
+  tmp1 = get_categories (topdir);
+  g_free (topdir);
+
+  for (tmp2 = tmp1; tmp2; tmp2 = tmp2->next) {
+    gchar *name = (gchar *) tmp2->data;
+    if (!g_list_find_custom (res, name, (GCompareFunc) g_strcmp0))
+      res = g_list_append (res, (gpointer) name);
+    else
+      g_free (name);
+  }
+  g_free (tmp1);
+
+  return res;
+}
+
+static inline GList *
+sub_get_all_targets (gchar * subdir)
+{
+  GList *res = NULL;
+  const gchar *filename;
+  GDir *dir;
+  GstEncodingTarget *target;
+
+  dir = g_dir_open (subdir, 0, NULL);
+  if (G_UNLIKELY (dir == NULL))
+    return NULL;
+
+  while ((filename = g_dir_read_name (dir))) {
+    gchar *fullname;
+
+    /* Only try files ending with .gstprofile */
+    if (!g_str_has_suffix (filename, GST_ENCODING_TARGET_SUFFIX))
+      continue;
+
+    fullname = g_build_filename (subdir, filename, NULL);
+    target = gst_encoding_target_load_from_file (fullname, NULL);
+    if (target) {
+      res = g_list_append (res, target);
+    } else
+      GST_WARNING ("Failed to get a target from %s", fullname);
+    g_free (fullname);
+  }
+  g_dir_close (dir);
+
+  return res;
+}
+
+static inline GList *
+get_all_targets (gchar * topdir, const gchar * categoryname)
+{
+  GList *res = NULL;
+
+  if (categoryname) {
+    gchar *subdir = g_build_filename (topdir, categoryname, NULL);
+    /* Try to open the directory */
+    res = sub_get_all_targets (subdir);
+    g_free (subdir);
+  } else {
+    const gchar *subdirname;
+    GDir *dir = g_dir_open (topdir, 0, NULL);
+
+    if (G_UNLIKELY (dir == NULL))
+      return NULL;
+
+    while ((subdirname = g_dir_read_name (dir))) {
+      gchar *ltmp = g_build_filename (topdir, subdirname, NULL);
+
+      if (g_file_test (ltmp, G_FILE_TEST_IS_DIR)) {
+        res = g_list_concat (res, sub_get_all_targets (ltmp));
+      }
+      g_free (ltmp);
+    }
+    g_dir_close (dir);
+  }
+
+  return res;
+}
+
+static guint
+compare_targets (const GstEncodingTarget * ta, const GstEncodingTarget * tb)
+{
+  if (!g_strcmp0 (ta->name, tb->name)
+      && !g_strcmp0 (ta->category, tb->category))
+    return -1;
+
+  return 0;
+}
+
+/**
+ * gst_encoding_list_all_targets:
+ * @categoryname: (allow-none): The category, for ex: #GST_ENCODING_CATEGORY_DEVICE.
+ * Can be %NULL.
+ *
+ * List all available #GstEncodingTarget for the specified category, or all categories
+ * if @categoryname is %NULL.
+ *
+ * Returns: (transfer full) (element-type GstEncodingTarget): The list of #GstEncodingTarget
+ *
+ * Since: 0.10.32
+ */
+GList *
+gst_encoding_list_all_targets (const gchar * categoryname)
+{
+  GList *res;
+  GList *tmp1, *tmp2;
+  gchar *topdir;
+
+  /* Get user-locals */
+  topdir = g_build_filename (g_get_home_dir (), ".gstreamer-" GST_MAJORMINOR,
+      GST_ENCODING_TARGET_DIRECTORY, NULL);
+  res = get_all_targets (topdir, categoryname);
+  g_free (topdir);
+
+  /* Get system-wide */
+  topdir = g_build_filename (GST_DATADIR, "gstreamer-" GST_MAJORMINOR,
+      GST_ENCODING_TARGET_DIRECTORY, NULL);
+  tmp1 = get_all_targets (topdir, categoryname);
+  g_free (topdir);
+
+  /* Merge system-wide targets */
+  /* FIXME : We should merge the system-wide profiles into the user-locals
+   * instead of stopping at identical target names */
+  for (tmp2 = tmp1; tmp2; tmp2 = tmp2->next) {
+    GstEncodingTarget *target = (GstEncodingTarget *) tmp2->data;
+    if (g_list_find_custom (res, target, (GCompareFunc) compare_targets))
+      gst_encoding_target_unref (target);
+    else
+      res = g_list_append (res, target);
+  }
+  g_list_free (tmp1);
+
+  return res;
+}
diff --git a/gst-libs/gst/pbutils/encoding-target.h b/gst-libs/gst/pbutils/encoding-target.h
new file mode 100644
index 0000000..70c049d
--- /dev/null
+++ b/gst-libs/gst/pbutils/encoding-target.h
@@ -0,0 +1,147 @@
+/* GStreamer encoding profile registry
+ * Copyright (C) 2010 Edward Hervey <edward.hervey@collabora.co.uk>
+ *           (C) 2010 Nokia Corporation
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_PROFILE_REGISTRY_H__
+#define __GST_PROFILE_REGISTRY_H__
+
+#include <gst/pbutils/encoding-profile.h>
+
+G_BEGIN_DECLS
+
+
+/* FIXME/UNKNOWNS
+ *
+ * Should encoding categories be well-known strings/quarks ?
+ *
+ */
+
+/**
+ * GST_ENCODING_CATEGORY_DEVICE:
+ *
+ * #GstEncodingTarget category for device-specific targets.
+ * The name of the target will usually be the contructor and model of the device,
+ * and that target will contain #GstEncodingProfiles suitable for that device.
+ */
+#define GST_ENCODING_CATEGORY_DEVICE		"device"
+
+/**
+ * GST_ENCODING_CATEGORY_ONLINE_SERVICE:
+ *
+ * #GstEncodingTarget category for online-services.
+ * The name of the target will usually be the name of the online service
+ * and that target will contain #GstEncodingProfiles suitable for that online
+ * service.
+ */
+
+#define GST_ENCODING_CATEGORY_ONLINE_SERVICE	"online-service"
+
+/**
+ * GST_ENCODING_CATEGORY_STORAGE_EDITING:
+ *
+ * #GstEncodingTarget category for storage, archiving and editing targets.
+ * Those targets can be lossless and/or provide very fast random access content.
+ * The name of the target will usually be the container type or editing target,
+ * and that target will contain #GstEncodingProfiles suitable for editing or
+ * storage.
+ */
+#define GST_ENCODING_CATEGORY_STORAGE_EDITING   "storage-editing"
+
+/**
+ * GST_ENCODING_CATEGORY_CAPTURE:
+ *
+ * #GstEncodingTarget category for recording and capture.
+ * Targets within this category are optimized for low latency encoding.
+ */
+#define GST_ENCODING_CATEGORY_CAPTURE		"capture"
+
+/**
+ * GstEncodingTarget:
+ *
+ * Collection of #GstEncodingProfile for a specific target or use-case.
+ *
+ * When being stored/loaded, targets come from a specific category, like
+ * #GST_ENCODING_CATEGORY_DEVICE.
+ *
+ * Since: 0.10.32
+ */
+#define GST_TYPE_ENCODING_TARGET			\
+  (gst_encoding_target_get_type ())
+#define GST_ENCODING_TARGET(obj)			\
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ENCODING_TARGET, GstEncodingTarget))
+#define GST_IS_ENCODING_TARGET(obj)			\
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ENCODING_TARGET))
+
+typedef struct _GstEncodingTarget GstEncodingTarget;
+typedef GstMiniObjectClass GstEncodingTargetClass;
+
+GType gst_encoding_target_get_type (void);
+
+/**
+ * gst_encoding_target_unref:
+ * @target: a #GstEncodingTarget
+ *
+ * Decreases the reference count of the @target, possibly freeing it.
+ *
+ * Since: 0.10.32
+ */
+#define gst_encoding_target_unref(target) \
+  (gst_mini_object_unref ((GstMiniObject*) target))
+
+/**
+ * gst_encoding_target_ref:
+ * @target: a #GstEncodingTarget
+ *
+ * Increases the reference count of the @target.
+ *
+ * Since: 0.10.32
+ */
+#define gst_encoding_target_ref(target) \
+  (gst_mini_object_ref ((GstMiniObject*) target))
+
+GstEncodingTarget *
+gst_encoding_target_new (const gchar *name, const gchar *category,
+			 const gchar *description, const GList *profiles);
+const gchar *gst_encoding_target_get_name (GstEncodingTarget *target);
+const gchar *gst_encoding_target_get_category (GstEncodingTarget *target);
+const gchar *gst_encoding_target_get_description (GstEncodingTarget *target);
+const GList *gst_encoding_target_get_profiles (GstEncodingTarget *target);
+GstEncodingProfile *gst_encoding_target_get_profile (GstEncodingTarget *target,
+						     const gchar *name);
+
+gboolean
+gst_encoding_target_add_profile (GstEncodingTarget *target, GstEncodingProfile *profile);
+
+gboolean gst_encoding_target_save (GstEncodingTarget *target,
+				   GError **error);
+gboolean gst_encoding_target_save_to_file (GstEncodingTarget *target,
+					   const gchar *filepath,
+					   GError **error);
+GstEncodingTarget *gst_encoding_target_load (const gchar *name,
+					     const gchar *category,
+					     GError **error);
+GstEncodingTarget *gst_encoding_target_load_from_file (const gchar *filepath,
+						       GError **error);
+
+GList *gst_encoding_list_available_categories (void);
+GList *gst_encoding_list_all_targets (const gchar * categoryname);
+
+G_END_DECLS
+
+#endif	/* __GST_PROFILE_REGISTRY_H__ */
diff --git a/gst-libs/gst/pbutils/pbutils.h b/gst-libs/gst/pbutils/pbutils.h
index 02f7f6b..2802cc7 100644
--- a/gst-libs/gst/pbutils/pbutils.h
+++ b/gst-libs/gst/pbutils/pbutils.h
@@ -26,6 +26,8 @@
 #include <gst/pbutils/missing-plugins.h>
 #include <gst/pbutils/install-plugins.h>
 #include <gst/pbutils/pbutils-enumtypes.h>
+#include <gst/pbutils/encoding-profile.h>
+#include <gst/pbutils/encoding-target.h>
 
 G_BEGIN_DECLS
 
diff --git a/gst/encoding/.gitignore b/gst/encoding/.gitignore
new file mode 100644
index 0000000..ff44545
--- /dev/null
+++ b/gst/encoding/.gitignore
@@ -0,0 +1 @@
+gstencode-marshal.[ch]
diff --git a/gst/encoding/Makefile.am b/gst/encoding/Makefile.am
new file mode 100644
index 0000000..0e287fa
--- /dev/null
+++ b/gst/encoding/Makefile.am
@@ -0,0 +1,41 @@
+# variables used for enum/marshal generation
+glib_enum_define = GST_ENCODE
+glib_gen_prefix = gst_encode
+glib_gen_basename = gstencode
+
+built_sources = gstencode-marshal.c
+built_headers = gstencode-marshal.h
+
+plugindir = $(libdir)/gstreamer-@GST_MAJORMINOR@
+
+plugin_LTLIBRARIES = libgstencodebin.la
+
+libgstencodebin_la_SOURCES = 	\
+	gstencodebin.c		\
+	gstsmartencoder.c	\
+	gststreamcombiner.c	\
+	gststreamsplitter.c
+
+nodist_libgstencodebin_la_SOURCES = $(built_sources)
+libgstencodebin_la_CFLAGS = $(GST_PLUGINS_BASE_CFLAGS) $(GST_CFLAGS)
+libgstencodebin_la_LDFLAGS = $(GST_PLUGIN_LDFLAGS)
+libgstencodebin_la_LIBADD = \
+	$(top_builddir)/gst-libs/gst/pbutils/libgstpbutils-@GST_MAJORMINOR@.la \
+	$(GST_LIBS)
+libgstencodebin_la_LIBTOOLFLAGS = --tag=disable-static
+
+noinst_HEADERS = 		\
+	gstencodebin.h		\
+	gststreamcombiner.h	\
+	gststreamsplitter.h	\
+	gstsmartencoder.h
+
+
+BUILT_SOURCES = $(built_headers) $(built_sources)
+
+EXTRA_DIST = gstencode-marshal.list
+
+CLEANFILES = $(BUILT_SOURCES)
+
+include $(top_srcdir)/common/gst-glib-gen.mak
+
diff --git a/gst/encoding/gstencode-marshal.list b/gst/encoding/gstencode-marshal.list
new file mode 100644
index 0000000..00f26ed
--- /dev/null
+++ b/gst/encoding/gstencode-marshal.list
@@ -0,0 +1 @@
+OBJECT:BOXED
diff --git a/gst/encoding/gstencodebin.c b/gst/encoding/gstencodebin.c
new file mode 100644
index 0000000..51b93ce
--- /dev/null
+++ b/gst/encoding/gstencodebin.c
@@ -0,0 +1,1783 @@
+/* GStreamer encoding bin
+ * Copyright (C) 2009 Edward Hervey <edward.hervey@collabora.co.uk>
+ *           (C) 2009 Nokia Corporation
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+#include "gstencodebin.h"
+#include "gstsmartencoder.h"
+#include "gststreamsplitter.h"
+#include "gststreamcombiner.h"
+#include <gst/gst-i18n-plugin.h>
+
+/**
+ * SECTION:element-encodebin
+ *
+ * EncodeBin provides a bin for encoding/muxing various streams according to
+ * a specified #GstEncodingProfile.
+ *
+ * Based on the profile that was set (via the #GstEncodeBin:profile property),
+ * EncodeBin will internally select and configure the required elements
+ * (encoders, muxers, but also audio and video converters) so that you can
+ * provide it raw or pre-encoded streams of data in input and have your
+ * encoded/muxed/converted stream in output.
+ *
+ * <refsect2>
+ * <title>Features</title>
+ * <itemizedlist>
+ * <listitem>
+ * Automatic encoder and muxer selection based on elements available on the
+ * system.
+ * </listitem>
+ * <listitem>
+ * Conversion of raw audio/video streams (scaling, framerate conversion,
+ * colorspace conversion, samplerate conversion) to conform to the profile
+ * output format.
+ * </listitem>
+ * <listitem>
+ * Variable number of streams. If the presence property for a stream encoding
+ * profile is 0, you can request any number of sink pads for it via the
+ * standard request pad gstreamer API or the #GstEncodeBin::request-pad action
+ * signal.
+ * </listitem>
+ * <listitem>
+ * Avoid reencoding (passthrough). If the input stream is already encoded and is
+ * compatible with what the #GstEncodingProfile expects, then the stream won't
+ * be re-encoded but just passed through downstream to the muxer or the output.
+ * </listitem>
+ * <listitem>
+ * Mix pre-encoded and raw streams as input. In addition to the passthrough
+ * feature above, you can feed both raw audio/video *AND* already-encoded data
+ * to a pad. #GstEncodeBin will take care of passing through the compatible
+ * segments and re-encoding the segments of media that need encoding.
+ * </listitem>
+ * <listitem>
+ * Standard behaviour is to use a #GstEncodingContainerProfile to have both
+ * encoding and muxing performed. But you can also provide a single stream
+ * profile (like #GstEncodingAudioProfile) to only have the encoding done and
+ * handle the encoded output yourself.
+ * </listitem>
+ * <listitem>
+ * Audio imperfection corrections. Incoming audio streams can have non perfect
+ * timestamps (jitter), like the streams coming from ASF files. #GstEncodeBin
+ * will automatically fix those imperfections for you. See
+ * #GstEncodeBin:audio-jitter-tolerance for more details.
+ * </listitem>
+ * <listitem>
+ * Variable or Constant video framerate. If your #GstEncodingVideoProfile has
+ * the variableframerate property deactivated (default), then the incoming
+ * raw video stream will be retimestampped in order to produce a constant
+ * framerate.
+ * </listitem>
+ * <listitem>
+ * Cross-boundary re-encoding. When feeding compatible pre-encoded streams that
+ * fall on segment boundaries, and for supported formats (right now only H263),
+ * the GOP will be decoded/reencoded when needed to produce an encoded output
+ * that fits exactly within the request GstSegment.
+ * </listitem>
+ * <listitem>
+ * Missing plugin support. If a #GstElement is missing to encode/mux to the
+ * request profile formats, a missing-plugin #GstMessage will be posted on the
+ * #GstBus, allowing systems that support the missing-plugin system to offer the
+ * user a way to install the missing element.
+ * </listitem>
+ * </itemizedlist>
+ * </refsect2>
+ */
+
+
+/* TODO/FIXME
+ *
+ * Handling mp3!xing!idv3 and theora!ogg tagsetting scenarios:
+ *  Once we have chosen a muxer:
+ *   When a new stream is requested:
+ *    If muxer is 'Formatter' OR doesn't have a TagSetter interface:
+ *      Find a Formatter for the given stream (preferably with TagSetter)
+ *       Insert that before muxer
+ **/
+
+#define fast_pad_link(a,b) gst_pad_link_full((a),(b),GST_PAD_LINK_CHECK_NOTHING)
+#define fast_element_link(a,b) gst_element_link_pads_full((a),"src",(b),"sink",GST_PAD_LINK_CHECK_NOTHING)
+
+/* generic templates */
+static GstStaticPadTemplate muxer_src_template =
+GST_STATIC_PAD_TEMPLATE ("src", GST_PAD_SRC, GST_PAD_ALWAYS,
+    GST_STATIC_CAPS_ANY);
+
+static GstStaticPadTemplate video_sink_template =
+GST_STATIC_PAD_TEMPLATE ("video_%d",
+    GST_PAD_SINK,
+    GST_PAD_REQUEST,
+    GST_STATIC_CAPS_ANY);
+static GstStaticPadTemplate audio_sink_template =
+GST_STATIC_PAD_TEMPLATE ("audio_%d",
+    GST_PAD_SINK,
+    GST_PAD_REQUEST,
+    GST_STATIC_CAPS_ANY);
+/* static GstStaticPadTemplate text_sink_template = */
+/* GST_STATIC_PAD_TEMPLATE ("text_%d", */
+/*     GST_PAD_SINK, */
+/*     GST_PAD_REQUEST, */
+/*     GST_STATIC_CAPS_ANY); */
+static GstStaticPadTemplate private_sink_template =
+GST_STATIC_PAD_TEMPLATE ("private_%d",
+    GST_PAD_SINK,
+    GST_PAD_REQUEST,
+    GST_STATIC_CAPS_ANY);
+
+struct _GstEncodeBin
+{
+  GstBin parent;
+
+  /* the profile field is only valid if it could be entirely setup */
+  GstEncodingProfile *profile;
+
+  GList *streams;               /* List of StreamGroup, not sorted */
+
+  GstElement *muxer;
+  /* Ghostpad with changing target */
+  GstPad *srcpad;
+
+  /* TRUE if in PAUSED/PLAYING */
+  gboolean active;
+
+  /* available muxers, encoders and parsers */
+  GList *muxers;
+  GList *encoders;
+  GList *parsers;
+
+  /* Increasing counter for unique pad name */
+  guint last_pad_id;
+
+  /* Cached caps for identification */
+  GstCaps *raw_video_caps;
+  GstCaps *raw_audio_caps;
+  /* GstCaps *raw_text_caps; */
+
+  guint queue_buffers_max;
+  guint queue_bytes_max;
+  guint64 queue_time_max;
+
+  guint64 tolerance;
+  gboolean avoid_reencoding;
+};
+
+struct _GstEncodeBinClass
+{
+  GstBinClass parent;
+
+  /* Action Signals */
+  GstPad *(*request_pad) (GstEncodeBin * encodebin, GstCaps * caps);
+};
+
+typedef struct _StreamGroup StreamGroup;
+
+struct _StreamGroup
+{
+  GstEncodeBin *ebin;
+  GstEncodingProfile *profile;
+  GstPad *ghostpad;             /* Sink ghostpad */
+  GstElement *inqueue;          /* Queue just after the ghostpad */
+  GstElement *splitter;
+  GList *converters;            /* List of conversion GstElement */
+  GstElement *capsfilter;       /* profile->restriction (if non-NULL/ANY) */
+  GstElement *encoder;          /* Encoder (can be NULL) */
+  GstElement *combiner;
+  GstElement *parser;
+  GstElement *smartencoder;
+  GstElement *outfilter;        /* Output capsfilter (streamprofile.format) */
+  GstElement *outqueue;         /* Queue just before the muxer */
+};
+
+/* Default for queues (same defaults as queue element) */
+#define DEFAULT_QUEUE_BUFFERS_MAX  200
+#define DEFAULT_QUEUE_BYTES_MAX    10 * 1024 * 1024
+#define DEFAULT_QUEUE_TIME_MAX     GST_SECOND
+#define DEFAULT_AUDIO_JITTER_TOLERANCE 20 * GST_MSECOND
+#define DEFAULT_AVOID_REENCODING   FALSE
+
+#define DEFAULT_RAW_CAPS			\
+  "video/x-raw-yuv; "				\
+  "video/x-raw-rgb; "				\
+  "video/x-raw-gray; "				\
+  "audio/x-raw-int; "				\
+  "audio/x-raw-float; "				\
+  "text/plain; "				\
+  "text/x-pango-markup; "			\
+  "video/x-dvd-subpicture; "			\
+  "subpicture/x-pgs"
+
+/* Properties */
+enum
+{
+  PROP_0,
+  PROP_PROFILE,
+  PROP_QUEUE_BUFFERS_MAX,
+  PROP_QUEUE_BYTES_MAX,
+  PROP_QUEUE_TIME_MAX,
+  PROP_AUDIO_JITTER_TOLERANCE,
+  PROP_AVOID_REENCODING,
+  PROP_LAST
+};
+
+/* Signals */
+enum
+{
+  SIGNAL_REQUEST_PAD,
+  LAST_SIGNAL
+};
+
+static guint gst_encode_bin_signals[LAST_SIGNAL] = { 0 };
+
+static GstStaticCaps default_raw_caps = GST_STATIC_CAPS (DEFAULT_RAW_CAPS);
+
+GST_DEBUG_CATEGORY_STATIC (gst_encode_bin_debug);
+#define GST_CAT_DEFAULT gst_encode_bin_debug
+
+G_DEFINE_TYPE (GstEncodeBin, gst_encode_bin, GST_TYPE_BIN);
+
+static void gst_encode_bin_dispose (GObject * object);
+static void gst_encode_bin_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec);
+static void gst_encode_bin_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec);
+static GstStateChangeReturn gst_encode_bin_change_state (GstElement * element,
+    GstStateChange transition);
+
+static GstPad *gst_encode_bin_request_new_pad (GstElement * element,
+    GstPadTemplate * templ, const gchar * name, const GstCaps * caps);
+static void gst_encode_bin_release_pad (GstElement * element, GstPad * pad);
+
+static gboolean
+gst_encode_bin_set_profile (GstEncodeBin * ebin, GstEncodingProfile * profile);
+static void gst_encode_bin_tear_down_profile (GstEncodeBin * ebin);
+static gboolean gst_encode_bin_setup_profile (GstEncodeBin * ebin,
+    GstEncodingProfile * profile);
+
+static StreamGroup *_create_stream_group (GstEncodeBin * ebin,
+    GstEncodingProfile * sprof, const gchar * sinkpadname, GstCaps * sinkcaps);
+static void stream_group_remove (GstEncodeBin * ebin, StreamGroup * sgroup);
+static GstPad *gst_encode_bin_request_pad_signal (GstEncodeBin * encodebin,
+    GstCaps * caps);
+
+static void
+gst_encode_bin_class_init (GstEncodeBinClass * klass)
+{
+  GObjectClass *gobject_klass;
+  GstElementClass *gstelement_klass;
+
+  gobject_klass = (GObjectClass *) klass;
+  gstelement_klass = (GstElementClass *) klass;
+
+  gobject_klass->dispose = gst_encode_bin_dispose;
+  gobject_klass->set_property = gst_encode_bin_set_property;
+  gobject_klass->get_property = gst_encode_bin_get_property;
+
+  /* Properties */
+
+  /**
+   * GstEncodeBin:profile:
+   *
+   * The #GstEncodingProfile to use. This property must be set before going
+   * to %GST_STATE_PAUSED or higher.
+   */
+  g_object_class_install_property (gobject_klass, PROP_PROFILE,
+      gst_param_spec_mini_object ("profile", "Profile",
+          "The GstEncodingProfile to use", GST_TYPE_ENCODING_PROFILE,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_klass, PROP_QUEUE_BUFFERS_MAX,
+      g_param_spec_uint ("queue-bytes-max", "Max. size (kB)",
+          "Max. amount of data in the queue (bytes, 0=disable)",
+          0, G_MAXUINT, DEFAULT_QUEUE_BYTES_MAX,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_klass, PROP_QUEUE_BYTES_MAX,
+      g_param_spec_uint ("queue-buffers-max", "Max. size (buffers)",
+          "Max. number of buffers in the queue (0=disable)", 0, G_MAXUINT,
+          DEFAULT_QUEUE_BUFFERS_MAX,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_klass, PROP_QUEUE_TIME_MAX,
+      g_param_spec_uint64 ("queue-time-max", "Max. size (ns)",
+          "Max. amount of data in the queue (in ns, 0=disable)", 0, G_MAXUINT64,
+          DEFAULT_QUEUE_TIME_MAX, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_klass, PROP_AUDIO_JITTER_TOLERANCE,
+      g_param_spec_uint64 ("audio-jitter-tolerance", "Audio jitter tolerance",
+          "Amount of timestamp jitter/imperfection to allow on audio streams before inserting/dropping samples (ns)",
+          0, G_MAXUINT64, DEFAULT_AUDIO_JITTER_TOLERANCE,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  g_object_class_install_property (gobject_klass, PROP_AVOID_REENCODING,
+      g_param_spec_boolean ("avoid-reencoding", "Avoid re-encoding",
+          "Whether to re-encode portions of compatible video streams that lay on segment boundaries",
+          DEFAULT_AVOID_REENCODING,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /* Signals */
+  /**
+   * GstEncodeBin::request-pad
+   * @encodebin: a #GstEncodeBin instance
+   * @caps: a #GstCaps
+   *
+   * Use this method to request an unused sink request #GstPad that can take the
+   * provided @caps as input. You must release the pad with
+   * gst_element_release_request_pad() when you are done with it.
+   *
+   * Returns: A compatible #GstPad, or %NULL if no compatible #GstPad could be
+   * created or is available.
+   */
+  gst_encode_bin_signals[SIGNAL_REQUEST_PAD] =
+      g_signal_new ("request-pad", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION, G_STRUCT_OFFSET (GstEncodeBinClass,
+          request_pad), NULL, NULL, gst_encode_marshal_OBJECT__BOXED,
+      GST_TYPE_PAD, 1, GST_TYPE_CAPS);
+
+  klass->request_pad = gst_encode_bin_request_pad_signal;
+
+  gst_element_class_add_pad_template (gstelement_klass,
+      gst_static_pad_template_get (&muxer_src_template));
+  gst_element_class_add_pad_template (gstelement_klass,
+      gst_static_pad_template_get (&video_sink_template));
+  gst_element_class_add_pad_template (gstelement_klass,
+      gst_static_pad_template_get (&audio_sink_template));
+  /* gst_element_class_add_pad_template (gstelement_klass, */
+  /*     gst_static_pad_template_get (&text_sink_template)); */
+  gst_element_class_add_pad_template (gstelement_klass,
+      gst_static_pad_template_get (&private_sink_template));
+
+  gstelement_klass->change_state =
+      GST_DEBUG_FUNCPTR (gst_encode_bin_change_state);
+  gstelement_klass->request_new_pad_full =
+      GST_DEBUG_FUNCPTR (gst_encode_bin_request_new_pad);
+  gstelement_klass->release_pad =
+      GST_DEBUG_FUNCPTR (gst_encode_bin_release_pad);
+
+  gst_element_class_set_details_simple (gstelement_klass,
+      "Encoder Bin",
+      "Generic/Bin/Encoder",
+      "Convenience encoding/muxing element",
+      "Edward Hervey <edward.hervey@collabora.co.uk>");
+}
+
+static void
+gst_encode_bin_dispose (GObject * object)
+{
+  GstEncodeBin *ebin = (GstEncodeBin *) object;
+
+  if (ebin->muxers)
+    gst_plugin_feature_list_free (ebin->muxers);
+
+  if (ebin->encoders)
+    gst_plugin_feature_list_free (ebin->encoders);
+
+  if (ebin->parsers)
+    gst_plugin_feature_list_free (ebin->parsers);
+
+  gst_encode_bin_tear_down_profile (ebin);
+
+  if (ebin->raw_video_caps)
+    gst_caps_unref (ebin->raw_video_caps);
+  if (ebin->raw_audio_caps)
+    gst_caps_unref (ebin->raw_audio_caps);
+  /* if (ebin->raw_text_caps) */
+  /*   gst_caps_unref (ebin->raw_text_caps); */
+
+  G_OBJECT_CLASS (gst_encode_bin_parent_class)->dispose (object);
+}
+
+static void
+gst_encode_bin_init (GstEncodeBin * encode_bin)
+{
+  GstPadTemplate *tmpl;
+  GList *formatters;
+
+  encode_bin->muxers =
+      gst_element_factory_list_get_elements (GST_ELEMENT_FACTORY_TYPE_MUXER,
+      GST_RANK_MARGINAL);
+  formatters =
+      gst_element_factory_list_get_elements (GST_ELEMENT_FACTORY_TYPE_FORMATTER,
+      GST_RANK_SECONDARY);
+  encode_bin->muxers = g_list_concat (encode_bin->muxers, formatters);
+
+  encode_bin->encoders =
+      gst_element_factory_list_get_elements (GST_ELEMENT_FACTORY_TYPE_ENCODER,
+      GST_RANK_MARGINAL);
+
+  encode_bin->parsers =
+      gst_element_factory_list_get_elements (GST_ELEMENT_FACTORY_TYPE_PARSER,
+      GST_RANK_MARGINAL);
+
+  encode_bin->raw_video_caps =
+      gst_caps_from_string ("video/x-raw-yuv;video/x-raw-rgb;video/x-raw-gray");
+  encode_bin->raw_audio_caps =
+      gst_caps_from_string ("audio/x-raw-int;audio/x-raw-float");
+  /* encode_bin->raw_text_caps = */
+  /*     gst_caps_from_string ("text/plain;text/x-pango-markup"); */
+
+  encode_bin->queue_buffers_max = DEFAULT_QUEUE_BUFFERS_MAX;
+  encode_bin->queue_bytes_max = DEFAULT_QUEUE_BYTES_MAX;
+  encode_bin->queue_time_max = DEFAULT_QUEUE_TIME_MAX;
+  encode_bin->tolerance = DEFAULT_AUDIO_JITTER_TOLERANCE;
+  encode_bin->avoid_reencoding = DEFAULT_AVOID_REENCODING;
+
+  tmpl = gst_static_pad_template_get (&muxer_src_template);
+  encode_bin->srcpad = gst_ghost_pad_new_no_target_from_template ("src", tmpl);
+  gst_object_unref (tmpl);
+  gst_element_add_pad (GST_ELEMENT_CAST (encode_bin), encode_bin->srcpad);
+}
+
+static void
+gst_encode_bin_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstEncodeBin *ebin = (GstEncodeBin *) object;
+
+  switch (prop_id) {
+    case PROP_PROFILE:
+      gst_encode_bin_set_profile (ebin,
+          (GstEncodingProfile *) gst_value_get_mini_object (value));
+      break;
+    case PROP_QUEUE_BUFFERS_MAX:
+      ebin->queue_buffers_max = g_value_get_uint (value);
+      break;
+    case PROP_QUEUE_BYTES_MAX:
+      ebin->queue_bytes_max = g_value_get_uint (value);
+      break;
+    case PROP_QUEUE_TIME_MAX:
+      ebin->queue_time_max = g_value_get_uint64 (value);
+      break;
+    case PROP_AUDIO_JITTER_TOLERANCE:
+      ebin->tolerance = g_value_get_uint64 (value);
+      break;
+    case PROP_AVOID_REENCODING:
+      ebin->avoid_reencoding = g_value_get_boolean (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_encode_bin_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstEncodeBin *ebin = (GstEncodeBin *) object;
+
+  switch (prop_id) {
+    case PROP_PROFILE:
+      gst_value_set_mini_object (value, (GstMiniObject *) ebin->profile);
+      break;
+    case PROP_QUEUE_BUFFERS_MAX:
+      g_value_set_uint (value, ebin->queue_buffers_max);
+      break;
+    case PROP_QUEUE_BYTES_MAX:
+      g_value_set_uint (value, ebin->queue_bytes_max);
+      break;
+    case PROP_QUEUE_TIME_MAX:
+      g_value_set_uint64 (value, ebin->queue_time_max);
+      break;
+    case PROP_AUDIO_JITTER_TOLERANCE:
+      g_value_set_uint64 (value, ebin->tolerance);
+      break;
+    case PROP_AVOID_REENCODING:
+      g_value_set_boolean (value, ebin->avoid_reencoding);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static inline gboolean
+are_raw_caps (const GstCaps * caps)
+{
+  GstCaps *raw = gst_static_caps_get (&default_raw_caps);
+
+  if (gst_caps_can_intersect (caps, raw)) {
+    gst_caps_unref (raw);
+    return TRUE;
+  }
+  gst_caps_unref (raw);
+  return FALSE;
+}
+
+/* Returns the number of time a given stream profile is currently used
+ * in encodebin */
+static inline guint
+stream_profile_used_count (GstEncodeBin * ebin, GstEncodingProfile * sprof)
+{
+  guint nbprofused = 0;
+  GList *tmp;
+
+  for (tmp = ebin->streams; tmp; tmp = tmp->next) {
+    StreamGroup *sgroup = (StreamGroup *) tmp->data;
+
+    if (sgroup->profile == sprof)
+      nbprofused++;
+  }
+
+  return nbprofused;
+}
+
+static inline GstEncodingProfile *
+next_unused_stream_profile (GstEncodeBin * ebin, GType ptype, GstCaps * caps)
+{
+  GST_DEBUG_OBJECT (ebin, "ptype:%s, caps:%" GST_PTR_FORMAT,
+      g_type_name (ptype), caps);
+
+  if (G_UNLIKELY (ptype == G_TYPE_NONE && caps != NULL)) {
+    /* Identify the profile type based on raw caps */
+    if (gst_caps_can_intersect (ebin->raw_video_caps, caps))
+      ptype = GST_TYPE_ENCODING_VIDEO_PROFILE;
+    else if (gst_caps_can_intersect (ebin->raw_audio_caps, caps))
+      ptype = GST_TYPE_ENCODING_AUDIO_PROFILE;
+    /* else if (gst_caps_can_intersect (ebin->raw_text_caps, caps)) */
+    /*   ptype = GST_TYPE_ENCODING_TEXT_PROFILE; */
+    GST_DEBUG_OBJECT (ebin, "Detected profile type as being %s",
+        g_type_name (ptype));
+  }
+
+  if (GST_IS_ENCODING_CONTAINER_PROFILE (ebin->profile)) {
+    const GList *tmp;
+
+    for (tmp =
+        gst_encoding_container_profile_get_profiles
+        (GST_ENCODING_CONTAINER_PROFILE (ebin->profile)); tmp;
+        tmp = tmp->next) {
+      GstEncodingProfile *sprof = (GstEncodingProfile *) tmp->data;
+
+      /* Pick an available Stream profile for which:
+       * * either it is of the compatibly raw type,
+       * * OR we can pass it through directly without encoding
+       */
+      if (G_TYPE_FROM_INSTANCE (sprof) == ptype) {
+        guint presence = gst_encoding_profile_get_presence (sprof);
+        GST_DEBUG ("Found a stream profile with the same type");
+        if ((presence == 0)
+            || (presence > stream_profile_used_count (ebin, sprof)))
+          return sprof;
+      } else if ((caps != NULL) && (ptype == G_TYPE_NONE)) {
+        GstCaps *outcaps;
+        gboolean res;
+
+        outcaps = gst_encoding_profile_get_input_caps (sprof);
+        GST_DEBUG ("Unknown stream, seeing if it's compatible with %"
+            GST_PTR_FORMAT, outcaps);
+        res = gst_caps_can_intersect (outcaps, caps);
+        gst_caps_unref (outcaps);
+
+        if (res)
+          return sprof;
+      }
+    }
+  }
+
+  return NULL;
+}
+
+static GstPad *
+request_pad_for_stream (GstEncodeBin * encodebin, GType ptype,
+    const gchar * name, GstCaps * caps)
+{
+  StreamGroup *sgroup;
+  GstEncodingProfile *sprof;
+
+  GST_DEBUG_OBJECT (encodebin, "name:%s caps:%" GST_PTR_FORMAT, name, caps);
+
+  /* Figure out if we have a unused GstEncodingProfile we can use for
+   * these caps */
+  sprof = next_unused_stream_profile (encodebin, ptype, caps);
+
+  if (G_UNLIKELY (sprof == NULL))
+    goto no_stream_profile;
+
+  sgroup = _create_stream_group (encodebin, sprof, name, caps);
+  if (G_UNLIKELY (sgroup == NULL))
+    goto no_stream_group;
+
+  return sgroup->ghostpad;
+
+no_stream_profile:
+  {
+    GST_WARNING_OBJECT (encodebin, "Couldn't find a compatible stream profile");
+    return NULL;
+  }
+
+no_stream_group:
+  {
+    GST_WARNING_OBJECT (encodebin, "Couldn't create a StreamGroup");
+    return NULL;
+  }
+}
+
+static GstPad *
+gst_encode_bin_request_new_pad (GstElement * element,
+    GstPadTemplate * templ, const gchar * name, const GstCaps * caps)
+{
+  GstEncodeBin *ebin = (GstEncodeBin *) element;
+  GstPad *res = NULL;
+
+  GST_DEBUG_OBJECT (element, "templ:%s, name:%s", templ->name_template, name);
+
+  /* Identify the stream group */
+  if (caps != NULL) {
+    res = request_pad_for_stream (ebin, G_TYPE_NONE, name, (GstCaps *) caps);
+  }
+
+  if (res == NULL) {
+    GType ptype = G_TYPE_NONE;
+
+    if (!strcmp (templ->name_template, "video_%d"))
+      ptype = GST_TYPE_ENCODING_VIDEO_PROFILE;
+    else if (!strcmp (templ->name_template, "audio_%d"))
+      ptype = GST_TYPE_ENCODING_AUDIO_PROFILE;
+    /* else if (!strcmp (templ->name_template, "text_%d")) */
+    /*   ptype = GST_TYPE_ENCODING_TEXT_PROFILE; */
+
+    /* FIXME : Check uniqueness of pad */
+    /* FIXME : Check that the requested number is the last one, and if not,
+     * update the last_pad_id variable so that we don't create a pad with
+     * the same name/number in the future */
+
+    res = request_pad_for_stream (ebin, ptype, name, NULL);
+  }
+
+  return res;
+}
+
+static GstPad *
+gst_encode_bin_request_pad_signal (GstEncodeBin * encodebin, GstCaps * caps)
+{
+  GstPad *pad = request_pad_for_stream (encodebin, G_TYPE_NONE, NULL, caps);
+
+  return pad ? GST_PAD_CAST (gst_object_ref (pad)) : NULL;
+}
+
+static inline StreamGroup *
+find_stream_group_from_pad (GstEncodeBin * ebin, GstPad * pad)
+{
+  GList *tmp;
+
+  for (tmp = ebin->streams; tmp; tmp = tmp->next) {
+    StreamGroup *sgroup = (StreamGroup *) tmp->data;
+    if (G_UNLIKELY (sgroup->ghostpad == pad))
+      return sgroup;
+  }
+
+  return NULL;
+}
+
+static void
+gst_encode_bin_release_pad (GstElement * element, GstPad * pad)
+{
+  GstEncodeBin *ebin = (GstEncodeBin *) element;
+  StreamGroup *sgroup;
+
+  /* Find the associated StreamGroup */
+
+  sgroup = find_stream_group_from_pad (ebin, pad);
+  if (G_UNLIKELY (sgroup == NULL))
+    goto no_stream_group;
+
+  /* Release objects/data associated with the StreamGroup */
+  stream_group_remove (ebin, sgroup);
+
+  return;
+
+no_stream_group:
+  {
+    GST_WARNING_OBJECT (ebin, "Couldn't find corresponding StreamGroup");
+    return;
+  }
+}
+
+/* Create a parser for the given stream profile */
+static inline GstElement *
+_get_parser (GstEncodeBin * ebin, GstEncodingProfile * sprof)
+{
+  GList *parsers1, *parsers, *tmp;
+  GstElement *parser = NULL;
+  GstElementFactory *parserfact = NULL;
+  const GstCaps *format;
+
+  format = gst_encoding_profile_get_format (sprof);
+
+  GST_DEBUG ("Getting list of parsers for format %" GST_PTR_FORMAT, format);
+
+  /* FIXME : requesting twice the parsers twice is a bit ugly, we should
+   * have a method to request on more than one condition */
+  parsers1 =
+      gst_element_factory_list_filter (ebin->parsers, format,
+      GST_PAD_SRC, FALSE);
+  parsers =
+      gst_element_factory_list_filter (parsers1, format, GST_PAD_SINK, FALSE);
+  gst_plugin_feature_list_free (parsers1);
+
+  if (G_UNLIKELY (parsers == NULL)) {
+    GST_DEBUG ("Couldn't find any compatible parsers");
+    return NULL;
+  }
+
+  for (tmp = parsers; tmp; tmp = tmp->next) {
+    /* FIXME : We're only picking the first one so far */
+    /* FIXME : signal the user if he wants this */
+    parserfact = (GstElementFactory *) tmp->data;
+    break;
+  }
+
+  if (parserfact)
+    parser = gst_element_factory_create (parserfact, NULL);
+
+  gst_plugin_feature_list_free (parsers);
+
+  return parser;
+}
+
+static GstElement *
+_create_element_and_set_preset (GstElementFactory * factory,
+    const gchar * preset, const gchar * name)
+{
+  GstElement *res = NULL;
+
+  GST_DEBUG ("Creating element from factory %s",
+      GST_PLUGIN_FEATURE_NAME (factory));
+  res = gst_element_factory_create (factory, name);
+  if (preset && GST_IS_PRESET (res) &&
+      !gst_preset_load_preset (GST_PRESET (res), preset)) {
+    GST_WARNING ("Couldn't set preset [%s] on element [%s]",
+        preset, GST_PLUGIN_FEATURE_NAME (factory));
+    gst_object_unref (res);
+    res = NULL;
+  }
+
+  return res;
+}
+
+/* Create the encoder for the given stream profile */
+static inline GstElement *
+_get_encoder (GstEncodeBin * ebin, GstEncodingProfile * sprof)
+{
+  GList *encoders, *tmp;
+  GstElement *encoder = NULL;
+  GstElementFactory *encoderfact = NULL;
+  const GstCaps *format;
+  const gchar *preset;
+
+  format = gst_encoding_profile_get_format (sprof);
+  preset = gst_encoding_profile_get_preset (sprof);
+
+  GST_DEBUG ("Getting list of encoders for format %" GST_PTR_FORMAT, format);
+
+  /* If stream caps are raw, return identity */
+  if (G_UNLIKELY (are_raw_caps (format))) {
+    GST_DEBUG ("Stream format is raw, returning identity as the encoder");
+    encoder = gst_element_factory_make ("identity", NULL);
+    goto beach;
+  }
+
+  encoders =
+      gst_element_factory_list_filter (ebin->encoders, format,
+      GST_PAD_SRC, FALSE);
+
+  if (G_UNLIKELY (encoders == NULL)) {
+    GST_DEBUG ("Couldn't find any compatible encoders");
+    goto beach;
+  }
+
+  for (tmp = encoders; tmp; tmp = tmp->next) {
+    encoderfact = (GstElementFactory *) tmp->data;
+    if ((encoder = _create_element_and_set_preset (encoderfact, preset, NULL)))
+      break;
+  }
+
+  gst_plugin_feature_list_free (encoders);
+
+beach:
+  return encoder;
+}
+
+static GstPad *
+local_element_request_pad (GstElement * element, GstPadTemplate * templ,
+    const gchar * name)
+{
+  GstPad *newpad = NULL;
+  GstElementClass *oclass;
+
+  oclass = GST_ELEMENT_GET_CLASS (element);
+
+  if (oclass->request_new_pad)
+    newpad = (oclass->request_new_pad) (element, templ, name);
+
+  if (newpad)
+    gst_object_ref (newpad);
+
+  return newpad;
+}
+
+static GstPad *
+gst_element_get_pad_from_template (GstElement * element, GstPadTemplate * templ)
+{
+  GstPad *ret = NULL;
+  GstPadPresence presence;
+
+  /* If this function is ever exported, we need check the validity of `element'
+   * and `templ', and to make sure the template actually belongs to the
+   * element. */
+
+  presence = GST_PAD_TEMPLATE_PRESENCE (templ);
+
+  switch (presence) {
+    case GST_PAD_ALWAYS:
+    case GST_PAD_SOMETIMES:
+      ret = gst_element_get_static_pad (element, templ->name_template);
+      if (!ret && presence == GST_PAD_ALWAYS)
+        g_warning
+            ("Element %s has an ALWAYS template %s, but no pad of the same name",
+            GST_OBJECT_NAME (element), templ->name_template);
+      break;
+
+    case GST_PAD_REQUEST:
+      ret = gst_element_request_pad (element, templ, NULL, NULL);
+      break;
+  }
+
+  return ret;
+}
+
+/* FIXME : Improve algorithm for finding compatible muxer sink pad */
+static inline GstPad *
+get_compatible_muxer_sink_pad (GstEncodeBin * ebin, GstElement * encoder,
+    const GstCaps * sinkcaps)
+{
+  GstPad *sinkpad;
+  GstPadTemplate *srctempl = NULL;
+  GstPadTemplate *sinktempl;
+
+  if (encoder) {
+    GstPad *srcpad;
+    srcpad = gst_element_get_static_pad (encoder, "src");
+
+    srctempl = gst_pad_get_pad_template (srcpad);
+
+    GST_DEBUG_OBJECT (ebin,
+        "Attempting to find pad from muxer %s compatible with %s:%s",
+        GST_ELEMENT_NAME (ebin->muxer), GST_DEBUG_PAD_NAME (srcpad));
+
+    gst_object_unref (srcpad);
+    sinktempl = gst_element_get_compatible_pad_template (ebin->muxer, srctempl);
+  } else {
+    srctempl =
+        gst_pad_template_new ("whatever", GST_PAD_SRC, GST_PAD_ALWAYS,
+        gst_caps_copy (sinkcaps));
+    g_assert (srctempl != NULL);
+    sinktempl = gst_element_get_compatible_pad_template (ebin->muxer, srctempl);
+    g_object_unref (srctempl);
+  }
+
+  if (G_UNLIKELY (sinktempl == NULL))
+    goto no_template;
+
+  sinkpad = gst_element_get_pad_from_template (ebin->muxer, sinktempl);
+
+  return sinkpad;
+
+no_template:
+  {
+    GST_WARNING_OBJECT (ebin, "No compatible pad available on muxer");
+    return NULL;
+  }
+}
+
+/* FIXME : Add handling of streams that don't need encoding  */
+/* FIXME : Add handling of streams that don't require conversion elements */
+/*
+ * Create the elements, StreamGroup, add the sink pad, link it to the muxer
+ *
+ * sinkpadname: If non-NULL, that name will be assigned to the sink ghost pad
+ * sinkcaps: If non-NULL will be used to figure out how to setup the group */
+static StreamGroup *
+_create_stream_group (GstEncodeBin * ebin, GstEncodingProfile * sprof,
+    const gchar * sinkpadname, GstCaps * sinkcaps)
+{
+  StreamGroup *sgroup = NULL;
+  GstPad *sinkpad, *srcpad, *muxerpad = NULL;
+  /* Element we will link to the encoder */
+  GstElement *last = NULL;
+  GList *tmp, *tosync = NULL;
+  const GstCaps *format;
+  const GstCaps *restriction;
+
+  format = gst_encoding_profile_get_format (sprof);
+  restriction = gst_encoding_profile_get_restriction (sprof);
+
+  GST_DEBUG ("Creating group. format %" GST_PTR_FORMAT ", for caps %"
+      GST_PTR_FORMAT, format, sinkcaps);
+  GST_DEBUG ("avoid_reencoding:%d", ebin->avoid_reencoding);
+
+  sgroup = g_slice_new0 (StreamGroup);
+  sgroup->ebin = ebin;
+  sgroup->profile = sprof;
+
+  /* NOTE for people reading this code:
+   * 
+   * We construct the group starting by the furthest downstream element
+   * and making our way up adding/syncing/linking as we go.
+   *
+   * There are two parallel paths:
+   * * One for raw data which goes through converters and encoders
+   * * One for already encoded data
+   */
+
+  /* Exception to the rule above:
+   * We check if we have an available encoder so we can abort early */
+  /* FIXME : What if we only want to do passthrough ??? */
+  GST_LOG ("Checking for encoder availability");
+  sgroup->encoder = _get_encoder (ebin, sprof);
+  if (G_UNLIKELY (sgroup->encoder == NULL))
+    goto no_encoder;
+
+  /* Muxer.
+   * If we are handling a container profile, figure out if the muxer has a
+   * sinkpad compatible with the selected profile */
+  if (ebin->muxer) {
+    muxerpad = get_compatible_muxer_sink_pad (ebin, NULL, format);
+    if (G_UNLIKELY (muxerpad == NULL))
+      goto no_muxer_pad;
+  }
+
+  /* Output Queue.
+   * We only use a 1buffer long queue here, the actual queueing will be done
+   * in the intput queue */
+  last = sgroup->outqueue = gst_element_factory_make ("queue", NULL);
+  g_object_set (sgroup->outqueue, "max-size-buffers", (guint32) 1,
+      "max-size-bytes", (guint32) 0, "max-size-time", (guint64) 0, NULL);
+
+  gst_bin_add (GST_BIN (ebin), sgroup->outqueue);
+  tosync = g_list_append (tosync, sgroup->outqueue);
+  srcpad = gst_element_get_static_pad (sgroup->outqueue, "src");
+  if (muxerpad) {
+    if (G_UNLIKELY (fast_pad_link (srcpad, muxerpad) != GST_PAD_LINK_OK)) {
+      goto muxer_link_failure;
+    }
+    gst_object_unref (muxerpad);
+  } else {
+    gst_ghost_pad_set_target (GST_GHOST_PAD (ebin->srcpad), srcpad);
+  }
+  gst_object_unref (srcpad);
+
+  /* Output capsfilter
+   * This will receive the format caps from the streamprofile */
+  GST_DEBUG ("Adding output capsfilter for %" GST_PTR_FORMAT, format);
+  sgroup->outfilter = gst_element_factory_make ("capsfilter", NULL);
+  g_object_set (sgroup->outfilter, "caps", format, NULL);
+
+  gst_bin_add (GST_BIN (ebin), sgroup->outfilter);
+  tosync = g_list_append (tosync, sgroup->outfilter);
+  if (G_UNLIKELY (!fast_element_link (sgroup->outfilter, last)))
+    goto outfilter_link_failure;
+  last = sgroup->outfilter;
+
+
+  /* FIXME :
+   *
+   *   The usage of parsers in encoding/muxing scenarios is
+   * just too undefined to just use as-is.
+   *
+   * Take the use-case where you want to re-mux a stream of type
+   * "my/media". You create a StreamEncodingProfile with that type
+   * as the target (as-is). And you use decodebin2/uridecodebin
+   * upstream.
+   *
+   * * demuxer exposes "my/media"
+   * * a parser is available for "my/media" which has a source pad
+   *   caps of "my/media,parsed=True"
+   * * decodebin2/uridecodebin exposes a new pad with the parsed caps
+   * * You request a new stream from encodebin, which will match the
+   *   streamprofile and creates a group (i.e. going through this method)
+   *   There is a matching parser (the same used in the decoder) whose
+   *   source pad caps intersects with the stream profile caps, you
+   *   therefore use it...
+   * * ... but that parser has a "my/media,parsed=False" sink pad caps
+   * * ... and you can't link your decodebin pad to encodebin.
+   *
+   * In the end, it comes down to parsers only taking into account the
+   * decoding use-cases.
+   *
+   * One way to solve that might be to :
+   * * Make parsers sink pad caps be "framed={False,True}" and the
+   *   source pad caps be "framed=True"
+   * * Modify decodebin2 accordingly to avoid looping and chaining
+   *   an infinite number of parsers
+   *
+   * Another way would be to have "well-known" caps properties to specify
+   * whether a stream has been parsed or not.
+   * * currently we fail. aacparse uses 'framed' and mp3parse uses 'parsed'
+   */
+  /* FIXME : Re-enable once parser situation is un-$#*@(%$#ed */
+#if 0
+  /* Parser.
+   * FIXME : identify smart parsers (used for re-encoding) */
+  sgroup->parser = _get_parser (ebin, sprof);
+
+  if (sgroup->parser != NULL) {
+    GST_DEBUG ("Got a parser %s", GST_ELEMENT_NAME (sgroup->parser));
+    gst_bin_add (GST_BIN (ebin), sgroup->parser);
+    tosync = g_list_append (tosync, sgroup->parser);
+    if (G_UNLIKELY (!gst_element_link (sgroup->parser, last)))
+      goto parser_link_failure;
+    last = sgroup->parser;
+  }
+#endif
+
+  /* Stream combiner */
+  sgroup->combiner = g_object_new (GST_TYPE_STREAM_COMBINER, NULL);
+
+  gst_bin_add (GST_BIN (ebin), sgroup->combiner);
+  tosync = g_list_append (tosync, sgroup->combiner);
+  if (G_UNLIKELY (!fast_element_link (sgroup->combiner, last)))
+    goto combiner_link_failure;
+
+
+  /* Stream splitter */
+  sgroup->splitter = g_object_new (GST_TYPE_STREAM_SPLITTER, NULL);
+
+  gst_bin_add (GST_BIN (ebin), sgroup->splitter);
+  tosync = g_list_append (tosync, sgroup->splitter);
+
+  /* Input queue
+   * FIXME : figure out what max-size to use for the input queue */
+  sgroup->inqueue = gst_element_factory_make ("queue", NULL);
+  g_object_set (sgroup->inqueue, "max-size-buffers",
+      (guint32) ebin->queue_buffers_max, "max-size-bytes",
+      (guint32) ebin->queue_bytes_max, "max-size-time",
+      (guint64) ebin->queue_time_max, NULL);
+
+  gst_bin_add (GST_BIN (ebin), sgroup->inqueue);
+  tosync = g_list_append (tosync, sgroup->inqueue);
+  if (G_UNLIKELY (!fast_element_link (sgroup->inqueue, sgroup->splitter)))
+    goto splitter_link_failure;
+
+  /* Expose input queue sink pad as ghostpad */
+  sinkpad = gst_element_get_static_pad (sgroup->inqueue, "sink");
+  if (sinkpadname == NULL) {
+    gchar *pname =
+        g_strdup_printf ("%s_%d", gst_encoding_profile_get_type_nick (sprof),
+        ebin->last_pad_id++);
+    GST_DEBUG ("Adding ghost pad %s", pname);
+    sgroup->ghostpad = gst_ghost_pad_new (pname, sinkpad);
+    g_free (pname);
+  } else
+    sgroup->ghostpad = gst_ghost_pad_new (sinkpadname, sinkpad);
+  gst_object_unref (sinkpad);
+
+
+  /* Path 1 : Already-encoded data */
+  sinkpad =
+      local_element_request_pad (sgroup->combiner, NULL, "passthroughsink");
+  if (G_UNLIKELY (sinkpad == NULL))
+    goto no_combiner_sinkpad;
+
+  if (ebin->avoid_reencoding) {
+    GstCaps *tmpcaps;
+
+    GST_DEBUG ("Asked to use Smart Encoder");
+    sgroup->smartencoder = g_object_new (GST_TYPE_SMART_ENCODER, NULL);
+
+    /* Check if stream format is compatible */
+    srcpad = gst_element_get_static_pad (sgroup->smartencoder, "src");
+    tmpcaps = gst_pad_get_caps (srcpad);
+    if (!gst_caps_can_intersect (tmpcaps, format)) {
+      GST_DEBUG ("We don't have a smart encoder for the stream format");
+      gst_object_unref (sgroup->smartencoder);
+      sgroup->smartencoder = NULL;
+    } else {
+      gst_bin_add ((GstBin *) ebin, sgroup->smartencoder);
+      fast_pad_link (srcpad, sinkpad);
+      tosync = g_list_append (tosync, sgroup->smartencoder);
+      sinkpad = gst_element_get_static_pad (sgroup->smartencoder, "sink");
+    }
+    gst_caps_unref (tmpcaps);
+    g_object_unref (srcpad);
+  }
+
+  srcpad = local_element_request_pad (sgroup->splitter, NULL, "passthroughsrc");
+  if (G_UNLIKELY (srcpad == NULL))
+    goto no_splitter_srcpad;
+
+  /* Go straight to splitter */
+  if (G_UNLIKELY (fast_pad_link (srcpad, sinkpad) != GST_PAD_LINK_OK))
+    goto passthrough_link_failure;
+  g_object_unref (sinkpad);
+  g_object_unref (srcpad);
+
+
+  /* Path 2 : Conversion / Encoding */
+
+  /* 1. Create the encoder */
+  GST_LOG ("Adding encoder");
+  last = sgroup->encoder;
+  gst_bin_add ((GstBin *) ebin, sgroup->encoder);
+  tosync = g_list_append (tosync, sgroup->encoder);
+
+  sinkpad = local_element_request_pad (sgroup->combiner, NULL, "encodingsink");
+  if (G_UNLIKELY (sinkpad == NULL))
+    goto no_combiner_sinkpad;
+  srcpad = gst_element_get_static_pad (sgroup->encoder, "src");
+  if (G_UNLIKELY (fast_pad_link (srcpad, sinkpad) != GST_PAD_LINK_OK))
+    goto encoder_link_failure;
+  g_object_unref (sinkpad);
+  g_object_unref (srcpad);
+
+
+  /* 3. Create the conversion/restriction elements */
+  /* 3.1. capsfilter */
+  if (restriction && !gst_caps_is_any (restriction)) {
+    GST_LOG ("Adding capsfilter for restriction caps : %" GST_PTR_FORMAT,
+        restriction);
+
+    last = sgroup->capsfilter = gst_element_factory_make ("capsfilter", NULL);
+    g_object_set (sgroup->capsfilter, "caps", restriction, NULL);
+    gst_bin_add ((GstBin *) ebin, sgroup->capsfilter);
+    tosync = g_list_append (tosync, sgroup->capsfilter);
+    fast_element_link (sgroup->capsfilter, sgroup->encoder);
+  }
+
+  /* 3.2. restriction elements */
+  /* FIXME : Once we have properties for specific converters, use those */
+  if (GST_IS_ENCODING_VIDEO_PROFILE (sprof)) {
+    GstElement *cspace, *scale, *vrate, *cspace2;
+
+    GST_LOG ("Adding conversion elements for video stream");
+
+    cspace = gst_element_factory_make ("ffmpegcolorspace", NULL);
+    scale = gst_element_factory_make ("videoscale", NULL);
+    /* 4-tap scaling and black borders */
+    g_object_set (scale, "method", 2, "add-borders", TRUE, NULL);
+    cspace2 = gst_element_factory_make ("ffmpegcolorspace", NULL);
+
+    gst_bin_add_many ((GstBin *) ebin, cspace, scale, cspace2, NULL);
+    tosync = g_list_append (tosync, cspace);
+    tosync = g_list_append (tosync, scale);
+    tosync = g_list_append (tosync, cspace2);
+
+    sgroup->converters = g_list_prepend (sgroup->converters, cspace);
+    sgroup->converters = g_list_prepend (sgroup->converters, scale);
+    sgroup->converters = g_list_prepend (sgroup->converters, cspace2);
+
+    if (!fast_element_link (cspace, scale) ||
+        !fast_element_link (scale, cspace2))
+      goto converter_link_failure;
+
+    if (!gst_encoding_video_profile_get_variableframerate
+        (GST_ENCODING_VIDEO_PROFILE (sprof))) {
+      vrate = gst_element_factory_make ("videorate", NULL);
+      gst_bin_add ((GstBin *) ebin, vrate);
+      tosync = g_list_prepend (tosync, vrate);
+      sgroup->converters = g_list_prepend (sgroup->converters, vrate);
+      if (!fast_element_link (cspace2, vrate) ||
+          !fast_element_link (vrate, last))
+        goto converter_link_failure;
+    } else if (!fast_element_link (cspace2, last))
+      goto converter_link_failure;
+
+    last = cspace;
+
+  } else if (GST_IS_ENCODING_AUDIO_PROFILE (sprof)) {
+    GstElement *aconv, *ares, *arate, *aconv2;
+
+    GST_LOG ("Adding conversion elements for audio stream");
+
+    arate = gst_element_factory_make ("audiorate", NULL);
+    g_object_set (arate, "tolerance", (guint64) ebin->tolerance, NULL);
+    aconv = gst_element_factory_make ("audioconvert", NULL);
+    aconv2 = gst_element_factory_make ("audioconvert", NULL);
+    ares = gst_element_factory_make ("audioresample", NULL);
+
+    gst_bin_add_many ((GstBin *) ebin, arate, aconv, ares, aconv2, NULL);
+    tosync = g_list_append (tosync, arate);
+    tosync = g_list_append (tosync, aconv);
+    tosync = g_list_append (tosync, ares);
+    tosync = g_list_append (tosync, aconv2);
+    if (!fast_element_link (arate, aconv) ||
+        !fast_element_link (aconv, ares) ||
+        !fast_element_link (ares, aconv2) || !fast_element_link (aconv2, last))
+      goto converter_link_failure;
+
+    sgroup->converters = g_list_prepend (sgroup->converters, arate);
+    sgroup->converters = g_list_prepend (sgroup->converters, aconv);
+    sgroup->converters = g_list_prepend (sgroup->converters, ares);
+    sgroup->converters = g_list_prepend (sgroup->converters, aconv2);
+
+    last = arate;
+  }
+
+  /* Link to stream splitter */
+  sinkpad = gst_element_get_static_pad (last, "sink");
+  srcpad = local_element_request_pad (sgroup->splitter, NULL, "encodingsrc");
+  if (G_UNLIKELY (srcpad == NULL))
+    goto no_splitter_srcpad;
+  if (G_UNLIKELY (fast_pad_link (srcpad, sinkpad) != GST_PAD_LINK_OK))
+    goto splitter_encoding_failure;
+  g_object_unref (sinkpad);
+  g_object_unref (srcpad);
+
+  /* End of Stream 2 setup */
+
+  /* Sync all elements to parent state */
+  for (tmp = tosync; tmp; tmp = tmp->next)
+    gst_element_sync_state_with_parent ((GstElement *) tmp->data);
+  g_list_free (tosync);
+
+  /* Add ghostpad */
+  GST_DEBUG ("Adding ghostpad %s:%s", GST_DEBUG_PAD_NAME (sgroup->ghostpad));
+  gst_pad_set_active (sgroup->ghostpad, TRUE);
+  gst_element_add_pad ((GstElement *) ebin, sgroup->ghostpad);
+
+  /* Add StreamGroup to our list of streams */
+
+  GST_DEBUG
+      ("Done creating elements, adding StreamGroup to our controlled stream list");
+
+  ebin->streams = g_list_prepend (ebin->streams, sgroup);
+
+  return sgroup;
+
+splitter_encoding_failure:
+  GST_ERROR_OBJECT (ebin, "Error linking splitter to encoding stream");
+  goto cleanup;
+
+no_encoder:
+  GST_ERROR_OBJECT (ebin, "Couldn't create encoder for format %" GST_PTR_FORMAT,
+      format);
+  /* missing plugin support */
+  gst_element_post_message (GST_ELEMENT_CAST (ebin),
+      gst_missing_encoder_message_new (GST_ELEMENT_CAST (ebin), format));
+  GST_ELEMENT_ERROR (ebin, CORE, MISSING_PLUGIN, (NULL),
+      ("Couldn't create encoder for format %" GST_PTR_FORMAT, format));
+  goto cleanup;
+
+no_muxer_pad:
+  GST_ERROR_OBJECT (ebin,
+      "Couldn't find a compatible muxer pad to link encoder to");
+  goto cleanup;
+
+encoder_link_failure:
+  GST_ERROR_OBJECT (ebin, "Failed to link the encoder");
+  goto cleanup;
+
+muxer_link_failure:
+  GST_ERROR_OBJECT (ebin, "Couldn't link encoder to muxer");
+  goto cleanup;
+
+outfilter_link_failure:
+  GST_ERROR_OBJECT (ebin, "Couldn't link output filter to output queue");
+  goto cleanup;
+
+passthrough_link_failure:
+  GST_ERROR_OBJECT (ebin, "Failed linking splitter in passthrough mode");
+  goto cleanup;
+
+no_splitter_srcpad:
+  GST_ERROR_OBJECT (ebin, "Couldn't get a source pad from the splitter");
+  goto cleanup;
+
+no_combiner_sinkpad:
+  GST_ERROR_OBJECT (ebin, "Couldn't get a sink pad from the combiner");
+  goto cleanup;
+
+splitter_link_failure:
+  GST_ERROR_OBJECT (ebin, "Failure linking to the splitter");
+  goto cleanup;
+
+combiner_link_failure:
+  GST_ERROR_OBJECT (ebin, "Failure linking to the combiner");
+  goto cleanup;
+
+#if 0
+parser_link_failure:
+  GST_ERROR_OBJECT (ebin, "Failure linking the parser");
+  goto cleanup;
+#endif
+
+converter_link_failure:
+  GST_ERROR_OBJECT (ebin, "Failure linking the video converters");
+  goto cleanup;
+
+cleanup:
+  /* FIXME : Actually properly cleanup everything */
+  g_slice_free (StreamGroup, sgroup);
+  return NULL;
+}
+
+static gboolean
+_factory_can_sink_caps (GstElementFactory * factory, const GstCaps * caps)
+{
+  GList *templates = factory->staticpadtemplates;
+
+  while (templates) {
+    GstStaticPadTemplate *template = (GstStaticPadTemplate *) templates->data;
+
+    if (template->direction == GST_PAD_SINK) {
+      GstCaps *tmp = gst_static_caps_get (&template->static_caps);
+
+      if (gst_caps_can_intersect (tmp, caps)) {
+        gst_caps_unref (tmp);
+        return TRUE;
+      }
+      gst_caps_unref (tmp);
+    }
+    templates = g_list_next (templates);
+  }
+
+  return FALSE;
+}
+
+static inline GstElement *
+_get_muxer (GstEncodeBin * ebin)
+{
+  GList *muxers, *tmpmux;
+  GstElement *muxer = NULL;
+  GstElementFactory *muxerfact = NULL;
+  const GList *tmp;
+  const GstCaps *format;
+  const gchar *preset;
+
+  format = gst_encoding_profile_get_format (ebin->profile);
+  preset = gst_encoding_profile_get_preset (ebin->profile);
+
+  GST_DEBUG ("Getting list of muxers for format %" GST_PTR_FORMAT, format);
+
+  muxers =
+      gst_element_factory_list_filter (ebin->muxers, format, GST_PAD_SRC, TRUE);
+
+  if (muxers == NULL)
+    goto beach;
+
+  /* FIXME : signal the user if he wants this */
+  for (tmpmux = muxers; tmpmux; tmpmux = tmpmux->next) {
+    gboolean cansinkstreams = TRUE;
+    const GList *profiles =
+        gst_encoding_container_profile_get_profiles
+        (GST_ENCODING_CONTAINER_PROFILE (ebin->profile));
+
+    muxerfact = (GstElementFactory *) tmpmux->data;
+
+    GST_DEBUG ("Trying muxer %s", GST_PLUGIN_FEATURE_NAME (muxerfact));
+
+    /* See if the muxer can sink all of our stream profile caps */
+    for (tmp = profiles; tmp; tmp = tmp->next) {
+      GstEncodingProfile *sprof = (GstEncodingProfile *) tmp->data;
+
+      if (!_factory_can_sink_caps (muxerfact,
+              gst_encoding_profile_get_format (sprof))) {
+        GST_DEBUG ("Skipping muxer because it can't sink caps %" GST_PTR_FORMAT,
+            gst_encoding_profile_get_format (sprof));
+        cansinkstreams = FALSE;
+        break;
+      }
+    }
+
+    /* Only use a muxer than can use all streams and than can accept the
+     * preset (which may be present or not) */
+    if (cansinkstreams && (muxer =
+            _create_element_and_set_preset (muxerfact, preset, "muxer")))
+      break;
+  }
+
+  gst_plugin_feature_list_free (muxers);
+
+beach:
+  return muxer;
+}
+
+static gboolean
+create_elements_and_pads (GstEncodeBin * ebin)
+{
+  gboolean ret = TRUE;
+  GstElement *muxer = NULL;
+  GstPad *muxerpad;
+  const GList *tmp, *profiles;
+  GstEncodingProfile *sprof;
+
+  GST_DEBUG ("Current profile : %s",
+      gst_encoding_profile_get_name (ebin->profile));
+
+  if (GST_IS_ENCODING_CONTAINER_PROFILE (ebin->profile)) {
+    /* 1. Get the compatible muxer */
+    muxer = _get_muxer (ebin);
+    if (G_UNLIKELY (muxer == NULL))
+      goto no_muxer;
+
+    /* Record the muxer */
+    ebin->muxer = muxer;
+    gst_bin_add ((GstBin *) ebin, muxer);
+
+    /* 2. Ghost the muxer source pad */
+
+    /* FIXME : We should figure out if it's a static/request/dyamic pad, 
+     * but for the time being let's assume it's a static pad :) */
+    muxerpad = gst_element_get_static_pad (muxer, "src");
+    if (G_UNLIKELY (muxerpad == NULL))
+      goto no_muxer_pad;
+
+    if (!gst_ghost_pad_set_target (GST_GHOST_PAD (ebin->srcpad), muxerpad))
+      goto no_muxer_ghost_pad;
+
+    gst_object_unref (muxerpad);
+    /* 3. Activate fixed presence streams */
+    profiles =
+        gst_encoding_container_profile_get_profiles
+        (GST_ENCODING_CONTAINER_PROFILE (ebin->profile));
+    for (tmp = profiles; tmp; tmp = tmp->next) {
+      sprof = (GstEncodingProfile *) tmp->data;
+
+      GST_DEBUG ("Trying stream profile with presence %d",
+          gst_encoding_profile_get_presence (sprof));
+
+      if (gst_encoding_profile_get_presence (sprof) != 0) {
+        if (G_UNLIKELY (_create_stream_group (ebin, sprof, NULL, NULL) == NULL))
+          goto stream_error;
+      }
+    }
+  } else {
+    if (G_UNLIKELY (_create_stream_group (ebin, ebin->profile, NULL,
+                NULL) == NULL))
+      goto stream_error;
+  }
+
+  return ret;
+
+no_muxer:
+  {
+    GST_WARNING ("No available muxer for %" GST_PTR_FORMAT,
+        gst_encoding_profile_get_format (ebin->profile));
+    /* missing plugin support */
+    gst_element_post_message (GST_ELEMENT_CAST (ebin),
+        gst_missing_encoder_message_new (GST_ELEMENT_CAST (ebin),
+            gst_encoding_profile_get_format (ebin->profile)));
+    GST_ELEMENT_ERROR (ebin, CORE, MISSING_PLUGIN, (NULL),
+        ("No available muxer for format %" GST_PTR_FORMAT,
+            gst_encoding_profile_get_format (ebin->profile)));
+    return FALSE;
+  }
+
+no_muxer_pad:
+  {
+    GST_WARNING ("Can't get source pad from muxer (%s)",
+        GST_ELEMENT_NAME (muxer));
+    gst_bin_remove (GST_BIN (ebin), muxer);
+    return FALSE;
+  }
+
+no_muxer_ghost_pad:
+  {
+    GST_WARNING ("Couldn't set %s:%s as source ghostpad target",
+        GST_DEBUG_PAD_NAME (muxerpad));
+    gst_bin_remove (GST_BIN (ebin), muxer);
+    gst_object_unref (muxerpad);
+    return FALSE;
+  }
+
+stream_error:
+  {
+    GST_WARNING ("Could not create Streams");
+    if (muxer)
+      gst_bin_remove (GST_BIN (ebin), muxer);
+    ebin->muxer = NULL;
+    return FALSE;
+  }
+}
+
+static void
+release_pads (GstPad * pad, GstElement * elt)
+{
+  GstPad *peer = NULL;
+
+  GST_DEBUG_OBJECT (elt, "Releasing pad %s:%s", GST_DEBUG_PAD_NAME (pad));
+
+  /* Unlink from its peer pad */
+  if ((peer = gst_pad_get_peer (pad))) {
+    if (GST_PAD_DIRECTION (peer) == GST_PAD_SRC)
+      gst_pad_unlink (peer, pad);
+    else
+      gst_pad_unlink (pad, peer);
+    gst_object_unref (peer);
+  }
+
+  /* Release it from the object */
+  gst_element_release_request_pad (elt, pad);
+
+  /* And remove the reference added by the iterator */
+  gst_object_unref (pad);
+}
+
+static void inline
+stream_group_free (GstEncodeBin * ebin, StreamGroup * sgroup)
+{
+  GList *tmp;
+  GstPad *tmppad;
+  GstPad *pad;
+
+  GST_DEBUG_OBJECT (ebin, "Freeing StreamGroup %p", sgroup);
+
+  if (ebin->muxer) {
+    /* outqueue - Muxer */
+    tmppad = gst_element_get_static_pad (sgroup->outqueue, "src");
+    pad = gst_pad_get_peer (tmppad);
+
+    /* Remove muxer request sink pad */
+    gst_pad_unlink (tmppad, pad);
+    gst_element_release_request_pad (ebin->muxer, pad);
+    gst_object_unref (tmppad);
+    gst_object_unref (pad);
+  }
+  if (sgroup->outqueue)
+    gst_element_set_state (sgroup->outqueue, GST_STATE_NULL);
+
+  /* Capsfilter - outqueue */
+  gst_element_set_state (sgroup->outfilter, GST_STATE_NULL);
+  gst_element_unlink (sgroup->outfilter, sgroup->outqueue);
+  gst_bin_remove (GST_BIN (ebin), sgroup->outqueue);
+
+  /* streamcombiner - parser - capsfilter */
+  if (sgroup->parser) {
+    gst_element_set_state (sgroup->parser, GST_STATE_NULL);
+    gst_element_unlink (sgroup->parser, sgroup->outfilter);
+    gst_element_unlink (sgroup->combiner, sgroup->parser);
+  }
+
+  /* Sink Ghostpad */
+  if (sgroup->ghostpad)
+    gst_element_remove_pad (GST_ELEMENT_CAST (ebin), sgroup->ghostpad);
+
+  if (sgroup->inqueue)
+    gst_element_set_state (sgroup->inqueue, GST_STATE_NULL);
+
+  if (sgroup->encoder)
+    gst_element_set_state (sgroup->encoder, GST_STATE_NULL);
+  if (sgroup->outfilter)
+    gst_element_set_state (sgroup->outfilter, GST_STATE_NULL);
+  if (sgroup->smartencoder)
+    gst_element_set_state (sgroup->smartencoder, GST_STATE_NULL);
+
+  if (sgroup->capsfilter) {
+    gst_element_set_state (sgroup->capsfilter, GST_STATE_NULL);
+    gst_element_unlink (sgroup->capsfilter, sgroup->encoder);
+    gst_bin_remove ((GstBin *) ebin, sgroup->capsfilter);
+  }
+
+  for (tmp = sgroup->converters; tmp; tmp = tmp->next) {
+    GstElement *elt = (GstElement *) tmp->data;
+
+    gst_element_set_state (elt, GST_STATE_NULL);
+    gst_bin_remove ((GstBin *) ebin, elt);
+  }
+  if (sgroup->converters)
+    g_list_free (sgroup->converters);
+
+  if (sgroup->combiner) {
+    GstIterator *it = gst_element_iterate_sink_pads (sgroup->combiner);
+    GstIteratorResult itret = GST_ITERATOR_OK;
+
+    while (itret == GST_ITERATOR_OK || itret == GST_ITERATOR_RESYNC) {
+      itret = gst_iterator_foreach (it, (GFunc) release_pads, sgroup->combiner);
+      gst_iterator_resync (it);
+    }
+    gst_iterator_free (it);
+  }
+
+  if (sgroup->splitter) {
+    GstIterator *it = gst_element_iterate_src_pads (sgroup->splitter);
+    GstIteratorResult itret = GST_ITERATOR_OK;
+    while (itret == GST_ITERATOR_OK || itret == GST_ITERATOR_RESYNC) {
+      itret = gst_iterator_foreach (it, (GFunc) release_pads, sgroup->splitter);
+      gst_iterator_resync (it);
+    }
+    gst_iterator_free (it);
+  }
+
+  if (sgroup->inqueue)
+    gst_bin_remove ((GstBin *) ebin, sgroup->inqueue);
+  if (sgroup->encoder)
+    gst_bin_remove ((GstBin *) ebin, sgroup->encoder);
+  if (sgroup->smartencoder)
+    gst_bin_remove ((GstBin *) ebin, sgroup->smartencoder);
+
+  g_slice_free (StreamGroup, sgroup);
+}
+
+static void
+stream_group_remove (GstEncodeBin * ebin, StreamGroup * sgroup)
+{
+  ebin->streams = g_list_remove (ebin->streams, sgroup);
+
+  stream_group_free (ebin, sgroup);
+}
+
+static void
+gst_encode_bin_tear_down_profile (GstEncodeBin * ebin)
+{
+  if (G_UNLIKELY (ebin->profile == NULL))
+    return;
+
+  GST_DEBUG ("Tearing down profile %s",
+      gst_encoding_profile_get_name (ebin->profile));
+
+  while (ebin->streams)
+    stream_group_remove (ebin, (StreamGroup *) ebin->streams->data);
+
+  /* Set ghostpad target to NULL */
+  gst_ghost_pad_set_target (GST_GHOST_PAD (ebin->srcpad), NULL);
+
+  /* Remove muxer if present */
+  if (ebin->muxer) {
+    gst_bin_remove (GST_BIN (ebin), ebin->muxer);
+    ebin->muxer = NULL;
+  }
+
+  /* free/clear profile */
+  gst_encoding_profile_unref (ebin->profile);
+  ebin->profile = NULL;
+}
+
+static gboolean
+gst_encode_bin_setup_profile (GstEncodeBin * ebin, GstEncodingProfile * profile)
+{
+  gboolean res;
+
+  g_return_val_if_fail (ebin->profile == NULL, FALSE);
+
+  GST_DEBUG ("Setting up profile %s (type:%s)",
+      gst_encoding_profile_get_name (profile),
+      gst_encoding_profile_get_type_nick (profile));
+
+  ebin->profile = profile;
+  gst_mini_object_ref ((GstMiniObject *) ebin->profile);
+
+  /* Create elements */
+  res = create_elements_and_pads (ebin);
+  if (res == FALSE)
+    gst_encode_bin_tear_down_profile (ebin);
+
+  return res;
+}
+
+static gboolean
+gst_encode_bin_set_profile (GstEncodeBin * ebin, GstEncodingProfile * profile)
+{
+  g_return_val_if_fail (GST_IS_ENCODING_PROFILE (profile), FALSE);
+
+  GST_DEBUG_OBJECT (ebin, "profile : %s",
+      gst_encoding_profile_get_name (profile));
+
+  if (G_UNLIKELY (ebin->active)) {
+    GST_WARNING_OBJECT (ebin, "Element already active, can't change profile");
+    return FALSE;
+  }
+
+  /* If we're not active, we can deactivate the previous profile */
+  if (ebin->profile) {
+    gst_encode_bin_tear_down_profile (ebin);
+  }
+
+  return gst_encode_bin_setup_profile (ebin, profile);
+}
+
+static inline gboolean
+gst_encode_bin_activate (GstEncodeBin * ebin)
+{
+  ebin->active = ebin->profile != NULL;
+  return ebin->active;
+}
+
+static void
+gst_encode_bin_deactivate (GstEncodeBin * ebin)
+{
+  ebin->active = FALSE;
+}
+
+static GstStateChangeReturn
+gst_encode_bin_change_state (GstElement * element, GstStateChange transition)
+{
+  GstStateChangeReturn ret;
+  GstEncodeBin *ebin = (GstEncodeBin *) element;
+
+  switch (transition) {
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+    case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
+      if (!gst_encode_bin_activate (ebin)) {
+        ret = GST_STATE_CHANGE_FAILURE;
+        goto beach;
+      }
+      break;
+    default:
+      break;
+  }
+
+  ret =
+      GST_ELEMENT_CLASS (gst_encode_bin_parent_class)->change_state (element,
+      transition);
+  if (ret == GST_STATE_CHANGE_FAILURE)
+    goto beach;
+
+  switch (transition) {
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      gst_encode_bin_deactivate (ebin);
+      break;
+    default:
+      break;
+  }
+
+beach:
+  return ret;
+}
+
+
+static gboolean
+plugin_init (GstPlugin * plugin)
+{
+  gboolean res;
+
+  GST_DEBUG_CATEGORY_INIT (gst_encode_bin_debug, "encodebin", 0, "encoder bin");
+
+#ifdef ENABLE_NLS
+  GST_DEBUG ("binding text domain %s to locale dir %s", GETTEXT_PACKAGE,
+      LOCALEDIR);
+  bindtextdomain (GETTEXT_PACKAGE, LOCALEDIR);
+  bind_textdomain_codeset (GETTEXT_PACKAGE, "UTF-8");
+#endif /* ENABLE_NLS */
+
+
+  res = gst_element_register (plugin, "encodebin", GST_RANK_NONE,
+      GST_TYPE_ENCODE_BIN);
+
+  return res;
+}
+
+GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
+    GST_VERSION_MINOR,
+    "encoding",
+    "various encoding-related elements", plugin_init, VERSION, GST_LICENSE,
+    GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
diff --git a/gst/encoding/gstencodebin.h b/gst/encoding/gstencodebin.h
new file mode 100644
index 0000000..2d594b0
--- /dev/null
+++ b/gst/encoding/gstencodebin.h
@@ -0,0 +1,39 @@
+/* GStreamer encoding bin
+ * Copyright (C) 2009 Edward Hervey <edward.hervey@collabora.co.uk>
+ *           (C) 2009 Nokia Corporation
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_ENCODEBIN_H__
+#define __GST_ENCODEBIN_H__
+
+#include <gst/gst.h>
+#include <gst/pbutils/pbutils.h>
+#include "gstencode-marshal.h"
+
+#define GST_TYPE_ENCODE_BIN               (gst_encode_bin_get_type())
+#define GST_ENCODE_BIN(obj)               (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ENCODE_BIN,GstEncodeBin))
+#define GST_ENCODE_BIN_CLASS(klass)       (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_ENCODE_BIN,GstEncodeBinClass))
+#define GST_IS_ENCODE_BIN(obj)            (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ENCODE_BIN))
+#define GST_IS_ENCODE_BIN_CLASS(klass)    (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_ENCODE_BIN))
+
+typedef struct _GstEncodeBin GstEncodeBin;
+typedef struct _GstEncodeBinClass GstEncodeBinClass;
+
+GType gst_encode_bin_get_type(void);
+
+#endif /* __GST_ENCODEBIN_H__ */
diff --git a/gst/encoding/gstsmartencoder.c b/gst/encoding/gstsmartencoder.c
new file mode 100644
index 0000000..ed0e42b
--- /dev/null
+++ b/gst/encoding/gstsmartencoder.c
@@ -0,0 +1,701 @@
+/* GStreamer Smart Video Encoder element
+ * Copyright (C) <2010> Edward Hervey <bilboed@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/* TODO:
+ * * Implement get_caps/set_caps (store/forward caps)
+ * * Adjust template caps to the formats we can support
+ **/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+#include "gstsmartencoder.h"
+
+GST_DEBUG_CATEGORY_STATIC (smart_encoder_debug);
+#define GST_CAT_DEFAULT smart_encoder_debug
+
+/* FIXME : Update this with new caps */
+/* WARNING : We can only allow formats with closed-GOP */
+#define ALLOWED_CAPS "video/x-h263;video/x-intel-h263;"\
+  "video/mpeg,mpegversion=(int)1,systemstream=(boolean)false;"\
+  "video/mpeg,mpegversion=(int)2,systemstream=(boolean)false;"
+
+static GstStaticPadTemplate src_template =
+GST_STATIC_PAD_TEMPLATE ("src", GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (ALLOWED_CAPS)
+    );
+
+static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (ALLOWED_CAPS)
+    );
+
+static GQuark INTERNAL_ELEMENT;
+
+/* GstSmartEncoder signals and args */
+enum
+{
+  /* FILL ME */
+  LAST_SIGNAL
+};
+
+enum
+{
+  ARG_0
+      /* FILL ME */
+};
+
+static void
+_do_init (void)
+{
+  INTERNAL_ELEMENT = g_quark_from_string ("internal-element");
+};
+
+G_DEFINE_TYPE_EXTENDED (GstSmartEncoder, gst_smart_encoder, GST_TYPE_ELEMENT, 0,
+    _do_init ());
+
+static void gst_smart_encoder_dispose (GObject * object);
+
+static gboolean setup_recoder_pipeline (GstSmartEncoder * smart_encoder);
+
+static GstFlowReturn gst_smart_encoder_chain (GstPad * pad, GstBuffer * buf);
+static gboolean smart_encoder_sink_event (GstPad * pad, GstEvent * event);
+static GstCaps *smart_encoder_sink_getcaps (GstPad * pad);
+static GstStateChangeReturn
+gst_smart_encoder_change_state (GstElement * element,
+    GstStateChange transition);
+
+static void
+gst_smart_encoder_class_init (GstSmartEncoderClass * klass)
+{
+  GObjectClass *gobject_class;
+  GstElementClass *element_class;
+
+  element_class = (GstElementClass *) klass;
+  gobject_class = G_OBJECT_CLASS (klass);
+
+  gst_smart_encoder_parent_class = g_type_class_peek_parent (klass);
+
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&src_template));
+  gst_element_class_add_pad_template (element_class,
+      gst_static_pad_template_get (&sink_template));
+
+  gst_element_class_set_details_simple (element_class, "Smart Video Encoder",
+      "Codec/Recoder/Video",
+      "Re-encodes portions of Video that lay on segment boundaries",
+      "Edward Hervey <bilboed@gmail.com>");
+
+  gobject_class->dispose = (GObjectFinalizeFunc) (gst_smart_encoder_dispose);
+  element_class->change_state = gst_smart_encoder_change_state;
+
+  GST_DEBUG_CATEGORY_INIT (smart_encoder_debug, "smartencoder", 0,
+      "Smart Encoder");
+}
+
+static void
+smart_encoder_reset (GstSmartEncoder * smart_encoder)
+{
+  gst_segment_init (smart_encoder->segment, GST_FORMAT_UNDEFINED);
+
+  if (smart_encoder->encoder) {
+    /* Clean up/remove elements */
+    gst_element_set_state (smart_encoder->encoder, GST_STATE_NULL);
+    gst_element_set_state (smart_encoder->decoder, GST_STATE_NULL);
+    gst_element_set_bus (smart_encoder->encoder, NULL);
+    gst_element_set_bus (smart_encoder->decoder, NULL);
+    gst_pad_set_active (smart_encoder->internal_srcpad, FALSE);
+    gst_pad_set_active (smart_encoder->internal_sinkpad, FALSE);
+    gst_object_unref (smart_encoder->encoder);
+    gst_object_unref (smart_encoder->decoder);
+    gst_object_unref (smart_encoder->internal_srcpad);
+    gst_object_unref (smart_encoder->internal_sinkpad);
+
+    smart_encoder->encoder = NULL;
+    smart_encoder->decoder = NULL;
+    smart_encoder->internal_sinkpad = NULL;
+    smart_encoder->internal_srcpad = NULL;
+  }
+
+  if (smart_encoder->newsegment) {
+    gst_event_unref (smart_encoder->newsegment);
+    smart_encoder->newsegment = NULL;
+  }
+}
+
+
+static void
+gst_smart_encoder_init (GstSmartEncoder * smart_encoder)
+{
+  smart_encoder->sinkpad =
+      gst_pad_new_from_static_template (&sink_template, "sink");
+  gst_pad_set_chain_function (smart_encoder->sinkpad, gst_smart_encoder_chain);
+  gst_pad_set_event_function (smart_encoder->sinkpad, smart_encoder_sink_event);
+  gst_pad_set_getcaps_function (smart_encoder->sinkpad,
+      smart_encoder_sink_getcaps);
+  gst_element_add_pad (GST_ELEMENT (smart_encoder), smart_encoder->sinkpad);
+
+  smart_encoder->srcpad =
+      gst_pad_new_from_static_template (&src_template, "src");
+  gst_pad_use_fixed_caps (smart_encoder->srcpad);
+  gst_element_add_pad (GST_ELEMENT (smart_encoder), smart_encoder->srcpad);
+
+  smart_encoder->segment = gst_segment_new ();
+
+  smart_encoder_reset (smart_encoder);
+}
+
+void
+gst_smart_encoder_dispose (GObject * object)
+{
+  GstSmartEncoder *smart_encoder = (GstSmartEncoder *) object;
+
+  if (smart_encoder->segment)
+    gst_segment_free (smart_encoder->segment);
+  smart_encoder->segment = NULL;
+  if (smart_encoder->available_caps)
+    gst_caps_unref (smart_encoder->available_caps);
+  smart_encoder->available_caps = NULL;
+  G_OBJECT_CLASS (gst_smart_encoder_parent_class)->dispose (object);
+}
+
+static GstFlowReturn
+gst_smart_encoder_reencode_gop (GstSmartEncoder * smart_encoder)
+{
+  GstFlowReturn res = GST_FLOW_OK;
+  GList *tmp;
+
+  if (smart_encoder->encoder == NULL) {
+    if (!setup_recoder_pipeline (smart_encoder))
+      return GST_FLOW_ERROR;
+  }
+
+  /* Activate elements */
+  /* Set elements to PAUSED */
+  gst_element_set_state (smart_encoder->encoder, GST_STATE_PAUSED);
+  gst_element_set_state (smart_encoder->decoder, GST_STATE_PAUSED);
+
+  GST_INFO ("Pushing Flush start/stop to clean decoder/encoder");
+  gst_pad_push_event (smart_encoder->internal_srcpad,
+      gst_event_new_flush_start ());
+  gst_pad_push_event (smart_encoder->internal_srcpad,
+      gst_event_new_flush_stop ());
+
+  /* push newsegment */
+  GST_INFO ("Pushing newsegment %" GST_PTR_FORMAT, smart_encoder->newsegment);
+  gst_pad_push_event (smart_encoder->internal_srcpad,
+      gst_event_ref (smart_encoder->newsegment));
+
+  /* Push buffers through our pads */
+  GST_DEBUG ("Pushing pending buffers");
+
+  for (tmp = smart_encoder->pending_gop; tmp; tmp = tmp->next) {
+    GstBuffer *buf = (GstBuffer *) tmp->data;
+
+    res = gst_pad_push (smart_encoder->internal_srcpad, buf);
+    if (G_UNLIKELY (res != GST_FLOW_OK))
+      break;
+  }
+
+  if (G_UNLIKELY (res != GST_FLOW_OK)) {
+    GST_WARNING ("Error pushing pending buffers : %s", gst_flow_get_name (res));
+    /* Remove pending bfufers */
+    for (tmp = smart_encoder->pending_gop; tmp; tmp = tmp->next) {
+      gst_buffer_unref ((GstBuffer *) tmp->data);
+    }
+  } else {
+    GST_INFO ("Pushing out EOS to flush out decoder/encoder");
+    gst_pad_push_event (smart_encoder->internal_srcpad, gst_event_new_eos ());
+  }
+
+  /* Activate elements */
+  /* Set elements to PAUSED */
+  gst_element_set_state (smart_encoder->encoder, GST_STATE_NULL);
+  gst_element_set_state (smart_encoder->decoder, GST_STATE_NULL);
+
+  g_list_free (smart_encoder->pending_gop);
+  smart_encoder->pending_gop = NULL;
+
+  return res;
+}
+
+static GstFlowReturn
+gst_smart_encoder_push_pending_gop (GstSmartEncoder * smart_encoder)
+{
+  gint64 cstart, cstop;
+  GList *tmp;
+  GstFlowReturn res = GST_FLOW_OK;
+
+  GST_DEBUG ("Pushing pending GOP (%" GST_TIME_FORMAT " -- %" GST_TIME_FORMAT
+      ")", GST_TIME_ARGS (smart_encoder->gop_start),
+      GST_TIME_ARGS (smart_encoder->gop_stop));
+
+  /* If GOP is entirely within segment, just push downstream */
+  if (gst_segment_clip (smart_encoder->segment, GST_FORMAT_TIME,
+          smart_encoder->gop_start, smart_encoder->gop_stop, &cstart, &cstop)) {
+    if ((cstart != smart_encoder->gop_start)
+        || (cstop != smart_encoder->gop_stop)) {
+      GST_DEBUG ("GOP needs to be re-encoded from %" GST_TIME_FORMAT " to %"
+          GST_TIME_FORMAT, GST_TIME_ARGS (cstart), GST_TIME_ARGS (cstop));
+      res = gst_smart_encoder_reencode_gop (smart_encoder);
+    } else {
+      /* The whole GOP is within the segment, push all pending buffers downstream */
+      GST_DEBUG ("GOP doesn't need to be modified, pushing downstream");
+      for (tmp = smart_encoder->pending_gop; tmp; tmp = tmp->next) {
+        GstBuffer *buf = (GstBuffer *) tmp->data;
+        res = gst_pad_push (smart_encoder->srcpad, buf);
+        if (G_UNLIKELY (res != GST_FLOW_OK))
+          break;
+      }
+    }
+  } else {
+    /* The whole GOP is outside the segment, there's most likely
+     * a bug somewhere. */
+    GST_WARNING
+        ("GOP is entirely outside of the segment, upstream gave us too much data");
+    for (tmp = smart_encoder->pending_gop; tmp; tmp = tmp->next) {
+      gst_buffer_unref ((GstBuffer *) tmp->data);
+    }
+  }
+
+  if (smart_encoder->pending_gop) {
+    g_list_free (smart_encoder->pending_gop);
+    smart_encoder->pending_gop = NULL;
+  }
+  smart_encoder->gop_start = GST_CLOCK_TIME_NONE;
+  smart_encoder->gop_stop = GST_CLOCK_TIME_NONE;
+
+  return res;
+}
+
+static GstFlowReturn
+gst_smart_encoder_chain (GstPad * pad, GstBuffer * buf)
+{
+  GstSmartEncoder *smart_encoder;
+  GstFlowReturn res = GST_FLOW_OK;
+  gboolean discont, keyframe;
+
+  smart_encoder = GST_SMART_ENCODER (gst_object_get_parent (GST_OBJECT (pad)));
+
+  discont = GST_BUFFER_IS_DISCONT (buf);
+  keyframe = !GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT);
+
+  GST_DEBUG ("New buffer %s %s %" GST_TIME_FORMAT,
+      discont ? "discont" : "",
+      keyframe ? "keyframe" : "", GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)));
+
+  if (keyframe) {
+    GST_DEBUG ("Got a keyframe");
+
+    /* If there's a pending GOP, flush it out */
+    if (smart_encoder->pending_gop) {
+      /* Mark gop_stop */
+      smart_encoder->gop_stop = GST_BUFFER_TIMESTAMP (buf);
+
+      /* flush pending */
+      res = gst_smart_encoder_push_pending_gop (smart_encoder);
+      if (G_UNLIKELY (res != GST_FLOW_OK))
+        goto beach;
+    }
+
+    /* Mark gop_start for new gop */
+    smart_encoder->gop_start = GST_BUFFER_TIMESTAMP (buf);
+  }
+
+  /* Store buffer */
+  smart_encoder->pending_gop = g_list_append (smart_encoder->pending_gop, buf);
+  /* Update GOP stop position */
+  if (GST_BUFFER_TIMESTAMP_IS_VALID (buf)) {
+    smart_encoder->gop_stop = GST_BUFFER_TIMESTAMP (buf);
+    if (GST_BUFFER_DURATION_IS_VALID (buf))
+      smart_encoder->gop_stop += GST_BUFFER_DURATION (buf);
+  }
+
+  GST_DEBUG ("Buffer stored , Current GOP : %" GST_TIME_FORMAT " -- %"
+      GST_TIME_FORMAT, GST_TIME_ARGS (smart_encoder->gop_start),
+      GST_TIME_ARGS (smart_encoder->gop_stop));
+
+beach:
+  gst_object_unref (smart_encoder);
+  return res;
+}
+
+static gboolean
+smart_encoder_sink_event (GstPad * pad, GstEvent * event)
+{
+  gboolean res = TRUE;
+  GstSmartEncoder *smart_encoder = GST_SMART_ENCODER (gst_pad_get_parent (pad));
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_FLUSH_STOP:
+      smart_encoder_reset (smart_encoder);
+      break;
+    case GST_EVENT_NEWSEGMENT:
+    {
+      GstFormat format;
+      gdouble rate, arate;
+      gint64 start, stop, time;
+      gboolean update;
+
+      gst_event_parse_new_segment_full (event, &update, &rate, &arate, &format,
+          &start, &stop, &time);
+      GST_DEBUG_OBJECT (smart_encoder,
+          "newsegment: update %d, rate %g, arate %g, start %" GST_TIME_FORMAT
+          ", stop %" GST_TIME_FORMAT ", time %" GST_TIME_FORMAT,
+          update, rate, arate, GST_TIME_ARGS (start), GST_TIME_ARGS (stop),
+          GST_TIME_ARGS (time));
+      if (format != GST_FORMAT_TIME)
+        GST_ERROR
+            ("smart_encoder can not handle streams not specified in GST_FORMAT_TIME");
+
+      /* now configure the values */
+      gst_segment_set_newsegment_full (smart_encoder->segment, update,
+          rate, arate, format, start, stop, time);
+
+      /* And keep a copy for further usage */
+      if (smart_encoder->newsegment)
+        gst_event_unref (smart_encoder->newsegment);
+      smart_encoder->newsegment = gst_event_ref (event);
+    }
+      break;
+    case GST_EVENT_EOS:
+      GST_DEBUG ("Eos, flushing remaining data");
+      gst_smart_encoder_push_pending_gop (smart_encoder);
+      break;
+    default:
+      break;
+  }
+
+  res = gst_pad_push_event (smart_encoder->srcpad, event);
+
+  gst_object_unref (smart_encoder);
+  return res;
+}
+
+static GstCaps *
+smart_encoder_sink_getcaps (GstPad * pad)
+{
+  GstCaps *peer, *tmpl, *res;
+  GstSmartEncoder *smart_encoder = GST_SMART_ENCODER (gst_pad_get_parent (pad));
+
+  /* Try getting it from downstream */
+  peer = gst_pad_peer_get_caps_reffed (smart_encoder->srcpad);
+
+  /* Use computed caps */
+  if (smart_encoder->available_caps)
+    tmpl = gst_caps_ref (smart_encoder->available_caps);
+  else
+    tmpl = gst_static_pad_template_get_caps (&src_template);
+
+  if (peer == NULL) {
+    res = tmpl;
+  } else {
+    res = gst_caps_intersect (peer, tmpl);
+    gst_caps_unref (peer);
+    gst_caps_unref (tmpl);
+  }
+
+  gst_object_unref (smart_encoder);
+  return res;
+}
+
+/*****************************************
+ *    Internal encoder/decoder pipeline  *
+ ******************************************/
+
+static GstElementFactory *
+get_decoder_factory (GstCaps * caps)
+{
+  GstElementFactory *fact = NULL;
+  GList *decoders, *tmp;
+
+  tmp =
+      gst_element_factory_list_get_elements (GST_ELEMENT_FACTORY_TYPE_DECODER,
+      GST_RANK_MARGINAL);
+  decoders = gst_element_factory_list_filter (tmp, caps, GST_PAD_SINK, FALSE);
+  gst_plugin_feature_list_free (tmp);
+
+  for (tmp = decoders; tmp; tmp = tmp->next) {
+    /* We just pick the first one */
+    fact = (GstElementFactory *) tmp->data;
+    gst_object_ref (fact);
+    break;
+  }
+
+  gst_plugin_feature_list_free (decoders);
+
+  return fact;
+}
+
+static GstElementFactory *
+get_encoder_factory (GstCaps * caps)
+{
+  GstElementFactory *fact = NULL;
+  GList *encoders, *tmp;
+
+  tmp =
+      gst_element_factory_list_get_elements (GST_ELEMENT_FACTORY_TYPE_ENCODER,
+      GST_RANK_MARGINAL);
+  encoders = gst_element_factory_list_filter (tmp, caps, GST_PAD_SRC, FALSE);
+  gst_plugin_feature_list_free (tmp);
+
+  for (tmp = encoders; tmp; tmp = tmp->next) {
+    /* We just pick the first one */
+    fact = (GstElementFactory *) tmp->data;
+    gst_object_ref (fact);
+    break;
+  }
+
+  gst_plugin_feature_list_free (encoders);
+
+  return fact;
+}
+
+static GstElement *
+get_decoder (GstCaps * caps)
+{
+  GstElementFactory *fact = get_decoder_factory (caps);
+  GstElement *res = NULL;
+
+  if (fact) {
+    res = gst_element_factory_create (fact, "internal-decoder");
+    gst_object_unref (fact);
+  }
+  return res;
+}
+
+static GstElement *
+get_encoder (GstCaps * caps)
+{
+  GstElementFactory *fact = get_encoder_factory (caps);
+  GstElement *res = NULL;
+
+  if (fact) {
+    res = gst_element_factory_create (fact, "internal-encoder");
+    gst_object_unref (fact);
+  }
+  return res;
+}
+
+static GstFlowReturn
+internal_chain (GstPad * pad, GstBuffer * buf)
+{
+  GstSmartEncoder *smart_encoder =
+      g_object_get_qdata ((GObject *) pad, INTERNAL_ELEMENT);
+
+  return gst_pad_push (smart_encoder->srcpad, buf);
+}
+
+static gboolean
+setup_recoder_pipeline (GstSmartEncoder * smart_encoder)
+{
+  GstPad *tmppad;
+
+  /* Fast path */
+  if (G_UNLIKELY (smart_encoder->encoder))
+    return TRUE;
+
+  GST_DEBUG ("Creating internal decoder and encoder");
+
+  /* Create decoder/encoder */
+  smart_encoder->decoder = get_decoder (GST_PAD_CAPS (smart_encoder->sinkpad));
+  if (G_UNLIKELY (smart_encoder->decoder == NULL))
+    goto no_decoder;
+  gst_element_set_bus (smart_encoder->decoder, GST_ELEMENT_BUS (smart_encoder));
+
+  smart_encoder->encoder = get_encoder (GST_PAD_CAPS (smart_encoder->sinkpad));
+  if (G_UNLIKELY (smart_encoder->encoder == NULL))
+    goto no_encoder;
+  gst_element_set_bus (smart_encoder->encoder, GST_ELEMENT_BUS (smart_encoder));
+
+  GST_DEBUG ("Creating internal pads");
+
+  /* Create internal pads */
+
+  /* Source pad which we'll use to feed data to decoders */
+  smart_encoder->internal_srcpad = gst_pad_new ("internal_src", GST_PAD_SRC);
+  g_object_set_qdata ((GObject *) smart_encoder->internal_srcpad,
+      INTERNAL_ELEMENT, smart_encoder);
+  gst_pad_set_caps (smart_encoder->internal_srcpad,
+      GST_PAD_CAPS (smart_encoder->sinkpad));
+  gst_pad_set_active (smart_encoder->internal_srcpad, TRUE);
+
+  /* Sink pad which will get the buffers from the encoder.
+   * Note: We don't need an event function since we'll be discarding all
+   * of them. */
+  smart_encoder->internal_sinkpad = gst_pad_new ("internal_sink", GST_PAD_SINK);
+  g_object_set_qdata ((GObject *) smart_encoder->internal_sinkpad,
+      INTERNAL_ELEMENT, smart_encoder);
+  gst_pad_set_caps (smart_encoder->internal_sinkpad,
+      GST_PAD_CAPS (smart_encoder->sinkpad));
+  gst_pad_set_chain_function (smart_encoder->internal_sinkpad, internal_chain);
+  gst_pad_set_active (smart_encoder->internal_sinkpad, TRUE);
+
+  GST_DEBUG ("Linking pads to elements");
+
+  /* Link everything */
+  tmppad = gst_element_get_static_pad (smart_encoder->encoder, "src");
+  if (GST_PAD_LINK_FAILED (gst_pad_link (tmppad,
+              smart_encoder->internal_sinkpad)))
+    goto sinkpad_link_fail;
+  gst_object_unref (tmppad);
+
+  if (!gst_element_link (smart_encoder->decoder, smart_encoder->encoder))
+    goto encoder_decoder_link_fail;
+
+  tmppad = gst_element_get_static_pad (smart_encoder->decoder, "sink");
+  if (GST_PAD_LINK_FAILED (gst_pad_link (smart_encoder->internal_srcpad,
+              tmppad)))
+    goto srcpad_link_fail;
+  gst_object_unref (tmppad);
+
+  GST_DEBUG ("Done creating internal elements/pads");
+
+  return TRUE;
+
+no_decoder:
+  {
+    GST_WARNING ("Couldn't find a decoder for %" GST_PTR_FORMAT,
+        GST_PAD_CAPS (smart_encoder->sinkpad));
+    return FALSE;
+  }
+
+no_encoder:
+  {
+    GST_WARNING ("Couldn't find an encoder for %" GST_PTR_FORMAT,
+        GST_PAD_CAPS (smart_encoder->sinkpad));
+    return FALSE;
+  }
+
+srcpad_link_fail:
+  {
+    gst_object_unref (tmppad);
+    GST_WARNING ("Couldn't link internal srcpad to decoder");
+    return FALSE;
+  }
+
+sinkpad_link_fail:
+  {
+    gst_object_unref (tmppad);
+    GST_WARNING ("Couldn't link encoder to internal sinkpad");
+    return FALSE;
+  }
+
+encoder_decoder_link_fail:
+  {
+    GST_WARNING ("Couldn't link decoder to encoder");
+    return FALSE;
+  }
+}
+
+static GstStateChangeReturn
+gst_smart_encoder_find_elements (GstSmartEncoder * smart_encoder)
+{
+  guint i, n;
+  GstCaps *tmpl, *st, *res;
+  GstElementFactory *dec, *enc;
+  GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
+
+  if (G_UNLIKELY (smart_encoder->available_caps))
+    goto beach;
+
+  /* Iterate over all pad template caps and see if we have both an
+   * encoder and a decoder for those media types */
+  tmpl = gst_static_pad_template_get_caps (&src_template);
+  res = gst_caps_new_empty ();
+  n = gst_caps_get_size (tmpl);
+
+  for (i = 0; i < n; i++) {
+    st = gst_caps_copy_nth (tmpl, i);
+    GST_DEBUG_OBJECT (smart_encoder,
+        "Checking for available decoder and encoder for %" GST_PTR_FORMAT, st);
+    if (!(dec = get_decoder_factory (st))) {
+      gst_caps_unref (st);
+      continue;
+    }
+    gst_object_unref (dec);
+    if (!(enc = get_encoder_factory (st))) {
+      gst_caps_unref (st);
+      continue;
+    }
+    gst_object_unref (enc);
+    GST_DEBUG_OBJECT (smart_encoder, "OK");
+    gst_caps_append (res, st);
+  }
+
+  gst_caps_unref (tmpl);
+
+  if (gst_caps_is_empty (res))
+    ret = GST_STATE_CHANGE_FAILURE;
+  else
+    smart_encoder->available_caps = res;
+
+  GST_DEBUG_OBJECT (smart_encoder, "Done, available_caps:%" GST_PTR_FORMAT,
+      smart_encoder->available_caps);
+
+beach:
+  return ret;
+}
+
+/******************************************
+ *    GstElement vmethod implementations  *
+ ******************************************/
+
+static GstStateChangeReturn
+gst_smart_encoder_change_state (GstElement * element, GstStateChange transition)
+{
+  GstSmartEncoder *smart_encoder;
+  GstStateChangeReturn ret;
+
+  g_return_val_if_fail (GST_IS_SMART_ENCODER (element),
+      GST_STATE_CHANGE_FAILURE);
+
+  smart_encoder = GST_SMART_ENCODER (element);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_NULL_TO_READY:
+      /* Figure out which elements are available  */
+      if ((ret =
+              gst_smart_encoder_find_elements (smart_encoder)) ==
+          GST_STATE_CHANGE_FAILURE)
+        goto beach;
+      break;
+    default:
+      break;
+  }
+
+  ret =
+      GST_ELEMENT_CLASS (gst_smart_encoder_parent_class)->change_state (element,
+      transition);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      smart_encoder_reset (smart_encoder);
+      break;
+    default:
+      break;
+  }
+
+beach:
+  return ret;
+}
diff --git a/gst/encoding/gstsmartencoder.h b/gst/encoding/gstsmartencoder.h
new file mode 100644
index 0000000..1536626
--- /dev/null
+++ b/gst/encoding/gstsmartencoder.h
@@ -0,0 +1,71 @@
+/* GStreamer video re-encoder element
+ * Copyright (C) <2010> Edward Hervey <bilboed@bilboed.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+#ifndef __SMART_ENCODER_H__
+#define __SMART_ENCODER_H__
+
+#include <gst/gst.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_SMART_ENCODER \
+  (gst_smart_encoder_get_type())
+#define GST_SMART_ENCODER(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_SMART_ENCODER,GstSmartEncoder))
+#define GST_SMART_ENCODER_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_SMART_ENCODER,GstSmartEncoderClass))
+#define GST_IS_SMART_ENCODER(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_SMART_ENCODER))
+#define GST_IS_SMART_ENCODER_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_SMART_ENCODER))
+
+typedef struct _GstSmartEncoder GstSmartEncoder;
+typedef struct _GstSmartEncoderClass GstSmartEncoderClass;
+
+struct _GstSmartEncoder {
+  GstElement element;
+
+  GstPad *sinkpad, *srcpad;
+
+  GstSegment *segment;
+  GstEvent *newsegment;
+
+  /* Pending GOP to be checked */
+  GList *pending_gop;
+  guint64 gop_start;		/* GOP start in running time */
+  guint64 gop_stop;		/* GOP end in running time */
+
+  /* Internal recoding elements */
+  GstPad *internal_sinkpad;
+  GstPad *internal_srcpad;
+  GstElement *decoder;
+  GstElement *encoder;
+
+  /* Available caps at runtime */
+  GstCaps *available_caps;
+};
+
+struct _GstSmartEncoderClass {
+  GstElementClass parent_class;
+};
+
+GType gst_smart_encoder_get_type(void);
+
+G_END_DECLS
+
+#endif /* __SMART_ENCODER_H__ */
diff --git a/gst/encoding/gststreamcombiner.c b/gst/encoding/gststreamcombiner.c
new file mode 100644
index 0000000..72d40fe
--- /dev/null
+++ b/gst/encoding/gststreamcombiner.c
@@ -0,0 +1,276 @@
+/* GStreamer Stream Combiner
+ * Copyright (C) 2010 Edward Hervey <edward.hervey@collabora.co.uk>
+ *           (C) 2009 Nokia Corporation
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gststreamcombiner.h"
+
+static GstStaticPadTemplate src_template =
+GST_STATIC_PAD_TEMPLATE ("src", GST_PAD_SRC, GST_PAD_ALWAYS,
+    GST_STATIC_CAPS_ANY);
+
+static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink_%d",
+    GST_PAD_SINK,
+    GST_PAD_REQUEST,
+    GST_STATIC_CAPS_ANY);
+
+GST_DEBUG_CATEGORY_STATIC (gst_stream_combiner_debug);
+#define GST_CAT_DEFAULT gst_stream_combiner_debug
+
+G_DEFINE_TYPE (GstStreamCombiner, gst_stream_combiner, GST_TYPE_ELEMENT);
+
+#define STREAMS_LOCK(obj) (g_mutex_lock(obj->lock))
+#define STREAMS_UNLOCK(obj) (g_mutex_unlock(obj->lock))
+
+static void gst_stream_combiner_dispose (GObject * object);
+
+static GstPad *gst_stream_combiner_request_new_pad (GstElement * element,
+    GstPadTemplate * templ, const gchar * name);
+static void gst_stream_combiner_release_pad (GstElement * element,
+    GstPad * pad);
+
+static void
+gst_stream_combiner_class_init (GstStreamCombinerClass * klass)
+{
+  GObjectClass *gobject_klass;
+  GstElementClass *gstelement_klass;
+
+  gobject_klass = (GObjectClass *) klass;
+  gstelement_klass = (GstElementClass *) klass;
+
+  gobject_klass->dispose = gst_stream_combiner_dispose;
+
+  GST_DEBUG_CATEGORY_INIT (gst_stream_combiner_debug, "streamcombiner", 0,
+      "Stream Combiner");
+
+  gst_element_class_add_pad_template (gstelement_klass,
+      gst_static_pad_template_get (&src_template));
+  gst_element_class_add_pad_template (gstelement_klass,
+      gst_static_pad_template_get (&sink_template));
+
+  gstelement_klass->request_new_pad =
+      GST_DEBUG_FUNCPTR (gst_stream_combiner_request_new_pad);
+  gstelement_klass->release_pad =
+      GST_DEBUG_FUNCPTR (gst_stream_combiner_release_pad);
+
+  gst_element_class_set_details_simple (gstelement_klass,
+      "streamcombiner", "Generic",
+      "Recombines streams splitted by the streamsplitter element",
+      "Edward Hervey <edward.hervey@collabora.co.uk>");
+}
+
+static void
+gst_stream_combiner_dispose (GObject * object)
+{
+  GstStreamCombiner *stream_combiner = (GstStreamCombiner *) object;
+
+  if (stream_combiner->lock) {
+    g_mutex_free (stream_combiner->lock);
+    stream_combiner->lock = NULL;
+  }
+
+  G_OBJECT_CLASS (gst_stream_combiner_parent_class)->dispose (object);
+}
+
+static GstFlowReturn
+gst_stream_combiner_chain (GstPad * pad, GstBuffer * buf)
+{
+  GstStreamCombiner *stream_combiner =
+      (GstStreamCombiner *) GST_PAD_PARENT (pad);
+  /* FIXME : IMPLEMENT */
+
+  /* with lock taken, check if we're the active stream, if not drop */
+  return gst_pad_push (stream_combiner->srcpad, buf);
+}
+
+static gboolean
+gst_stream_combiner_sink_event (GstPad * pad, GstEvent * event)
+{
+  GstStreamCombiner *stream_combiner =
+      (GstStreamCombiner *) GST_PAD_PARENT (pad);
+  /* FIXME : IMPLEMENT */
+
+  GST_DEBUG_OBJECT (pad, "Got event %s", GST_EVENT_TYPE_NAME (event));
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_CUSTOM_DOWNSTREAM:
+      if (gst_event_has_name (event, "stream-switching-eos")) {
+        gst_event_unref (event);
+        event = gst_event_new_eos ();
+      }
+      break;
+    default:
+      break;
+  }
+
+  /* NEW_SEGMENT : lock, wait for other stream to EOS, select stream, unlock, push */
+  /* EOS : lock, mark pad as unused, unlock , drop event */
+  /* CUSTOM_REAL_EOS : push EOS downstream */
+  /* FLUSH_START : lock, mark as flushing, unlock. if wasn't flushing forward */
+  /* FLUSH_STOP : lock, unmark as flushing, unlock, if was flushing forward */
+  /* OTHER : if selected pad forward */
+  return gst_pad_push_event (stream_combiner->srcpad, event);
+}
+
+static GstCaps *
+gst_stream_combiner_sink_getcaps (GstPad * pad)
+{
+  GstStreamCombiner *stream_combiner =
+      (GstStreamCombiner *) GST_PAD_PARENT (pad);
+
+  return gst_pad_peer_get_caps_reffed (stream_combiner->srcpad);
+}
+
+static gboolean
+gst_stream_combiner_sink_setcaps (GstPad * pad, GstCaps * caps)
+{
+  GstStreamCombiner *stream_combiner =
+      (GstStreamCombiner *) GST_PAD_PARENT (pad);
+  GstPad *peer;
+  gboolean res = FALSE;
+
+  GST_DEBUG_OBJECT (pad, "caps:%" GST_PTR_FORMAT, caps);
+
+  peer = gst_pad_get_peer (stream_combiner->srcpad);
+  if (peer) {
+    GST_DEBUG_OBJECT (peer, "Setting caps");
+    res = gst_pad_set_caps (peer, caps);
+    gst_object_unref (peer);
+  } else
+    GST_WARNING_OBJECT (stream_combiner, "sourcepad has no peer !");
+  return res;
+}
+
+static gboolean
+gst_stream_combiner_src_event (GstPad * pad, GstEvent * event)
+{
+  GstStreamCombiner *stream_combiner =
+      (GstStreamCombiner *) GST_PAD_PARENT (pad);
+  GstPad *sinkpad = NULL;
+
+  STREAMS_LOCK (stream_combiner);
+  if (stream_combiner->current)
+    sinkpad = stream_combiner->current;
+  else if (stream_combiner->sinkpads)
+    sinkpad = (GstPad *) stream_combiner->sinkpads->data;
+  STREAMS_UNLOCK (stream_combiner);
+
+  if (sinkpad)
+    /* Forward upstream as is */
+    return gst_pad_push_event (sinkpad, event);
+  return FALSE;
+}
+
+static gboolean
+gst_stream_combiner_src_query (GstPad * pad, GstQuery * query)
+{
+  GstStreamCombiner *stream_combiner =
+      (GstStreamCombiner *) GST_PAD_PARENT (pad);
+
+  GstPad *sinkpad = NULL;
+
+  STREAMS_LOCK (stream_combiner);
+  if (stream_combiner->current)
+    sinkpad = stream_combiner->current;
+  else if (stream_combiner->sinkpads)
+    sinkpad = (GstPad *) stream_combiner->sinkpads->data;
+  STREAMS_UNLOCK (stream_combiner);
+
+  if (sinkpad)
+    /* Forward upstream as is */
+    return gst_pad_peer_query (sinkpad, query);
+  return FALSE;
+}
+
+static void
+gst_stream_combiner_init (GstStreamCombiner * stream_combiner)
+{
+  stream_combiner->srcpad =
+      gst_pad_new_from_static_template (&src_template, "src");
+  gst_pad_set_event_function (stream_combiner->srcpad,
+      gst_stream_combiner_src_event);
+  gst_pad_set_query_function (stream_combiner->srcpad,
+      gst_stream_combiner_src_query);
+  gst_element_add_pad (GST_ELEMENT (stream_combiner), stream_combiner->srcpad);
+
+  stream_combiner->lock = g_mutex_new ();
+}
+
+static GstPad *
+gst_stream_combiner_request_new_pad (GstElement * element,
+    GstPadTemplate * templ, const gchar * name)
+{
+  GstStreamCombiner *stream_combiner = (GstStreamCombiner *) element;
+  GstPad *sinkpad;
+
+  GST_DEBUG_OBJECT (element, "templ:%p, name:%s", templ, name);
+
+  sinkpad = gst_pad_new_from_static_template (&sink_template, name);
+  /* FIXME : No buffer alloc for the time being, it will resort to the fallback */
+  /* gst_pad_set_bufferalloc_function (sinkpad, gst_stream_combiner_buffer_alloc); */
+  gst_pad_set_chain_function (sinkpad, gst_stream_combiner_chain);
+  gst_pad_set_event_function (sinkpad, gst_stream_combiner_sink_event);
+  gst_pad_set_getcaps_function (sinkpad, gst_stream_combiner_sink_getcaps);
+  gst_pad_set_setcaps_function (sinkpad, gst_stream_combiner_sink_setcaps);
+
+  STREAMS_LOCK (stream_combiner);
+  stream_combiner->sinkpads =
+      g_list_append (stream_combiner->sinkpads, sinkpad);
+  gst_pad_set_active (sinkpad, TRUE);
+  gst_element_add_pad (element, sinkpad);
+  stream_combiner->cookie++;
+  STREAMS_UNLOCK (stream_combiner);
+
+  GST_DEBUG_OBJECT (element, "Returning pad %p", sinkpad);
+
+  return sinkpad;
+}
+
+static void
+gst_stream_combiner_release_pad (GstElement * element, GstPad * pad)
+{
+  GstStreamCombiner *stream_combiner = (GstStreamCombiner *) element;
+  GList *tmp;
+
+  GST_DEBUG_OBJECT (element, "pad %s:%s", GST_DEBUG_PAD_NAME (pad));
+
+  STREAMS_LOCK (stream_combiner);
+  tmp = g_list_find (stream_combiner->sinkpads, pad);
+  if (tmp) {
+    GstPad *pad = (GstPad *) tmp->data;
+
+    stream_combiner->sinkpads =
+        g_list_delete_link (stream_combiner->sinkpads, tmp);
+    stream_combiner->cookie++;
+
+    if (pad == stream_combiner->current) {
+      /* Deactivate current flow */
+      GST_DEBUG_OBJECT (element, "Removed pad was the current one");
+      stream_combiner->current = NULL;
+    }
+    GST_DEBUG_OBJECT (element, "Removing pad from ourself");
+    gst_element_remove_pad (element, pad);
+  }
+  STREAMS_UNLOCK (stream_combiner);
+
+  return;
+}
diff --git a/gst/encoding/gststreamcombiner.h b/gst/encoding/gststreamcombiner.h
new file mode 100644
index 0000000..ce67277
--- /dev/null
+++ b/gst/encoding/gststreamcombiner.h
@@ -0,0 +1,60 @@
+/* GStreamer Stream Combiner
+ * Copyright (C) 2010 Edward Hervey <edward.hervey@collabora.co.uk>
+ *           (C) 2009 Nokia Corporation
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_STREAMCOMBINER_H__
+#define __GST_STREAMCOMBINER_H__
+
+#include <gst/gst.h>
+
+#define GST_TYPE_STREAM_COMBINER               (gst_stream_combiner_get_type())
+#define GST_STREAM_COMBINER(obj)               (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_STREAM_COMBINER,GstStreamCombiner))
+#define GST_STREAM_COMBINER_CLASS(klass)       (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_STREAM_COMBINER,GstStreamCombinerClass))
+#define GST_IS_STREAM_COMBINER(obj)            (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_STREAM_COMBINER))
+#define GST_IS_STREAM_COMBINER_CLASS(klass)    (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_STREAM_COMBINER))
+
+typedef struct _GstStreamCombiner GstStreamCombiner;
+typedef struct _GstStreamCombinerClass GstStreamCombinerClass;
+
+struct _GstStreamCombiner {
+  GstElement parent;
+
+  GstPad *srcpad;
+
+  /* lock protects:
+   * * the current pad
+   * * the list of srcpads
+   */
+  GMutex *lock;
+  /* Currently activated srcpad */
+  GstPad *current;
+  GList *sinkpads;
+  guint32 cookie;
+
+};
+
+struct _GstStreamCombinerClass {
+  GstElementClass parent;
+};
+
+GType gst_stream_combiner_get_type(void);
+
+GstElement *gst_stream_combiner_new (gchar *name);
+
+#endif /* __GST_STREAMCOMBINER_H__ */
diff --git a/gst/encoding/gststreamsplitter.c b/gst/encoding/gststreamsplitter.c
new file mode 100644
index 0000000..c473386
--- /dev/null
+++ b/gst/encoding/gststreamsplitter.c
@@ -0,0 +1,435 @@
+/* GStreamer Stream Splitter
+ * Copyright (C) 2010 Edward Hervey <edward.hervey@collabora.co.uk>
+ *           (C) 2009 Nokia Corporation
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gststreamsplitter.h"
+
+static GstStaticPadTemplate src_template =
+GST_STATIC_PAD_TEMPLATE ("src_%d", GST_PAD_SRC, GST_PAD_REQUEST,
+    GST_STATIC_CAPS_ANY);
+
+static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS_ANY);
+
+GST_DEBUG_CATEGORY_STATIC (gst_stream_splitter_debug);
+#define GST_CAT_DEFAULT gst_stream_splitter_debug
+
+G_DEFINE_TYPE (GstStreamSplitter, gst_stream_splitter, GST_TYPE_ELEMENT);
+
+#define STREAMS_LOCK(obj) (g_mutex_lock(obj->lock))
+#define STREAMS_UNLOCK(obj) (g_mutex_unlock(obj->lock))
+
+static void gst_stream_splitter_dispose (GObject * object);
+
+static GstPad *gst_stream_splitter_request_new_pad (GstElement * element,
+    GstPadTemplate * templ, const gchar * name);
+static void gst_stream_splitter_release_pad (GstElement * element,
+    GstPad * pad);
+
+static void
+gst_stream_splitter_class_init (GstStreamSplitterClass * klass)
+{
+  GObjectClass *gobject_klass;
+  GstElementClass *gstelement_klass;
+
+  gobject_klass = (GObjectClass *) klass;
+  gstelement_klass = (GstElementClass *) klass;
+
+  gobject_klass->dispose = gst_stream_splitter_dispose;
+
+  GST_DEBUG_CATEGORY_INIT (gst_stream_splitter_debug, "streamsplitter", 0,
+      "Stream Splitter");
+
+  gst_element_class_add_pad_template (gstelement_klass,
+      gst_static_pad_template_get (&src_template));
+  gst_element_class_add_pad_template (gstelement_klass,
+      gst_static_pad_template_get (&sink_template));
+
+  gstelement_klass->request_new_pad =
+      GST_DEBUG_FUNCPTR (gst_stream_splitter_request_new_pad);
+  gstelement_klass->release_pad =
+      GST_DEBUG_FUNCPTR (gst_stream_splitter_release_pad);
+
+  gst_element_class_set_details_simple (gstelement_klass,
+      "streamsplitter", "Generic",
+      "Splits streams based on their media type",
+      "Edward Hervey <edward.hervey@collabora.co.uk>");
+}
+
+static void
+gst_stream_splitter_dispose (GObject * object)
+{
+  GstStreamSplitter *stream_splitter = (GstStreamSplitter *) object;
+
+  if (stream_splitter->lock) {
+    g_mutex_free (stream_splitter->lock);
+    stream_splitter->lock = NULL;
+  }
+
+  g_list_foreach (stream_splitter->pending_events, (GFunc) gst_event_unref,
+      NULL);
+  g_list_free (stream_splitter->pending_events);
+  stream_splitter->pending_events = NULL;
+
+  G_OBJECT_CLASS (gst_stream_splitter_parent_class)->dispose (object);
+}
+
+static GstFlowReturn
+gst_stream_splitter_chain (GstPad * pad, GstBuffer * buf)
+{
+  GstStreamSplitter *stream_splitter =
+      (GstStreamSplitter *) GST_PAD_PARENT (pad);
+  GstFlowReturn res;
+  GstPad *srcpad = NULL;
+
+  STREAMS_LOCK (stream_splitter);
+  if (stream_splitter->current)
+    srcpad = gst_object_ref (stream_splitter->current);
+  STREAMS_UNLOCK (stream_splitter);
+
+  if (G_UNLIKELY (srcpad == NULL))
+    goto nopad;
+
+  if (G_UNLIKELY (stream_splitter->pending_events)) {
+    GList *tmp;
+    GST_DEBUG_OBJECT (srcpad, "Pushing out pending events");
+
+    for (tmp = stream_splitter->pending_events; tmp; tmp = tmp->next) {
+      GstEvent *event = (GstEvent *) tmp->data;
+      gst_pad_push_event (srcpad, event);
+    }
+    g_list_free (stream_splitter->pending_events);
+    stream_splitter->pending_events = NULL;
+  }
+
+  /* Forward to currently activated stream */
+  res = gst_pad_push (srcpad, buf);
+  gst_object_unref (srcpad);
+
+  return res;
+
+nopad:
+  GST_WARNING_OBJECT (stream_splitter, "No output pad was configured");
+  return GST_FLOW_ERROR;
+}
+
+static gboolean
+gst_stream_splitter_sink_event (GstPad * pad, GstEvent * event)
+{
+  GstStreamSplitter *stream_splitter =
+      (GstStreamSplitter *) GST_PAD_PARENT (pad);
+  gboolean res = TRUE;
+  gboolean toall = FALSE;
+  gboolean store = FALSE;
+  gboolean eos = FALSE;
+  gboolean flushpending = FALSE;
+
+  /* FLUSH_START/STOP : forward to all
+   * EOS : transform to CUSTOM_REAL_EOS and forward to all
+   * INBAND events : store to send in chain function to selected chain
+   * OUT_OF_BAND events : send to all
+   */
+
+  GST_DEBUG_OBJECT (stream_splitter, "Got event %s",
+      GST_EVENT_TYPE_NAME (event));
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_FLUSH_STOP:
+      flushpending = TRUE;
+      toall = TRUE;
+      break;
+    case GST_EVENT_FLUSH_START:
+      toall = TRUE;
+      break;
+    case GST_EVENT_EOS:
+      /* Replace with our custom eos event */
+      gst_event_unref (event);
+      event =
+          gst_event_new_custom (GST_EVENT_CUSTOM_DOWNSTREAM,
+          gst_structure_empty_new ("stream-switching-eos"));
+      toall = TRUE;
+      eos = TRUE;
+      break;
+    default:
+      if (GST_EVENT_TYPE (event) & GST_EVENT_TYPE_SERIALIZED)
+        store = TRUE;
+  }
+
+  if (flushpending) {
+    g_list_foreach (stream_splitter->pending_events, (GFunc) gst_event_unref,
+        NULL);
+    g_list_free (stream_splitter->pending_events);
+    stream_splitter->pending_events = NULL;
+  }
+
+  if (store) {
+    stream_splitter->pending_events =
+        g_list_append (stream_splitter->pending_events, event);
+  } else if (toall || eos) {
+    GList *tmp;
+    guint32 cookie;
+
+    /* Send to all pads */
+    STREAMS_LOCK (stream_splitter);
+  resync:
+    if (G_UNLIKELY (stream_splitter->srcpads == NULL)) {
+      STREAMS_UNLOCK (stream_splitter);
+      /* No source pads */
+      gst_event_unref (event);
+      res = FALSE;
+      goto beach;
+    }
+    tmp = stream_splitter->srcpads;
+    cookie = stream_splitter->cookie;
+    while (tmp) {
+      GstPad *srcpad = (GstPad *) tmp->data;
+      STREAMS_UNLOCK (stream_splitter);
+      /* In case of EOS, we first push out the real one to flush out
+       * each streams (but which will be discarded in the streamcombiner)
+       * before our custom one (which will be converted back to and EOS
+       * in the streamcombiner) */
+      if (eos)
+        gst_pad_push_event (srcpad, gst_event_new_eos ());
+      gst_event_ref (event);
+      res = gst_pad_push_event (srcpad, event);
+      STREAMS_LOCK (stream_splitter);
+      if (G_UNLIKELY (cookie != stream_splitter->cookie))
+        goto resync;
+      tmp = tmp->next;
+    }
+    STREAMS_UNLOCK (stream_splitter);
+    gst_event_unref (event);
+  } else {
+    GstPad *pad;
+
+    /* Only send to current pad */
+
+    STREAMS_LOCK (stream_splitter);
+    pad = stream_splitter->current;
+    STREAMS_UNLOCK (stream_splitter);
+    if (pad)
+      res = gst_pad_push_event (pad, event);
+    else {
+      gst_event_unref (event);
+      res = FALSE;
+    }
+  }
+
+beach:
+  return res;
+}
+
+static GstCaps *
+gst_stream_splitter_sink_getcaps (GstPad * pad)
+{
+  GstStreamSplitter *stream_splitter =
+      (GstStreamSplitter *) GST_PAD_PARENT (pad);
+  guint32 cookie;
+  GList *tmp;
+  GstCaps *res = NULL;
+
+  /* Return the combination of all downstream caps */
+
+  STREAMS_LOCK (stream_splitter);
+
+resync:
+  if (G_UNLIKELY (stream_splitter->srcpads == NULL)) {
+    res = gst_caps_new_any ();
+    goto beach;
+  }
+
+  res = NULL;
+  cookie = stream_splitter->cookie;
+  tmp = stream_splitter->srcpads;
+
+  while (tmp) {
+    GstPad *srcpad = (GstPad *) tmp->data;
+
+    STREAMS_UNLOCK (stream_splitter);
+    if (res)
+      gst_caps_merge (res, gst_pad_peer_get_caps_reffed (srcpad));
+    else
+      res = gst_pad_peer_get_caps (srcpad);
+    STREAMS_LOCK (stream_splitter);
+
+    if (G_UNLIKELY (cookie != stream_splitter->cookie)) {
+      if (res)
+        gst_caps_unref (res);
+      goto resync;
+    }
+    tmp = tmp->next;
+  }
+
+beach:
+  STREAMS_UNLOCK (stream_splitter);
+  return res;
+}
+
+static gboolean
+gst_stream_splitter_sink_setcaps (GstPad * pad, GstCaps * caps)
+{
+  GstStreamSplitter *stream_splitter =
+      (GstStreamSplitter *) GST_PAD_PARENT (pad);
+  guint32 cookie;
+  GList *tmp;
+  gboolean res;
+
+  GST_DEBUG_OBJECT (stream_splitter, "caps %" GST_PTR_FORMAT, caps);
+
+  /* Try on all pads, choose the one that succeeds as the current stream */
+  STREAMS_LOCK (stream_splitter);
+
+resync:
+  if (G_UNLIKELY (stream_splitter->srcpads == NULL)) {
+    res = FALSE;
+    goto beach;
+  }
+
+  res = FALSE;
+  tmp = stream_splitter->srcpads;
+  cookie = stream_splitter->cookie;
+
+  while (tmp) {
+    GstPad *srcpad = (GstPad *) tmp->data;
+    GstCaps *peercaps;
+
+    STREAMS_UNLOCK (stream_splitter);
+    peercaps = gst_pad_peer_get_caps_reffed (srcpad);
+    if (peercaps) {
+      res = gst_caps_can_intersect (caps, peercaps);
+      gst_caps_unref (peercaps);
+    }
+    STREAMS_LOCK (stream_splitter);
+
+    if (G_UNLIKELY (cookie != stream_splitter->cookie))
+      goto resync;
+
+    if (res) {
+      /* FIXME : we need to switch properly */
+      GST_DEBUG_OBJECT (srcpad, "Setting caps on this pad was succesfull");
+      stream_splitter->current = srcpad;
+      goto beach;
+    }
+    tmp = tmp->next;
+  }
+
+beach:
+  STREAMS_UNLOCK (stream_splitter);
+  return res;
+}
+
+static gboolean
+gst_stream_splitter_src_event (GstPad * pad, GstEvent * event)
+{
+  GstStreamSplitter *stream_splitter =
+      (GstStreamSplitter *) GST_PAD_PARENT (pad);
+
+  GST_DEBUG_OBJECT (pad, "%s", GST_EVENT_TYPE_NAME (event));
+
+  /* Forward upstream as is */
+  return gst_pad_push_event (stream_splitter->sinkpad, event);
+}
+
+static gboolean
+gst_stream_splitter_src_query (GstPad * pad, GstQuery * query)
+{
+  GstStreamSplitter *stream_splitter =
+      (GstStreamSplitter *) GST_PAD_PARENT (pad);
+
+  GST_DEBUG_OBJECT (pad, "%s", GST_QUERY_TYPE_NAME (query));
+
+  /* Forward upstream as is */
+  return gst_pad_peer_query (stream_splitter->sinkpad, query);
+}
+
+static void
+gst_stream_splitter_init (GstStreamSplitter * stream_splitter)
+{
+  stream_splitter->sinkpad =
+      gst_pad_new_from_static_template (&sink_template, "sink");
+  /* FIXME : No buffer alloc for the time being, it will resort to the fallback */
+  /* gst_pad_set_bufferalloc_function (stream_splitter->sinkpad, */
+  /*     gst_stream_splitter_buffer_alloc); */
+  gst_pad_set_chain_function (stream_splitter->sinkpad,
+      gst_stream_splitter_chain);
+  gst_pad_set_event_function (stream_splitter->sinkpad,
+      gst_stream_splitter_sink_event);
+  gst_pad_set_getcaps_function (stream_splitter->sinkpad,
+      gst_stream_splitter_sink_getcaps);
+  gst_pad_set_setcaps_function (stream_splitter->sinkpad,
+      gst_stream_splitter_sink_setcaps);
+  gst_element_add_pad (GST_ELEMENT (stream_splitter), stream_splitter->sinkpad);
+
+  stream_splitter->lock = g_mutex_new ();
+}
+
+static GstPad *
+gst_stream_splitter_request_new_pad (GstElement * element,
+    GstPadTemplate * templ, const gchar * name)
+{
+  GstStreamSplitter *stream_splitter = (GstStreamSplitter *) element;
+  GstPad *srcpad;
+
+  srcpad = gst_pad_new_from_static_template (&src_template, name);
+  gst_pad_set_event_function (srcpad, gst_stream_splitter_src_event);
+  gst_pad_set_query_function (srcpad, gst_stream_splitter_src_query);
+
+  STREAMS_LOCK (stream_splitter);
+  stream_splitter->srcpads = g_list_append (stream_splitter->srcpads, srcpad);
+  gst_pad_set_active (srcpad, TRUE);
+  gst_element_add_pad (element, srcpad);
+  stream_splitter->cookie++;
+  STREAMS_UNLOCK (stream_splitter);
+
+  return srcpad;
+}
+
+static void
+gst_stream_splitter_release_pad (GstElement * element, GstPad * pad)
+{
+  GstStreamSplitter *stream_splitter = (GstStreamSplitter *) element;
+  GList *tmp;
+
+  STREAMS_LOCK (stream_splitter);
+  tmp = g_list_find (stream_splitter->srcpads, pad);
+  if (tmp) {
+    GstPad *pad = (GstPad *) tmp->data;
+
+    stream_splitter->srcpads =
+        g_list_delete_link (stream_splitter->srcpads, tmp);
+    stream_splitter->cookie++;
+
+    if (pad == stream_splitter->current) {
+      /* Deactivate current flow */
+      GST_DEBUG_OBJECT (element, "Removed pad was the current one");
+      stream_splitter->current = NULL;
+    }
+
+    gst_element_remove_pad (element, pad);
+  }
+  STREAMS_UNLOCK (stream_splitter);
+
+  return;
+}
diff --git a/gst/encoding/gststreamsplitter.h b/gst/encoding/gststreamsplitter.h
new file mode 100644
index 0000000..b503c00
--- /dev/null
+++ b/gst/encoding/gststreamsplitter.h
@@ -0,0 +1,62 @@
+/* GStreamer Stream Splitter
+ * Copyright (C) 2010 Edward Hervey <edward.hervey@collabora.co.uk>
+ *           (C) 2009 Nokia Corporation
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_STREAMSPLITTER_H__
+#define __GST_STREAMSPLITTER_H__
+
+#include <gst/gst.h>
+
+#define GST_TYPE_STREAM_SPLITTER               (gst_stream_splitter_get_type())
+#define GST_STREAM_SPLITTER(obj)               (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_STREAM_SPLITTER,GstStreamSplitter))
+#define GST_STREAM_SPLITTER_CLASS(klass)       (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_STREAM_SPLITTER,GstStreamSplitterClass))
+#define GST_IS_STREAM_SPLITTER(obj)            (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_STREAM_SPLITTER))
+#define GST_IS_STREAM_SPLITTER_CLASS(klass)    (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_STREAM_SPLITTER))
+
+typedef struct _GstStreamSplitter GstStreamSplitter;
+typedef struct _GstStreamSplitterClass GstStreamSplitterClass;
+
+struct _GstStreamSplitter {
+  GstElement parent;
+
+  GstPad *sinkpad;
+
+  /* lock protects:
+   * * the current pad
+   * * the list of srcpads
+   */
+  GMutex *lock;
+  /* Currently activated srcpad */
+  GstPad *current;
+  GList *srcpads;
+  guint32 cookie;
+
+  /* List of pending in-band events */
+  GList *pending_events;
+};
+
+struct _GstStreamSplitterClass {
+  GstElementClass parent;
+};
+
+GType gst_stream_splitter_get_type(void);
+
+GstElement *gst_stream_splitter_new (gchar *name);
+
+#endif /* __GST_STREAMSPLITTER_H__ */
diff --git a/tests/examples/Makefile.am b/tests/examples/Makefile.am
index de19760..fa5a8b8 100644
--- a/tests/examples/Makefile.am
+++ b/tests/examples/Makefile.am
@@ -8,8 +8,8 @@ if USE_GIO
 GIO_SUBDIRS = gio
 endif
 
-SUBDIRS = app $(FT2_SUBDIRS) $(GIO_SUBDIRS) volume dynamic v4l overlay
+SUBDIRS = app $(FT2_SUBDIRS) $(GIO_SUBDIRS) volume dynamic v4l overlay encoding
 
-DIST_SUBDIRS = app seek volume dynamic snapshot gio v4l overlay
+DIST_SUBDIRS = app seek volume dynamic snapshot gio v4l overlay encoding
 
 include $(top_srcdir)/common/parallel-subdirs.mak
diff --git a/tests/examples/encoding/.gitignore b/tests/examples/encoding/.gitignore
new file mode 100644
index 0000000..c684c2e
--- /dev/null
+++ b/tests/examples/encoding/.gitignore
@@ -0,0 +1 @@
+encoding
diff --git a/tests/examples/encoding/Makefile.am b/tests/examples/encoding/Makefile.am
new file mode 100644
index 0000000..2bcc902
--- /dev/null
+++ b/tests/examples/encoding/Makefile.am
@@ -0,0 +1,12 @@
+examples = encoding
+
+encoding_SOURCES = gstcapslist.c encoding.c
+EXTRA_DIST = gstcapslist.h
+
+noinst_PROGRAMS = $(examples)
+
+LDADD = $(top_builddir)/gst-libs/gst/pbutils/libgstpbutils-@GST_MAJORMINOR@.la \
+	$(GST_LIBS)
+AM_CFLAGS = -I$(top_builddir)/gst-libs \
+	$(GST_PLUGINS_BASE_CFLAGS) \
+	$(GST_CFLAGS)
diff --git a/tests/examples/encoding/encoding.c b/tests/examples/encoding/encoding.c
new file mode 100644
index 0000000..89674ce
--- /dev/null
+++ b/tests/examples/encoding/encoding.c
@@ -0,0 +1,512 @@
+/* Example application for using GstProfile and encodebin
+ * Copyright (C) 2009 Edward Hervey <edward.hervey@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdlib.h>
+#include <glib.h>
+#include <glib/gprintf.h>
+#include <gst/gst.h>
+#include <gst/pbutils/pbutils.h>
+#include <gst/pbutils/encoding-profile.h>
+#include "gstcapslist.h"
+
+static gboolean silent = FALSE;
+
+static void
+list_codecs (void)
+{
+  GstCaps *l;
+  GstCaps *caps;
+  guint i, len;
+
+  caps = gst_caps_new_empty ();
+
+  g_print ("Available container formats:\n");
+  l = gst_caps_list_container_formats (GST_RANK_NONE);
+  len = gst_caps_get_size (l);
+  for (i = 0; i < len; i++) {
+    GstStructure *st = gst_caps_steal_structure (l, 0);
+    gchar *tmpstr, *desc;
+
+    gst_caps_append_structure (caps, st);
+
+    tmpstr = gst_caps_to_string (caps);
+    desc = gst_pb_utils_get_codec_description (caps);
+    g_print ("  %s - %s\n", desc, tmpstr);
+    g_free (tmpstr);
+    if (desc)
+      g_free (desc);
+    gst_caps_remove_structure (caps, 0);
+  }
+  g_print ("\n");
+  gst_caps_unref (l);
+
+  g_print ("Available video codecs:\n");
+  l = gst_caps_list_video_encoding_formats (GST_RANK_NONE);
+  len = gst_caps_get_size (l);
+  for (i = 0; i < len; i++) {
+    GstStructure *st = gst_caps_steal_structure (l, 0);
+    gchar *tmpstr, *desc;
+
+    gst_caps_append_structure (caps, st);
+
+    tmpstr = gst_caps_to_string (caps);
+    desc = gst_pb_utils_get_codec_description (caps);
+    g_print ("  %s - %s\n", desc, tmpstr);
+    g_free (tmpstr);
+    if (desc)
+      g_free (desc);
+    gst_caps_remove_structure (caps, 0);
+  }
+  g_print ("\n");
+  gst_caps_unref (l);
+
+  g_print ("Available audio codecs:\n");
+  l = gst_caps_list_audio_encoding_formats (GST_RANK_NONE);
+  len = gst_caps_get_size (l);
+  for (i = 0; i < len; i++) {
+    GstStructure *st = gst_caps_steal_structure (l, 0);
+    gchar *tmpstr, *desc;
+
+    gst_caps_append_structure (caps, st);
+
+    tmpstr = gst_caps_to_string (caps);
+    desc = gst_pb_utils_get_codec_description (caps);
+    g_print ("  %s - %s\n", desc, tmpstr);
+    g_free (tmpstr);
+    if (desc)
+      g_free (desc);
+    gst_caps_remove_structure (caps, 0);
+  }
+  g_print ("\n");
+  gst_caps_unref (l);
+
+  gst_caps_unref (caps);
+}
+
+static gchar *
+generate_filename (const GstCaps * container, const GstCaps * vcodec,
+    const GstCaps * acodec)
+{
+  gchar *a, *b, *c;
+  gchar *res = NULL;
+  guint i;
+
+  a = gst_pb_utils_get_codec_description (container);
+  b = gst_pb_utils_get_codec_description (vcodec);
+  c = gst_pb_utils_get_codec_description (acodec);
+
+  if (!a)
+    a = g_strdup_printf ("%.10s",
+        g_uri_escape_string (gst_caps_to_string (container), NULL, FALSE));
+  if (!b)
+    b = g_strdup_printf ("%.10s",
+        g_uri_escape_string (gst_caps_to_string (vcodec), NULL, FALSE));
+  if (!c)
+    c = g_strdup_printf ("%.10s",
+        g_uri_escape_string (gst_caps_to_string (acodec), NULL, FALSE));
+
+  for (i = 0; i < 256 && res == NULL; i++) {
+    res = g_strdup_printf ("%s-%s-%s-%d.file", a, b, c, i);
+    if (g_file_test (res, G_FILE_TEST_EXISTS)) {
+      g_free (res);
+      res = NULL;
+    }
+  }
+  /* Make sure file doesn't already exist */
+
+  g_free (a);
+  g_free (b);
+  g_free (c);
+
+  return res;
+}
+
+static GstEncodingProfile *
+create_profile (GstCaps * cf, GstCaps * vf, GstCaps * af)
+{
+  GstEncodingContainerProfile *cprof = NULL;
+
+  cprof =
+      gst_encoding_container_profile_new ((gchar *) "test-application-profile",
+      NULL, cf, NULL);
+
+  if (vf)
+    gst_encoding_container_profile_add_profile (cprof,
+        (GstEncodingProfile *) gst_encoding_video_profile_new (vf,
+            NULL, NULL, 0));
+  if (af)
+    gst_encoding_container_profile_add_profile (cprof, (GstEncodingProfile *)
+        gst_encoding_audio_profile_new (af, NULL, NULL, 0));
+
+  /* Let's print out some info */
+  if (!silent) {
+    gchar *desc = gst_pb_utils_get_codec_description (cf);
+    gchar *cd = gst_caps_to_string (cf);
+    g_print ("Encoding parameters\n");
+    g_print ("  Container format : %s (%s)\n", desc, cd);
+    g_free (desc);
+    g_free (cd);
+    if (vf) {
+      desc = gst_pb_utils_get_codec_description (vf);
+      cd = gst_caps_to_string (vf);
+      g_print ("  Video format : %s (%s)\n", desc, cd);
+      g_free (desc);
+      g_free (cd);
+    }
+    if (af) {
+      desc = gst_pb_utils_get_codec_description (af);
+      cd = gst_caps_to_string (af);
+      g_print ("  Audio format : %s (%s)\n", desc, cd);
+      g_free (desc);
+      g_free (cd);
+    }
+  }
+
+  return (GstEncodingProfile *) cprof;
+}
+
+static GstEncodingProfile *
+create_profile_from_string (gchar * format, gchar * vformat, gchar * aformat)
+{
+  GstEncodingProfile *prof = NULL;
+  GstCaps *cf = NULL, *vf = NULL, *af = NULL;
+
+  if (format)
+    cf = gst_caps_from_string (format);
+  if (vformat)
+    vf = gst_caps_from_string (vformat);
+  if (aformat)
+    af = gst_caps_from_string (aformat);
+
+  if (G_UNLIKELY ((vformat && (vf == NULL)) || (aformat && (af == NULL))))
+    goto beach;
+
+  prof = create_profile (cf, vf, af);
+
+beach:
+  if (cf)
+    gst_caps_unref (cf);
+  if (vf)
+    gst_caps_unref (vf);
+  if (af)
+    gst_caps_unref (af);
+
+  return prof;
+}
+
+static void
+pad_added_cb (GstElement * uridecodebin, GstPad * pad, GstElement * encodebin)
+{
+  GstPad *sinkpad;
+
+  sinkpad = gst_element_get_compatible_pad (encodebin, pad, NULL);
+
+  if (sinkpad == NULL) {
+    GstCaps *caps;
+
+    /* Ask encodebin for a compatible pad */
+    caps = gst_pad_get_caps (pad);
+    g_signal_emit_by_name (encodebin, "request-pad", caps, &sinkpad);
+    if (caps)
+      gst_caps_unref (caps);
+  }
+  if (sinkpad == NULL) {
+    g_print ("Couldn't get an encoding channel for pad %s:%s\n",
+        GST_DEBUG_PAD_NAME (pad));
+    return;
+  }
+
+  if (G_UNLIKELY (gst_pad_link (pad, sinkpad) != GST_PAD_LINK_OK)) {
+    g_print ("Couldn't link pads\n");
+  }
+
+  return;
+}
+
+static gboolean
+autoplug_continue_cb (GstElement * uridecodebin, GstPad * somepad,
+    GstCaps * caps, GstElement * encodebin)
+{
+  GstPad *sinkpad;
+
+  g_signal_emit_by_name (encodebin, "request-pad", caps, &sinkpad);
+
+  if (sinkpad == NULL)
+    return TRUE;
+
+  return FALSE;
+}
+
+static void
+bus_message_cb (GstBus * bus, GstMessage * message, GMainLoop * mainloop)
+{
+  switch (GST_MESSAGE_TYPE (message)) {
+    case GST_MESSAGE_ERROR:
+      g_print ("ERROR\n");
+      gst_bus_set_flushing (bus, TRUE);
+      g_main_loop_quit (mainloop);
+      break;
+    case GST_MESSAGE_EOS:
+      g_print ("Done\n");
+      g_main_loop_quit (mainloop);
+      break;
+    default:
+      break;
+  }
+}
+
+static void
+transcode_file (gchar * uri, gchar * outputuri, GstEncodingProfile * prof)
+{
+  GstElement *pipeline;
+  GstElement *src;
+  GstElement *ebin;
+  GstElement *sink;
+  GstBus *bus;
+  GstCaps *profilecaps, *rescaps;
+  GMainLoop *mainloop;
+
+  g_print (" Input URI  : %s\n", uri);
+  g_print (" Output URI : %s\n", outputuri);
+
+  sink = gst_element_make_from_uri (GST_URI_SINK, outputuri, "sink");
+  if (G_UNLIKELY (sink == NULL)) {
+    g_print ("Can't create output sink, most likely invalid output URI !\n");
+    return;
+  }
+
+  src = gst_element_factory_make ("uridecodebin", NULL);
+  if (G_UNLIKELY (src == NULL)) {
+    g_print ("Can't create uridecodebin for input URI, aborting!\n");
+    return;
+  }
+
+  /* Figure out the streams that can be passed as-is to encodebin */
+  g_object_get (src, "caps", &rescaps, NULL);
+  rescaps = gst_caps_copy (rescaps);
+  profilecaps = gst_encoding_profile_get_input_caps (prof);
+  gst_caps_append (rescaps, profilecaps);
+
+  /* Set properties */
+  g_object_set (src, "uri", uri, "caps", rescaps, NULL);
+
+  ebin = gst_element_factory_make ("encodebin", NULL);
+  g_object_set (ebin, "profile", prof, NULL);
+
+  g_signal_connect (src, "autoplug-continue", G_CALLBACK (autoplug_continue_cb),
+      ebin);
+  g_signal_connect (src, "pad-added", G_CALLBACK (pad_added_cb), ebin);
+
+  pipeline = gst_pipeline_new ("encoding-pipeline");
+
+  gst_bin_add_many (GST_BIN (pipeline), src, ebin, sink, NULL);
+
+  gst_element_link (ebin, sink);
+
+  mainloop = g_main_loop_new (NULL, FALSE);
+
+  bus = gst_pipeline_get_bus ((GstPipeline *) pipeline);
+  gst_bus_add_signal_watch (bus);
+  g_signal_connect (bus, "message", G_CALLBACK (bus_message_cb), mainloop);
+
+  if (gst_element_set_state (pipeline,
+          GST_STATE_PLAYING) == GST_STATE_CHANGE_FAILURE) {
+    g_print ("Failed to start the encoding\n");
+    return;
+  }
+
+  g_main_loop_run (mainloop);
+
+  gst_element_set_state (pipeline, GST_STATE_NULL);
+  gst_object_unref (pipeline);
+}
+
+static gchar *
+ensure_uri (gchar * location)
+{
+  gchar *res;
+  gchar *path;
+
+  if (gst_uri_is_valid (location))
+    return g_strdup (location);
+
+  if (!g_path_is_absolute (location)) {
+    gchar *cur_dir;
+    cur_dir = g_get_current_dir ();
+    path = g_build_filename (cur_dir, location, NULL);
+    g_free (cur_dir);
+  } else
+    path = g_strdup (location);
+
+  res = g_filename_to_uri (path, NULL, NULL);
+  g_free (path);
+
+  return res;
+}
+
+int
+main (int argc, char **argv)
+{
+  GError *err = NULL;
+  gchar *outputuri = NULL;
+  gchar *format = NULL;
+  gchar *aformat = NULL;
+  gchar *vformat = NULL;
+  gboolean allmissing = FALSE;
+  gboolean listcodecs = FALSE;
+  GOptionEntry options[] = {
+    {"silent", 's', 0, G_OPTION_ARG_NONE, &silent,
+        "Don't output the information structure", NULL},
+    {"outputuri", 'o', 0, G_OPTION_ARG_STRING, &outputuri,
+        "URI to encode to", "URI (<protocol>://<location>)"},
+    {"format", 'f', 0, G_OPTION_ARG_STRING, &format,
+        "Container format", "<GstCaps>"},
+    {"vformat", 'v', 0, G_OPTION_ARG_STRING, &vformat,
+        "Video format", "<GstCaps>"},
+    {"aformat", 'a', 0, G_OPTION_ARG_STRING, &aformat,
+        "Audio format", "<GstCaps>"},
+    {"allmissing", 'm', 0, G_OPTION_ARG_NONE, &allmissing,
+        "encode to all matching format/codec that aren't specified", NULL},
+    {"list-codecs", 'l', 0, G_OPTION_ARG_NONE, &listcodecs,
+        "list all available codecs and container formats", NULL},
+    {NULL}
+  };
+  GOptionContext *ctx;
+  GstEncodingProfile *prof;
+  gchar *inputuri;
+
+  if (!g_thread_supported ())
+    g_thread_init (NULL);
+
+  ctx = g_option_context_new ("- encode URIs with GstProfile and encodebin");
+  g_option_context_add_main_entries (ctx, options, NULL);
+  g_option_context_add_group (ctx, gst_init_get_option_group ());
+
+  if (!g_option_context_parse (ctx, &argc, &argv, &err)) {
+    g_print ("Error initializing: %s\n", err->message);
+    exit (1);
+  }
+
+  if (listcodecs) {
+    list_codecs ();
+    g_option_context_free (ctx);
+    exit (0);
+  }
+
+  if (outputuri == NULL || argc != 2) {
+    g_print ("%s", g_option_context_get_help (ctx, TRUE, NULL));
+    g_option_context_free (ctx);
+    exit (-1);
+  }
+
+  g_option_context_free (ctx);
+
+  /* Fixup outputuri to be a URI */
+  inputuri = ensure_uri (argv[1]);
+  outputuri = ensure_uri (outputuri);
+
+  if (allmissing) {
+    GList *muxers;
+    GstCaps *formats = NULL;
+    GstCaps *vformats = NULL;
+    GstCaps *aformats = NULL;
+    guint f, v, a, flen, vlen, alen;
+
+    if (!format)
+      formats = gst_caps_list_container_formats (GST_RANK_NONE);
+    else
+      formats = gst_caps_from_string (format);
+
+    if (!vformat)
+      vformats = gst_caps_list_video_encoding_formats (GST_RANK_NONE);
+    else
+      vformats = gst_caps_from_string (vformat);
+
+    if (!aformat)
+      aformats = gst_caps_list_audio_encoding_formats (GST_RANK_NONE);
+    else
+      aformats = gst_caps_from_string (aformat);
+    muxers =
+        gst_element_factory_list_get_elements (GST_ELEMENT_FACTORY_TYPE_MUXER,
+        GST_RANK_NONE);
+
+    flen = gst_caps_get_size (formats);
+
+    for (f = 0; f < flen; f++) {
+      GstCaps *container =
+          gst_caps_new_full (gst_caps_steal_structure (formats, 0), NULL);
+      GstCaps *compatv =
+          gst_caps_list_compatible_codecs (container, vformats, muxers);
+      GstCaps *compata =
+          gst_caps_list_compatible_codecs (container, aformats, muxers);
+
+      vlen = gst_caps_get_size (compatv);
+      alen = gst_caps_get_size (compata);
+
+
+      for (v = 0; v < vlen; v++) {
+        GstCaps *vcodec =
+            gst_caps_new_full (gst_structure_copy (gst_caps_get_structure
+                (compatv, v)), NULL);
+        for (a = 0; a < alen; a++) {
+          GstCaps *acodec =
+              gst_caps_new_full (gst_structure_copy (gst_caps_get_structure
+                  (compata, a)), NULL);
+
+          prof =
+              create_profile ((GstCaps *) container, (GstCaps *) vcodec,
+              (GstCaps *) acodec);
+          if (G_UNLIKELY (prof == NULL)) {
+            g_print ("Wrong arguments\n");
+            break;
+          }
+          outputuri =
+              ensure_uri (generate_filename (container, vcodec, acodec));
+          transcode_file (inputuri, outputuri, prof);
+          gst_encoding_profile_unref (prof);
+
+          gst_caps_unref (acodec);
+        }
+        gst_caps_unref (vcodec);
+      }
+      gst_caps_unref (container);
+    }
+
+  } else {
+
+    /* Create the profile */
+    prof = create_profile_from_string (format, vformat, aformat);
+    if (G_UNLIKELY (prof == NULL)) {
+      g_print ("Encoding arguments are not valid !\n");
+      return 1;
+    }
+
+    /* Trancode file */
+    transcode_file (inputuri, outputuri, prof);
+
+    /* cleanup */
+    gst_encoding_profile_unref (prof);
+
+  }
+  return 0;
+}
diff --git a/tests/examples/encoding/gstcapslist.c b/tests/examples/encoding/gstcapslist.c
new file mode 100644
index 0000000..4908e43
--- /dev/null
+++ b/tests/examples/encoding/gstcapslist.c
@@ -0,0 +1,286 @@
+/* GStreamer
+ * Copyright (C) <2010> Edward Hervey <edward.hervey@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "gstcapslist.h"
+
+/*
+ * Caps listing convenience functions
+ */
+
+static gboolean
+remove_range_foreach (GQuark field_id, const GValue * value, GstStructure * st)
+{
+  GType ftype = G_VALUE_TYPE (value);
+  const gchar *fname;
+
+  if (ftype == GST_TYPE_INT_RANGE || ftype == GST_TYPE_DOUBLE_RANGE ||
+      ftype == GST_TYPE_FRACTION_RANGE) {
+    gst_structure_remove_field (st, g_quark_to_string (field_id));
+    return FALSE;
+  }
+
+  fname = g_quark_to_string (field_id);
+
+  /* if (strstr (fname, "framerate") || strstr (fname, "pixel-aspect-ratio") || */
+  /*     strstr (fname, "rate")) { */
+  /*   gst_structure_remove_field (st, g_quark_to_string (field_id)); */
+  /*   return FALSE; */
+  /* } */
+
+  return TRUE;
+}
+
+static void
+clear_caps (GstCaps * caps, GstCaps * rescaps)
+{
+  GstCaps *res;
+  GstStructure *st;
+  guint i;
+
+  res = gst_caps_make_writable (caps);
+
+  GST_DEBUG ("incoming caps %" GST_PTR_FORMAT, res);
+
+  /* Remove width/height/framerate/depth/width fields */
+  for (i = gst_caps_get_size (res); i; i--) {
+    st = gst_caps_get_structure (res, i - 1);
+
+    /* Remove range fields */
+    while (!gst_structure_foreach (st,
+            (GstStructureForeachFunc) remove_range_foreach, st));
+  }
+
+  GST_DEBUG ("stripped %" GST_PTR_FORMAT, res);
+
+  /* And append to list without duplicates */
+  while ((st = gst_caps_steal_structure (res, 0))) {
+    /* Skip fake codecs/containers */
+    if (gst_structure_has_name (st, "audio/x-raw-int") ||
+        gst_structure_has_name (st, "audio/x-raw-float") ||
+        gst_structure_has_name (st, "video/x-raw-yuv") ||
+        gst_structure_has_name (st, "video/x-raw-rgb") ||
+        gst_structure_has_name (st, "unknown/unknown")) {
+      gst_structure_free (st);
+      continue;
+    }
+
+    gst_caps_append_structure (rescaps, st);
+  }
+
+  gst_caps_unref (res);
+}
+
+static GstCaps *
+get_all_caps (GList * elements, GstPadDirection direction)
+{
+  GstCaps *res = NULL, *res2;
+  GList *tmp;
+
+  res = gst_caps_new_empty ();
+
+  for (tmp = elements; tmp; tmp = tmp->next) {
+    GstElementFactory *factory = (GstElementFactory *) tmp->data;
+    const GList *templates;
+    GList *walk;
+
+    templates = gst_element_factory_get_static_pad_templates (factory);
+    for (walk = (GList *) templates; walk; walk = g_list_next (walk)) {
+      GstStaticPadTemplate *templ = walk->data;
+      if (templ->direction == direction)
+        clear_caps (gst_static_caps_get (&templ->static_caps), res);
+    }
+  }
+
+  res2 = gst_caps_normalize (res);
+  gst_caps_unref (res);
+  return res2;
+}
+
+/**
+ * gst_caps_list_container_formats:
+ * @minrank: The minimum #GstRank
+ *
+ * Returns a #GstCaps corresponding to all the container formats
+ * one can mux to on this system.
+ *
+ * Returns: A #GstCaps. Unref with %gst_caps_unref when done with it.
+ */
+GstCaps *
+gst_caps_list_container_formats (GstRank minrank)
+{
+  GstCaps *res;
+  GList *muxers;
+
+  muxers =
+      gst_element_factory_list_get_elements (GST_ELEMENT_FACTORY_TYPE_MUXER,
+      minrank);
+  res = get_all_caps (muxers, GST_PAD_SRC);
+  gst_plugin_feature_list_free (muxers);
+
+  return res;
+}
+
+static GstCaps *
+gst_caps_list_encoding_formats (GstRank minrank)
+{
+  GstCaps *res;
+  GList *encoders;
+
+  encoders =
+      gst_element_factory_list_get_elements (GST_ELEMENT_FACTORY_TYPE_ENCODER,
+      minrank);
+  res = get_all_caps (encoders, GST_PAD_SRC);
+  gst_plugin_feature_list_free (encoders);
+
+  return res;
+}
+
+/**
+ * gst_caps_list_video_encoding_formats:
+ * @minrank: The minimum #GstRank
+ *
+ * Returns a #GstCaps corresponding to all the video or image formats one
+ * can encode to on this system.
+ *
+ * Returns: A #GstCaps. Unref with %gst_caps_unref when done with it.
+ */
+GstCaps *
+gst_caps_list_video_encoding_formats (GstRank minrank)
+{
+  GstCaps *res;
+  GList *encoders;
+
+  encoders =
+      gst_element_factory_list_get_elements
+      (GST_ELEMENT_FACTORY_TYPE_VIDEO_ENCODER, minrank);
+  res = get_all_caps (encoders, GST_PAD_SRC);
+  gst_plugin_feature_list_free (encoders);
+
+  return res;
+}
+
+
+/**
+ * gst_caps_list_audio_encoding_formats:
+ * @minrank: The minimum #GstRank
+ *
+ * Returns a #GstCaps corresponding to all the audio formats one
+ * can encode to on this system.
+ *
+ * Returns: A  #GstCaps. Unref with %gst_caps_unref when done with it.
+ */
+GstCaps *
+gst_caps_list_audio_encoding_formats (GstRank minrank)
+{
+  GstCaps *res;
+  GList *encoders;
+
+  encoders =
+      gst_element_factory_list_get_elements
+      (GST_ELEMENT_FACTORY_TYPE_AUDIO_ENCODER, minrank);
+  res = get_all_caps (encoders, GST_PAD_SRC);
+  gst_plugin_feature_list_free (encoders);
+
+  return res;
+}
+
+/**
+ * gst_caps_list_compatible_codecs:
+ * @containerformat: A #GstCaps corresponding to a container format
+ * @codecformats: An optional #GstCaps of codec formats
+ * @muxers: An optional #GList of muxer #GstElementFactory.
+ *
+ * Returns an array of #GstCaps corresponding to the audio/video/text formats
+ * one can encode to and that can be muxed in the provided @containerformat.
+ *
+ * If specified, only the #GstCaps contained in @codecformats will be checked
+ * against, else all compatible audio/video formats will be returned.
+ *
+ * If specified, only the #GstElementFactory contained in @muxers will be checked,
+ * else all available muxers on the system will be checked.
+ *
+ * Returns: A #GstCaps containing all compatible formats. Unref with %gst_caps_unref
+ * when done.
+ */
+GstCaps *
+gst_caps_list_compatible_codecs (const GstCaps * containerformat,
+    GstCaps * codecformats, GList * muxers)
+{
+  const GList *templates;
+  GstElementFactory *factory;
+  GList *walk;
+  GstCaps *res = NULL;
+  GstCaps *tmpcaps;
+  GList *tmp;
+  gboolean hadmuxers = (muxers != NULL);
+  gboolean hadcodecs = (codecformats != NULL);
+
+  GST_DEBUG ("containerformat: %" GST_PTR_FORMAT, containerformat);
+  GST_DEBUG ("codecformats: %" GST_PTR_FORMAT, codecformats);
+
+  if (!hadmuxers)
+    muxers =
+        gst_element_factory_list_get_elements (GST_ELEMENT_FACTORY_TYPE_MUXER,
+        GST_RANK_NONE);
+  if (!hadcodecs)
+    codecformats = gst_caps_list_encoding_formats (GST_RANK_NONE);
+
+  /* Get the highest rank muxer matching containerformat */
+  tmp =
+      gst_element_factory_list_filter (muxers, containerformat, GST_PAD_SRC,
+      TRUE);
+  if (G_UNLIKELY (tmp == NULL))
+    goto beach;
+
+  factory = (GstElementFactory *) tmp->data;
+
+  GST_DEBUG ("Trying with factory %s",
+      gst_element_factory_get_longname (factory));
+
+  /* Match all muxer sink pad templates against the available codec formats */
+  templates = gst_element_factory_get_static_pad_templates (factory);
+  gst_plugin_feature_list_free (tmp);
+
+  tmpcaps = gst_caps_new_empty ();
+
+  for (walk = (GList *) templates; walk; walk = walk->next) {
+    GstStaticPadTemplate *templ = walk->data;
+
+    if (templ->direction == GST_PAD_SINK) {
+      GstCaps *templ_caps;
+
+      templ_caps = gst_static_caps_get (&templ->static_caps);
+      gst_caps_append (tmpcaps, gst_caps_copy (templ_caps));
+    }
+  }
+
+  res = gst_caps_intersect (tmpcaps, codecformats);
+  gst_caps_unref (tmpcaps);
+
+beach:
+  if (!hadmuxers)
+    gst_plugin_feature_list_free (muxers);
+  if (!hadcodecs)
+    gst_caps_unref (codecformats);
+
+  tmpcaps = gst_caps_normalize (res);
+  gst_caps_unref (res);
+
+  return tmpcaps;
+}
diff --git a/tests/examples/encoding/gstcapslist.h b/tests/examples/encoding/gstcapslist.h
new file mode 100644
index 0000000..fa0ed83
--- /dev/null
+++ b/tests/examples/encoding/gstcapslist.h
@@ -0,0 +1,35 @@
+/* GStreamer
+ * Copyright (C) <2010> Edward Hervey <edward.hervey@collabora.co.uk>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include <gst/gst.h>
+
+GstCaps *gst_caps_list_compatible_codecs (const GstCaps *containerformat,
+					  GstCaps *codecformats,
+					  GList *muxers);
+
+GstCaps *gst_caps_list_compatible_containers (GstCaps *mediaformat,
+					      GList *containerformats);
+
+
+GstCaps *gst_caps_list_container_formats (GstRank minrank);
+
+GstCaps *gst_caps_list_video_encoding_formats (GstRank minrank);
+
+GstCaps *gst_caps_list_audio_encoding_formats (GstRank minrank);
+
-- 
1.7.1

