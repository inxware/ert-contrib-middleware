<MACRO>
<NAME>GST_ALSA_MIXER_ELEMENT</NAME>
#define GST_ALSA_MIXER_ELEMENT(obj)             (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ALSA_MIXER_ELEMENT,GstAlsaMixerElement))
</MACRO>
<MACRO>
<NAME>GST_ALSA_MIXER_ELEMENT_CLASS</NAME>
#define GST_ALSA_MIXER_ELEMENT_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_ALSA_MIXER_ELEMENT,GstAlsaMixerElementClass))
</MACRO>
<MACRO>
<NAME>GST_IS_ALSA_MIXER_ELEMENT</NAME>
#define GST_IS_ALSA_MIXER_ELEMENT(obj)          (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ALSA_MIXER_ELEMENT))
</MACRO>
<MACRO>
<NAME>GST_IS_ALSA_MIXER_ELEMENT_CLASS</NAME>
#define GST_IS_ALSA_MIXER_ELEMENT_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_ALSA_MIXER_ELEMENT))
</MACRO>
<MACRO>
<NAME>GST_TYPE_ALSA_MIXER_ELEMENT</NAME>
#define GST_TYPE_ALSA_MIXER_ELEMENT             (gst_alsa_mixer_element_get_type())
</MACRO>
<STRUCT>
<NAME>GstAlsaMixerElement</NAME>
</STRUCT>
<STRUCT>
<NAME>GstAlsaMixerElementClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstAlsaMixerElement</NAME>
struct _GstAlsaMixerElement {
  GstElement            parent;

  GstAlsaMixer          *mixer;
  gchar                 *device;
};
</STRUCT>
<STRUCT>
<NAME>GstAlsaMixerElementClass</NAME>
struct _GstAlsaMixerElementClass {
  GstElementClass       parent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_alsa_mixer_element_get_type</NAME>
<RETURNS>GType           </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_ALSA_SINK</NAME>
#define GST_TYPE_ALSA_SINK            (gst_alsasink_get_type())
</MACRO>
<MACRO>
<NAME>GST_ALSA_SINK</NAME>
#define GST_ALSA_SINK(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ALSA_SINK,GstAlsaSink))
</MACRO>
<MACRO>
<NAME>GST_ALSA_SINK_CLASS</NAME>
#define GST_ALSA_SINK_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_ALSA_SINK,GstAlsaSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_ALSA_SINK</NAME>
#define GST_IS_ALSA_SINK(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ALSA_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_ALSA_SINK_CLASS</NAME>
#define GST_IS_ALSA_SINK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_ALSA_SINK))
</MACRO>
<MACRO>
<NAME>GST_ALSA_SINK_CAST</NAME>
#define GST_ALSA_SINK_CAST(obj)       ((GstAlsaSink *) (obj))
</MACRO>
<STRUCT>
<NAME>GstAlsaSink</NAME>
</STRUCT>
<STRUCT>
<NAME>GstAlsaSinkClass</NAME>
</STRUCT>
<MACRO>
<NAME>GST_ALSA_SINK_GET_LOCK</NAME>
#define GST_ALSA_SINK_GET_LOCK(obj)	(GST_ALSA_SINK_CAST (obj)->alsa_lock)
</MACRO>
<MACRO>
<NAME>GST_ALSA_SINK_LOCK</NAME>
#define GST_ALSA_SINK_LOCK(obj)	        (g_mutex_lock (GST_ALSA_SINK_GET_LOCK (obj)))
</MACRO>
<MACRO>
<NAME>GST_ALSA_SINK_UNLOCK</NAME>
#define GST_ALSA_SINK_UNLOCK(obj)	(g_mutex_unlock (GST_ALSA_SINK_GET_LOCK (obj)))
</MACRO>
<STRUCT>
<NAME>GstAlsaSink</NAME>
struct _GstAlsaSink {
  GstAudioSink    sink;

  gchar                 *device;

  snd_pcm_t             *handle;
  snd_pcm_hw_params_t   *hwparams;
  snd_pcm_sw_params_t   *swparams;

  snd_pcm_access_t access;
  snd_pcm_format_t format;
  guint rate;
  guint channels;
  gint bytes_per_sample;
  gboolean iec958;
  gboolean need_swap;

  guint buffer_time;
  guint period_time;
  snd_pcm_uframes_t buffer_size;
  snd_pcm_uframes_t period_size;

  GstCaps *cached_caps;

  GMutex *alsa_lock;
};
</STRUCT>
<STRUCT>
<NAME>GstAlsaSinkClass</NAME>
struct _GstAlsaSinkClass {
  GstAudioSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_alsasink_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_ALSA_SRC</NAME>
#define GST_TYPE_ALSA_SRC            (gst_alsasrc_get_type())
</MACRO>
<MACRO>
<NAME>GST_ALSA_SRC</NAME>
#define GST_ALSA_SRC(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ALSA_SRC,GstAlsaSrc))
</MACRO>
<MACRO>
<NAME>GST_ALSA_SRC_CLASS</NAME>
#define GST_ALSA_SRC_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_ALSA_SRC,GstAlsaSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_ALSA_SRC</NAME>
#define GST_IS_ALSA_SRC(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ALSA_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_ALSA_SRC_CLASS</NAME>
#define GST_IS_ALSA_SRC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_ALSA_SRC))
</MACRO>
<MACRO>
<NAME>GST_ALSA_SRC_CAST</NAME>
#define GST_ALSA_SRC_CAST(obj)       ((GstAlsaSrc *)(obj))
</MACRO>
<MACRO>
<NAME>GST_ALSA_SRC_GET_LOCK</NAME>
#define GST_ALSA_SRC_GET_LOCK(obj)  (GST_ALSA_SRC_CAST (obj)->alsa_lock)
</MACRO>
<MACRO>
<NAME>GST_ALSA_SRC_LOCK</NAME>
#define GST_ALSA_SRC_LOCK(obj)      (g_mutex_lock (GST_ALSA_SRC_GET_LOCK (obj)))
</MACRO>
<MACRO>
<NAME>GST_ALSA_SRC_UNLOCK</NAME>
#define GST_ALSA_SRC_UNLOCK(obj)    (g_mutex_unlock (GST_ALSA_SRC_GET_LOCK (obj)))
</MACRO>
<STRUCT>
<NAME>GstAlsaSrc</NAME>
</STRUCT>
<STRUCT>
<NAME>GstAlsaSrcClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstAlsaSrc</NAME>
struct _GstAlsaSrc {
  GstAudioSrc           src;

  gchar                 *device;

  snd_pcm_t             *handle;
  snd_pcm_hw_params_t   *hwparams;
  snd_pcm_sw_params_t   *swparams;

  GstCaps               *cached_caps;

  snd_pcm_access_t      access;
  snd_pcm_format_t      format;
  guint                 rate;
  guint                 channels;
  gint                  bytes_per_sample;

  guint                 buffer_time;
  guint                 period_time;
  snd_pcm_uframes_t     buffer_size;
  snd_pcm_uframes_t     period_size;

  GstAlsaMixer          *mixer;

  GMutex                *alsa_lock;
};
</STRUCT>
<STRUCT>
<NAME>GstAlsaSrcClass</NAME>
struct _GstAlsaSrcClass {
  GstAudioSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_alsasrc_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>size16</NAME>
#define size16 gint16
</MACRO>
<MACRO>
<NAME>size32</NAME>
#define size32 gint32
</MACRO>
<MACRO>
<NAME>GST_TYPE_CD_PARANOIA_SRC</NAME>
#define GST_TYPE_CD_PARANOIA_SRC            (gst_cd_paranoia_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_CD_PARANOIA_SRC</NAME>
#define GST_CD_PARANOIA_SRC(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CD_PARANOIA_SRC,GstCdParanoiaSrc))
</MACRO>
<MACRO>
<NAME>GST_CD_PARANOIA_SRC_CLASS</NAME>
#define GST_CD_PARANOIA_SRC_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CD_PARANOIA_SRC,GstCdParanoiaSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CD_PARANOIA_SRC</NAME>
#define GST_IS_CD_PARANOIA_SRC(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CD_PARANOIA_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_CD_PARANOIA_SRC_CLASS</NAME>
#define GST_IS_CD_PARANOIA_SRC_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CD_PARANOIA_SRC))
</MACRO>
<MACRO>
<NAME>GST_CD_PARANOIA_SRC_GET_CLASS</NAME>
#define GST_CD_PARANOIA_SRC_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_CDDA_BASAE_SRC, GstCdParanoiaSrcClass))
</MACRO>
<STRUCT>
<NAME>GstCdParanoiaSrc</NAME>
</STRUCT>
<STRUCT>
<NAME>GstCdParanoiaSrcClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstCdParanoiaSrc</NAME>
struct _GstCdParanoiaSrc {
  GstCddaBaseSrc   cddabasesrc;

  /*< private >*/
  cdrom_drive     *d;
  cdrom_paranoia  *p;

  gint             next_sector; /* -1 or next sector we expect to
                                 * read, so we know when to do a seek */

  gint             paranoia_mode;
  gint             read_speed;
  gint             search_overlap;
  gint             cache_size;

  gchar           *generic_device;
};
</STRUCT>
<STRUCT>
<NAME>GstCdParanoiaSrcClass</NAME>
struct _GstCdParanoiaSrcClass {
  GstCddaBaseSrcClass parent_class;

  /* signal callbacks */
  /**
   * GstCdParanoiaSrcClass::transport-error:
   * @src: the GstCddaBaseSrc source element object
   * @sector: the sector at which the error happened
   *
   * This signal is emitted when a sector could not be read
   * because of a transport error.
   */
  void (*transport_error)	(GstCdParanoiaSrc * src, gint sector);
  /**
   * GstCdParanoiaSrcClass::uncorrected-error:
   * @src: the GstCddaBaseSrc source element object
   * @sector: the sector at which the error happened
   *
   * This signal is emitted when a sector could not be read
   * because of a transport error.
   */
  void (*uncorrected_error)	(GstCdParanoiaSrc * src, gint sector);
};
</STRUCT>
<FUNCTION>
<NAME>gst_cd_paranoia_src_get_type</NAME>
<RETURNS>GType    </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GIO_SINK</NAME>
#define GST_TYPE_GIO_SINK \
  (gst_gio_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_GIO_SINK</NAME>
#define GST_GIO_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GIO_SINK,GstGioSink))
</MACRO>
<MACRO>
<NAME>GST_GIO_SINK_CLASS</NAME>
#define GST_GIO_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GIO_SINK,GstGioSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GIO_SINK</NAME>
#define GST_IS_GIO_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GIO_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_GIO_SINK_CLASS</NAME>
#define GST_IS_GIO_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GIO_SINK))
</MACRO>
<STRUCT>
<NAME>GstGioSink</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGioSinkClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGioSink</NAME>
struct _GstGioSink
{
  GstGioBaseSink sink;

  /*< private >*/
  GFile *file;
};
</STRUCT>
<STRUCT>
<NAME>GstGioSinkClass</NAME>
struct _GstGioSinkClass 
{
  GstGioBaseSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gio_sink_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GIO_SRC</NAME>
#define GST_TYPE_GIO_SRC \
  (gst_gio_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_GIO_SRC</NAME>
#define GST_GIO_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GIO_SRC,GstGioSrc))
</MACRO>
<MACRO>
<NAME>GST_GIO_SRC_CLASS</NAME>
#define GST_GIO_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GIO_SRC,GstGioSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GIO_SRC</NAME>
#define GST_IS_GIO_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GIO_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_GIO_SRC_CLASS</NAME>
#define GST_IS_GIO_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GIO_SRC))
</MACRO>
<STRUCT>
<NAME>GstGioSrc</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGioSrcClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGioSrc</NAME>
struct _GstGioSrc
{
  GstGioBaseSrc src;
  
  /*< private >*/
  GFile *file;
};
</STRUCT>
<STRUCT>
<NAME>GstGioSrcClass</NAME>
struct _GstGioSrcClass 
{
  GstGioBaseSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gio_src_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GIO_STREAM_SINK</NAME>
#define GST_TYPE_GIO_STREAM_SINK \
  (gst_gio_stream_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_GIO_STREAM_SINK</NAME>
#define GST_GIO_STREAM_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GIO_STREAM_SINK,GstGioStreamSink))
</MACRO>
<MACRO>
<NAME>GST_GIO_STREAM_SINK_CLASS</NAME>
#define GST_GIO_STREAM_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GIO_STREAM_SINK,GstGioStreamSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GIO_STREAM_SINK</NAME>
#define GST_IS_GIO_STREAM_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GIO_STREAM_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_GIO_STREAM_SINK_CLASS</NAME>
#define GST_IS_GIO_STREAM_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GIO_STREAM_SINK))
</MACRO>
<STRUCT>
<NAME>GstGioStreamSink</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGioStreamSinkClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGioStreamSink</NAME>
struct _GstGioStreamSink
{
  GstGioBaseSink sink;
  
  /* < private > */
  GOutputStream *stream;
};
</STRUCT>
<STRUCT>
<NAME>GstGioStreamSinkClass</NAME>
struct _GstGioStreamSinkClass 
{
  GstGioBaseSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gio_stream_sink_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GIO_STREAM_SRC</NAME>
#define GST_TYPE_GIO_STREAM_SRC \
  (gst_gio_stream_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_GIO_STREAM_SRC</NAME>
#define GST_GIO_STREAM_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GIO_STREAM_SRC,GstGioStreamSrc))
</MACRO>
<MACRO>
<NAME>GST_GIO_STREAM_SRC_CLASS</NAME>
#define GST_GIO_STREAM_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GIO_STREAM_SRC,GstGioStreamSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GIO_STREAM_SRC</NAME>
#define GST_IS_GIO_STREAM_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GIO_STREAM_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_GIO_STREAM_SRC_CLASS</NAME>
#define GST_IS_GIO_STREAM_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GIO_STREAM_SRC))
</MACRO>
<STRUCT>
<NAME>GstGioStreamSrc</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGioStreamSrcClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGioStreamSrc</NAME>
struct _GstGioStreamSrc
{
  GstGioBaseSrc src;

  /* < private > */
  GInputStream *stream;
};
</STRUCT>
<STRUCT>
<NAME>GstGioStreamSrcClass</NAME>
struct _GstGioStreamSrcClass 
{
  GstGioBaseSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gio_stream_src_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GNOME_VFS_SINK</NAME>
#define GST_TYPE_GNOME_VFS_SINK \
  (gst_gnome_vfs_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_GNOME_VFS_SINK</NAME>
#define GST_GNOME_VFS_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GNOME_VFS_SINK,GstGnomeVFSSink))
</MACRO>
<MACRO>
<NAME>GST_GNOME_VFS_SINK_CLASS</NAME>
#define GST_GNOME_VFS_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GNOME_VFS_SINK,GstGnomeVFSSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GNOME_VFS_SINK</NAME>
#define GST_IS_GNOME_VFS_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GNOME_VFS_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_GNOME_VFS_SINK_CLASS</NAME>
#define GST_IS_GNOME_VFS_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GNOME_VFS_SINK))
</MACRO>
<STRUCT>
<NAME>GstGnomeVFSSink</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGnomeVFSSinkClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGnomeVFSSink</NAME>
struct _GstGnomeVFSSink
{
  GstBaseSink basesink;

  /*< private >*/

  /* uri */
  GnomeVFSURI *uri;
  gchar *uri_name;

  /* handle */
  GnomeVFSHandle *handle;

  /* whether we opened the handle ourselves */
  gboolean own_handle;

  guint64  current_pos;
};
</STRUCT>
<STRUCT>
<NAME>GstGnomeVFSSinkClass</NAME>
struct _GstGnomeVFSSinkClass
{
  GstBaseSinkClass basesink_class;

  /* signals */
  gboolean (*erase_ask) (GstElement * element, GnomeVFSURI * uri);
};
</STRUCT>
<FUNCTION>
<NAME>gst_gnome_vfs_sink_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GNOME_VFS_SRC</NAME>
#define GST_TYPE_GNOME_VFS_SRC \
  (gst_gnome_vfs_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_GNOME_VFS_SRC</NAME>
#define GST_GNOME_VFS_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GNOME_VFS_SRC,GstGnomeVFSSrc))
</MACRO>
<MACRO>
<NAME>GST_GNOME_VFS_SRC_CLASS</NAME>
#define GST_GNOME_VFS_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GNOME_VFS_SRC,GstGnomeVFSSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GNOME_VFS_SRC</NAME>
#define GST_IS_GNOME_VFS_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GNOME_VFS_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_GNOME_VFS_SRC_CLASS</NAME>
#define GST_IS_GNOME_VFS_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GNOME_VFS_SRC))
</MACRO>
<STRUCT>
<NAME>GstGnomeVFSSrc</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGnomeVFSSrcClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGnomeVFSSrc</NAME>
struct _GstGnomeVFSSrc
{
  GstBaseSrc basesrc;

  /* uri, file, ... */
  GnomeVFSURI *uri;
  gchar *uri_name;
  GnomeVFSHandle *handle;
  gboolean own_handle;
  GnomeVFSFileOffset curoffset; /* current offset in file */
  gboolean seekable;

  /* shoutcast/icecast metadata extraction handling */
  gboolean iradio_mode;
  gboolean http_callbacks_pushed;

  gchar *iradio_name;
  gchar *iradio_genre;
  gchar *iradio_url;
  gchar *iradio_title;
};
</STRUCT>
<STRUCT>
<NAME>GstGnomeVFSSrcClass</NAME>
struct _GstGnomeVFSSrcClass
{
  GstBaseSrcClass  basesrc_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gnome_vfs_src_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_OGG_PAD</NAME>
#define GST_TYPE_OGG_PAD (gst_ogg_pad_get_type())
</MACRO>
<MACRO>
<NAME>GST_OGG_PAD</NAME>
#define GST_OGG_PAD(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OGG_PAD, GstOggPad))
</MACRO>
<MACRO>
<NAME>GST_OGG_PAD_CLASS</NAME>
#define GST_OGG_PAD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OGG_PAD, GstOggPad))
</MACRO>
<MACRO>
<NAME>GST_IS_OGG_PAD</NAME>
#define GST_IS_OGG_PAD(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OGG_PAD))
</MACRO>
<MACRO>
<NAME>GST_IS_OGG_PAD_CLASS</NAME>
#define GST_IS_OGG_PAD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_OGG_PAD))
</MACRO>
<STRUCT>
<NAME>GstOggPad</NAME>
</STRUCT>
<STRUCT>
<NAME>GstOggPadClass</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_OGG_DEMUX</NAME>
#define GST_TYPE_OGG_DEMUX (gst_ogg_demux_get_type())
</MACRO>
<MACRO>
<NAME>GST_OGG_DEMUX</NAME>
#define GST_OGG_DEMUX(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OGG_DEMUX, GstOggDemux))
</MACRO>
<MACRO>
<NAME>GST_OGG_DEMUX_CLASS</NAME>
#define GST_OGG_DEMUX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OGG_DEMUX, GstOggDemux))
</MACRO>
<MACRO>
<NAME>GST_IS_OGG_DEMUX</NAME>
#define GST_IS_OGG_DEMUX(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OGG_DEMUX))
</MACRO>
<MACRO>
<NAME>GST_IS_OGG_DEMUX_CLASS</NAME>
#define GST_IS_OGG_DEMUX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_OGG_DEMUX))
</MACRO>
<FUNCTION>
<NAME>gst_ogg_demux_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<STRUCT>
<NAME>GstOggDemux</NAME>
</STRUCT>
<STRUCT>
<NAME>GstOggDemuxClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstOggChain</NAME>
</STRUCT>
<STRUCT>
<NAME>GstOggChain</NAME>
struct _GstOggChain
{
  GstOggDemux *ogg;

  gint64 offset;                /* starting offset of chain */
  gint64 end_offset;            /* end offset of chain */
  gint64 bytes;                 /* number of bytes */

  gboolean have_bos;

  GArray *streams;

  GstClockTime total_time;      /* the total time of this chain, this is the MAX of
                                   the totals of all streams */
  GstClockTime begin_time;      /* when this chain starts in the stream */

  GstClockTime segment_start;   /* the timestamp of the first sample, this is the MIN of
                                   the start times of all streams. */
  GstClockTime segment_stop;    /* the timestamp of the last page, this is the MAX of the
                                   streams. */
};
</STRUCT>
<ENUM>
<NAME>GstOggPadMode</NAME>
typedef enum
{
  GST_OGG_PAD_MODE_INIT,        /* we are feeding our internal decoder to get info */
  GST_OGG_PAD_MODE_STREAMING,   /* we are streaming buffers to the outside */
} GstOggPadMode;
</ENUM>
<STRUCT>
<NAME>GstOggPad</NAME>
struct _GstOggPad
{
  GstPad pad;                   /* subclass GstPad */

  gboolean have_type;
  GstOggPadMode mode;

  GstOggChain *chain;           /* the chain we are part of */
  GstOggDemux *ogg;             /* the ogg demuxer we are part of */

  GstOggStream map;

  gint64 packetno;
  gint64 current_granule;
  gint64 keyframe_granule;

  GstClockTime start_time;      /* the timestamp of the first sample */

  gint64 first_granule;         /* the granulepos of first page == first sample in next page */
  GstClockTime first_time;      /* the timestamp of the second page or granuletime of first page */

  gboolean     is_sparse;       /* TRUE if this is a subtitle pad or some other sparse stream */
  GstClockTime last_stop;       /* last_stop when last push occured; used to detect when we
                                 * need to send a newsegment update event for sparse streams */

  GList *continued;

  gboolean discont;
  GstFlowReturn last_ret;       /* last return of _pad_push() */
  gboolean is_eos;

  gboolean added;
};
</STRUCT>
<STRUCT>
<NAME>GstOggPadClass</NAME>
struct _GstOggPadClass
{
  GstPadClass parent_class;
};
</STRUCT>
<STRUCT>
<NAME>GstOggDemux</NAME>
struct _GstOggDemux
{
  GstElement element;

  GstPad *sinkpad;

  gint64 length;
  gint64 read_offset;
  gint64 offset;

  gboolean pullmode;
  gboolean running;

  gboolean need_chains;
  gboolean resync;

  /* state */
  GMutex *chain_lock;           /* we need the lock to protect the chains */
  GArray *chains;               /* list of chains we know */
  GstClockTime total_time;
  gint bitrate;                 /* bitrate of the current chain */

  GstOggChain *current_chain;
  GstOggChain *building_chain;

  /* playback start/stop positions */
  GstSegment segment;
  gboolean segment_running;
  guint32  seqnum;

  GstEvent *event;
  GstEvent *newsegment;         /* pending newsegment to be sent from _loop */

  /* annodex stuff */
  gint64 basetime;
  gint64 prestime;

  /* ogg stuff */
  ogg_sync_state sync;
};
</STRUCT>
<STRUCT>
<NAME>GstOggDemuxClass</NAME>
struct _GstOggDemuxClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ogg_demux_plugin_init</NAME>
<RETURNS>gboolean </RETURNS>
GstPlugin * plugin 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_OGG_MUX</NAME>
#define GST_TYPE_OGG_MUX (gst_ogg_mux_get_type())
</MACRO>
<MACRO>
<NAME>GST_OGG_MUX</NAME>
#define GST_OGG_MUX(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_OGG_MUX, GstOggMux))
</MACRO>
<MACRO>
<NAME>GST_OGG_MUX_CLASS</NAME>
#define GST_OGG_MUX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_OGG_MUX, GstOggMux))
</MACRO>
<MACRO>
<NAME>GST_IS_OGG_MUX</NAME>
#define GST_IS_OGG_MUX(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_OGG_MUX))
</MACRO>
<MACRO>
<NAME>GST_IS_OGG_MUX_CLASS</NAME>
#define GST_IS_OGG_MUX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_OGG_MUX))
</MACRO>
<STRUCT>
<NAME>GstOggMux</NAME>
</STRUCT>
<STRUCT>
<NAME>GstOggMuxClass</NAME>
</STRUCT>
<ENUM>
<NAME>GstOggPadState</NAME>
typedef enum
{
  GST_OGG_PAD_STATE_CONTROL = 0,
  GST_OGG_PAD_STATE_DATA = 1
}
GstOggPadState;
</ENUM>
<STRUCT>
<NAME>GstOggMux</NAME>
struct _GstOggMux
{
  GstElement element;

  /* source pad */
  GstPad *srcpad;

  /* sinkpads */
  GstCollectPads *collect;

  /* number of pads which have not received EOS */
  gint active_pads;

  /* the pad we are currently using to fill a page */
  GstOggPadData *pulling;

  /* next timestamp for the page */
  GstClockTime next_ts;

  /* Last timestamp actually output on src pad */
  GstClockTime last_ts;

  /* offset in stream */
  guint64 offset;

  /* need_headers */
  gboolean need_headers;

  guint64 max_delay;
  guint64 max_page_delay;

  GstOggPadData *delta_pad;     /* when a delta frame is detected on a stream, we mark
                                   pages as delta frames up to the page that has the
                                   keyframe */

};
</STRUCT>
<STRUCT>
<NAME>GstOggMuxClass</NAME>
struct _GstOggMuxClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ogg_mux_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>gst_ogg_mux_plugin_init</NAME>
<RETURNS>gboolean </RETURNS>
GstPlugin * plugin 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CLOCK_OVERLAY</NAME>
#define GST_TYPE_CLOCK_OVERLAY \
  (gst_clock_overlay_get_type())
</MACRO>
<MACRO>
<NAME>GST_CLOCK_OVERLAY</NAME>
#define GST_CLOCK_OVERLAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CLOCK_OVERLAY,GstClockOverlay))
</MACRO>
<MACRO>
<NAME>GST_CLOCK_OVERLAY_CLASS</NAME>
#define GST_CLOCK_OVERLAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CLOCK_OVERLAY,GstClockOverlayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CLOCK_OVERLAY</NAME>
#define GST_IS_CLOCK_OVERLAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CLOCK_OVERLAY))
</MACRO>
<MACRO>
<NAME>GST_IS_CLOCK_OVERLAY_CLASS</NAME>
#define GST_IS_CLOCK_OVERLAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CLOCK_OVERLAY))
</MACRO>
<STRUCT>
<NAME>GstClockOverlay</NAME>
</STRUCT>
<STRUCT>
<NAME>GstClockOverlayClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstClockOverlay</NAME>
struct _GstClockOverlay {
  GstTextOverlay textoverlay;
	gchar         *format; /* as in strftime () */
};
</STRUCT>
<STRUCT>
<NAME>GstClockOverlayClass</NAME>
struct _GstClockOverlayClass {
  GstTextOverlayClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_clock_overlay_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>strftime</NAME>
<RETURNS>return </RETURNS>
s, max, format, tm 
</FUNCTION>
<MACRO>
<NAME>strftime</NAME>
#define strftime my_strftime
</MACRO>
<MACRO>
<NAME>GST_TYPE_TEXT_OVERLAY</NAME>
#define GST_TYPE_TEXT_OVERLAY            (gst_text_overlay_get_type())
</MACRO>
<MACRO>
<NAME>GST_TEXT_OVERLAY</NAME>
#define GST_TEXT_OVERLAY(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),\
                                         GST_TYPE_TEXT_OVERLAY, GstTextOverlay))
</MACRO>
<MACRO>
<NAME>GST_TEXT_OVERLAY_CLASS</NAME>
#define GST_TEXT_OVERLAY_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),\
                                         GST_TYPE_TEXT_OVERLAY,GstTextOverlayClass))
</MACRO>
<MACRO>
<NAME>GST_TEXT_OVERLAY_GET_CLASS</NAME>
#define GST_TEXT_OVERLAY_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),\
                                         GST_TYPE_TEXT_OVERLAY, GstTextOverlayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_TEXT_OVERLAY</NAME>
#define GST_IS_TEXT_OVERLAY(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),\
                                         GST_TYPE_TEXT_OVERLAY))
</MACRO>
<MACRO>
<NAME>GST_IS_TEXT_OVERLAY_CLASS</NAME>
#define GST_IS_TEXT_OVERLAY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),\
                                         GST_TYPE_TEXT_OVERLAY))
</MACRO>
<STRUCT>
<NAME>GstTextOverlay</NAME>
</STRUCT>
<STRUCT>
<NAME>GstTextOverlayClass</NAME>
</STRUCT>
<ENUM>
<NAME>GstTextOverlayVAlign</NAME>
typedef enum {
    GST_TEXT_OVERLAY_VALIGN_BASELINE,
    GST_TEXT_OVERLAY_VALIGN_BOTTOM,
    GST_TEXT_OVERLAY_VALIGN_TOP
} GstTextOverlayVAlign;
</ENUM>
<ENUM>
<NAME>GstTextOverlayHAlign</NAME>
typedef enum {
    GST_TEXT_OVERLAY_HALIGN_LEFT,
    GST_TEXT_OVERLAY_HALIGN_CENTER,
    GST_TEXT_OVERLAY_HALIGN_RIGHT
} GstTextOverlayHAlign;
</ENUM>
<ENUM>
<NAME>GstTextOverlayWrapMode</NAME>
typedef enum {
    GST_TEXT_OVERLAY_WRAP_MODE_NONE = -1,
    GST_TEXT_OVERLAY_WRAP_MODE_WORD = PANGO_WRAP_WORD,
    GST_TEXT_OVERLAY_WRAP_MODE_CHAR = PANGO_WRAP_CHAR,
    GST_TEXT_OVERLAY_WRAP_MODE_WORD_CHAR = PANGO_WRAP_WORD_CHAR
} GstTextOverlayWrapMode;
</ENUM>
<ENUM>
<NAME>GstTextOverlayLineAlign</NAME>
typedef enum {
    GST_TEXT_OVERLAY_LINE_ALIGN_LEFT = PANGO_ALIGN_LEFT,
    GST_TEXT_OVERLAY_LINE_ALIGN_CENTER = PANGO_ALIGN_CENTER,
    GST_TEXT_OVERLAY_LINE_ALIGN_RIGHT = PANGO_ALIGN_RIGHT
} GstTextOverlayLineAlign;
</ENUM>
<STRUCT>
<NAME>GstTextOverlay</NAME>
struct _GstTextOverlay {
    GstElement               element;

    GstPad                  *video_sinkpad;
    GstPad                  *text_sinkpad;
    GstPad                  *srcpad;

    GstSegment               segment;
    GstSegment               text_segment;
    GstBuffer               *text_buffer;
    gboolean                text_linked;
    gboolean                video_flushing;
    gboolean                video_eos;
    gboolean                text_flushing;
    gboolean                text_eos;

    GCond                   *cond;  /* to signal removal of a queued text
                                     * buffer, arrival of a text buffer,
                                     * a text segment update, or a change
                                     * in status (e.g. shutdown, flushing) */

    gint                     width;
    gint                     height;
    gint                     rowstride;
    gint                     fps_n;
    gint                     fps_d;
    GstVideoFormat           format;

    GstTextOverlayVAlign     valign;
    GstTextOverlayHAlign     halign;
    GstTextOverlayWrapMode   wrap_mode;
    GstTextOverlayLineAlign  line_align;

    gint                     xpad;
    gint                     ypad;
    gint                     deltax;
    gint                     deltay;
    gchar                   *default_text;
    gboolean                 want_shading;
    gboolean                 silent;
    gboolean                 wait_text;

    PangoLayout             *layout;
    gdouble                  shadow_offset;
    gdouble                  outline_offset;
    guchar                  *text_image;
    gint                     image_width;
    gint                     image_height;
    gint                     baseline_y;

    gboolean                 auto_adjust_size;
    gboolean                 need_render;

    gint                     shading_value;  /* for timeoverlay subclass */

    gboolean                 have_pango_markup;
    gboolean                 use_vertical_render;
};
</STRUCT>
<STRUCT>
<NAME>GstTextOverlayClass</NAME>
struct _GstTextOverlayClass {
    GstElementClass parent_class;

    PangoContext *pango_context;

    gchar *     (*get_text) (GstTextOverlay *overlay, GstBuffer *video_frame);
};
</STRUCT>
<FUNCTION>
<NAME>gst_text_overlay_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TEXT_RENDER</NAME>
#define GST_TYPE_TEXT_RENDER            (gst_text_render_get_type())
</MACRO>
<MACRO>
<NAME>GST_TEXT_RENDER</NAME>
#define GST_TEXT_RENDER(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),\
                                        GST_TYPE_TEXT_RENDER, GstTextRender))
</MACRO>
<MACRO>
<NAME>GST_TEXT_RENDER_CLASS</NAME>
#define GST_TEXT_RENDER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),\
                                        GST_TYPE_TEXT_RENDER, GstTextRenderClass))
</MACRO>
<MACRO>
<NAME>GST_TEXT_RENDER_GET_CLASS</NAME>
#define GST_TEXT_RENDER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),\
                                        GST_TYPE_TEXT_RENDER, GstTextRenderClass))
</MACRO>
<MACRO>
<NAME>GST_IS_TEXT_RENDER</NAME>
#define GST_IS_TEXT_RENDER(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),\
                                        GST_TYPE_TEXT_RENDER))
</MACRO>
<MACRO>
<NAME>GST_IS_TEXT_RENDER_CLASS</NAME>
#define GST_IS_TEXT_RENDER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),\
                                        GST_TYPE_TEXT_RENDER))
</MACRO>
<STRUCT>
<NAME>GstTextRender</NAME>
</STRUCT>
<STRUCT>
<NAME>GstTextRenderClass</NAME>
</STRUCT>
<ENUM>
<NAME>GstTextRenderVAlign</NAME>
typedef enum {
    GST_TEXT_RENDER_VALIGN_BASELINE,
    GST_TEXT_RENDER_VALIGN_BOTTOM,
    GST_TEXT_RENDER_VALIGN_TOP
} GstTextRenderVAlign;
</ENUM>
<ENUM>
<NAME>GstTextRenderHAlign</NAME>
typedef enum {
    GST_TEXT_RENDER_HALIGN_LEFT,
    GST_TEXT_RENDER_HALIGN_CENTER,
    GST_TEXT_RENDER_HALIGN_RIGHT
} GstTextRenderHAlign;
</ENUM>
<ENUM>
<NAME>GstTextRenderLineAlign</NAME>
typedef enum {
    GST_TEXT_RENDER_LINE_ALIGN_LEFT = PANGO_ALIGN_LEFT,
    GST_TEXT_RENDER_LINE_ALIGN_CENTER = PANGO_ALIGN_CENTER,
    GST_TEXT_RENDER_LINE_ALIGN_RIGHT = PANGO_ALIGN_RIGHT
} GstTextRenderLineAlign;
</ENUM>
<STRUCT>
<NAME>GstTextRender</NAME>
struct _GstTextRender {
    GstElement            element;

    GstPad               *sinkpad, *srcpad;
    gint                  width;
    gint                  height;
    PangoLayout          *layout;
    gdouble               shadow_offset;
    gdouble               outline_offset;
    guchar               *text_image;
    gint                  image_width;
    gint                  image_height;
    gint                  baseline_y;
    gboolean              use_ARGB;

    GstTextRenderVAlign     valign;
    GstTextRenderHAlign     halign;
    GstTextRenderLineAlign  line_align;

    gint xpad;
    gint ypad;
};
</STRUCT>
<STRUCT>
<NAME>GstTextRenderClass</NAME>
struct _GstTextRenderClass {
    GstElementClass parent_class;

    PangoContext *pango_context;
};
</STRUCT>
<FUNCTION>
<NAME>gst_text_render_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TIME_OVERLAY</NAME>
#define GST_TYPE_TIME_OVERLAY \
  (gst_time_overlay_get_type())
</MACRO>
<MACRO>
<NAME>GST_TIME_OVERLAY</NAME>
#define GST_TIME_OVERLAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_TIME_OVERLAY,GstTimeOverlay))
</MACRO>
<MACRO>
<NAME>GST_TIME_OVERLAY_CLASS</NAME>
#define GST_TIME_OVERLAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_TIME_OVERLAY,GstTimeOverlayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_TIME_OVERLAY</NAME>
#define GST_IS_TIME_OVERLAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_TIME_OVERLAY))
</MACRO>
<MACRO>
<NAME>GST_IS_TIME_OVERLAY_CLASS</NAME>
#define GST_IS_TIME_OVERLAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_TIME_OVERLAY))
</MACRO>
<STRUCT>
<NAME>GstTimeOverlay</NAME>
</STRUCT>
<STRUCT>
<NAME>GstTimeOverlayClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstTimeOverlay</NAME>
struct _GstTimeOverlay {
  GstTextOverlay textoverlay;
};
</STRUCT>
<STRUCT>
<NAME>GstTimeOverlayClass</NAME>
struct _GstTimeOverlayClass {
  GstTextOverlayClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_time_overlay_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_THEORA_DEC</NAME>
#define GST_TYPE_THEORA_DEC \
  (gst_theora_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_THEORA_DEC</NAME>
#define GST_THEORA_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_THEORA_DEC,GstTheoraDec))
</MACRO>
<MACRO>
<NAME>GST_THEORA_DEC_CLASS</NAME>
#define GST_THEORA_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_THEORA_DEC,GstTheoraDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_THEORA_DEC</NAME>
#define GST_IS_THEORA_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_THEORA_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_THEORA_DEC_CLASS</NAME>
#define GST_IS_THEORA_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_THEORA_DEC))
</MACRO>
<STRUCT>
<NAME>GstTheoraDec</NAME>
</STRUCT>
<STRUCT>
<NAME>GstTheoraDecClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstTheoraDec</NAME>
struct _GstTheoraDec
{
  GstElement element;

  /* Pads */
  GstPad *sinkpad;
  GstPad *srcpad;

  /* theora decoder state */
  th_dec_ctx *decoder;
  //theora_state state;
  th_setup_info *setup;
  th_info info;
  th_comment comment;

  gboolean have_header;

  GstClockTime last_timestamp;
  guint64 frame_nr;
  gboolean need_keyframe;
  gint width, height;
  gint offset_x, offset_y;
  gint output_bpp;

  gboolean crop;

  /* list of buffers that need timestamps */
  GList *queued;
  /* list of raw output buffers */
  GList *output;
  /* gather/decode queues for reverse playback */
  GList *gather;
  GList *decode;
  GList *pendingevents;

  GstTagList *tags;

  /* segment info */ /* with STREAM_LOCK */
  GstSegment segment;
  gboolean discont;
  guint32 seqnum;

  /* QoS stuff */ /* with LOCK*/
  gdouble proportion;
  GstClockTime earliest_time;
  guint64 processed;
  guint64 dropped;

  gboolean have_par;
  gint par_num;
  gint par_den;
};
</STRUCT>
<STRUCT>
<NAME>GstTheoraDecClass</NAME>
struct _GstTheoraDecClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_theora_dec_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_THEORA_ENC</NAME>
#define GST_TYPE_THEORA_ENC \
  (gst_theora_enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_THEORA_ENC</NAME>
#define GST_THEORA_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_THEORA_ENC,GstTheoraEnc))
</MACRO>
<MACRO>
<NAME>GST_THEORA_ENC_CLASS</NAME>
#define GST_THEORA_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_THEORA_ENC,GstTheoraEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_THEORA_ENC</NAME>
#define GST_IS_THEORA_ENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_THEORA_ENC))
</MACRO>
<MACRO>
<NAME>GST_IS_THEORA_ENC_CLASS</NAME>
#define GST_IS_THEORA_ENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_THEORA_ENC))
</MACRO>
<STRUCT>
<NAME>GstTheoraEnc</NAME>
</STRUCT>
<STRUCT>
<NAME>GstTheoraEncClass</NAME>
</STRUCT>
<ENUM>
<NAME>GstTheoraEncBorderMode</NAME>
typedef enum
{
  BORDER_NONE,
  BORDER_BLACK,
  BORDER_MIRROR
}
GstTheoraEncBorderMode;
</ENUM>
<STRUCT>
<NAME>GstTheoraEnc</NAME>
struct _GstTheoraEnc
{
  GstElement element;

  GstPad *sinkpad;
  GstPad *srcpad;

  GstSegment segment;

  ogg_stream_state to;

  th_enc_ctx *encoder;
  th_info info;
  th_comment comment;
  gboolean initialised;

  gint video_bitrate;           /* bitrate target for Theora video */
  gint video_quality;           /* Theora quality selector 0 = low, 63 = high */
  gboolean keyframe_auto;
  gint keyframe_freq;
  gint keyframe_force;

  gint info_width, info_height;
  gint width, height;
  gint fps_n, fps_d;
  GstClockTime next_ts;

  GstClockTime expected_ts;
  gboolean next_discont;

  gboolean force_keyframe;

  guint packetno;
  guint64 bytes_out;
  guint64 granulepos_offset;
  guint64 timestamp_offset;

  gint speed_level;
  gboolean vp3_compatible;
  gboolean drop_frames;
  gboolean cap_overflow;
  gboolean cap_underflow;
  int rate_buffer;
};
</STRUCT>
<STRUCT>
<NAME>GstTheoraEncClass</NAME>
struct _GstTheoraEncClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_theora_enc_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_THEORA_PARSE</NAME>
#define GST_TYPE_THEORA_PARSE \
  (gst_theora_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_THEORA_PARSE</NAME>
#define GST_THEORA_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_THEORA_PARSE,GstTheoraParse))
</MACRO>
<MACRO>
<NAME>GST_THEORA_PARSE_CLASS</NAME>
#define GST_THEORA_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_THEORA_PARSE,GstTheoraParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_THEORA_PARSE</NAME>
#define GST_IS_THEORA_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_THEORA_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_THEORA_PARSE_CLASS</NAME>
#define GST_IS_THEORA_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_THEORA_PARSE))
</MACRO>
<STRUCT>
<NAME>GstTheoraParse</NAME>
</STRUCT>
<STRUCT>
<NAME>GstTheoraParseClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstTheoraParse</NAME>
struct _GstTheoraParse {
  GstElement            element;

  GstPad *              sinkpad;
  GstPad *              srcpad;

  gboolean              send_streamheader;
  gboolean              streamheader_received;
  gboolean		is_old_bitstream;
  GstBuffer *		streamheader[3];

  GQueue *		event_queue;
  GQueue *		buffer_queue;

  th_info		info;
  th_comment            comment;

  gint64		prev_frame;
  gint64		prev_keyframe;
  guint32		fps_n;
  guint32		fps_d;
  gint			shift;
  gint64		granule_offset;

  GstClockTime		*times;
  gint			npairs;
};
</STRUCT>
<STRUCT>
<NAME>GstTheoraParseClass</NAME>
struct _GstTheoraParseClass {
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_theora_parse_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VORBIS_DEC</NAME>
#define GST_TYPE_VORBIS_DEC \
  (gst_vorbis_dec_get_type())
</MACRO>
<MACRO>
<NAME>GST_VORBIS_DEC</NAME>
#define GST_VORBIS_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VORBIS_DEC,GstVorbisDec))
</MACRO>
<MACRO>
<NAME>GST_VORBIS_DEC_CLASS</NAME>
#define GST_VORBIS_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VORBIS_DEC,GstVorbisDecClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VORBIS_DEC</NAME>
#define GST_IS_VORBIS_DEC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VORBIS_DEC))
</MACRO>
<MACRO>
<NAME>GST_IS_VORBIS_DEC_CLASS</NAME>
#define GST_IS_VORBIS_DEC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VORBIS_DEC))
</MACRO>
<STRUCT>
<NAME>GstVorbisDec</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVorbisDecClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVorbisDec</NAME>
struct _GstVorbisDec {
  GstElement        element;

  GstPad           *sinkpad;
  GstPad           *srcpad;

  vorbis_dsp_state  vd;
  vorbis_info       vi;
  vorbis_comment    vc;
  vorbis_block      vb;

  gboolean          initialized;
  guint             width;

  /* list of buffers that need timestamps */
  GList            *queued;
  /* gather/decode queues for reverse playback */
  GList            *gather;
  GList            *decode;

  GstSegment        segment;
  gboolean          discont;
  guint32           seqnum;

  GstClockTime      last_timestamp;

  GList            *pendingevents;
  GstTagList       *taglist;
  
  CopySampleFunc    copy_samples;
};
</STRUCT>
<STRUCT>
<NAME>GstVorbisDecClass</NAME>
struct _GstVorbisDecClass {
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vorbis_dec_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VORBISENC</NAME>
#define GST_TYPE_VORBISENC \
  (gst_vorbis_enc_get_type())
</MACRO>
<MACRO>
<NAME>GST_VORBISENC</NAME>
#define GST_VORBISENC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VORBISENC,GstVorbisEnc))
</MACRO>
<MACRO>
<NAME>GST_VORBISENC_CLASS</NAME>
#define GST_VORBISENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VORBISENC,GstVorbisEncClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VORBISENC</NAME>
#define GST_IS_VORBISENC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VORBISENC))
</MACRO>
<MACRO>
<NAME>GST_IS_VORBISENC_CLASS</NAME>
#define GST_IS_VORBISENC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VORBISENC))
</MACRO>
<STRUCT>
<NAME>GstVorbisEnc</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVorbisEncClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVorbisEnc</NAME>
struct _GstVorbisEnc {
  GstElement       element;

  GstPad          *sinkpad;
  GstPad          *srcpad;

  GstCaps         *srccaps;
  GstCaps         *sinkcaps;

  vorbis_info      vi; /* struct that stores all the static vorbis bitstream
                                                            settings */
  vorbis_comment   vc; /* struct that stores all the user comments */

  vorbis_dsp_state vd; /* central working state for the packet->PCM decoder */
  vorbis_block     vb; /* local working space for packet->PCM decode */

  gboolean         managed;
  gint             bitrate;
  gint             min_bitrate;
  gint             max_bitrate;
  gfloat           quality;
  gboolean         quality_set;

  gint             channels;
  gint             frequency;

  guint64          samples_in;
  guint64          bytes_out;
  GstClockTime     next_ts;
  GstClockTime     expected_ts;
  gboolean         next_discont;
  guint64          granulepos_offset;
  gint64           subgranule_offset;
  GstSegment       segment;
  GstClockTime     initial_ts;

  GstTagList *     tags;

  gboolean         setup;
  gboolean         header_sent;
  gchar           *last_message;
};
</STRUCT>
<STRUCT>
<NAME>GstVorbisEncClass</NAME>
struct _GstVorbisEncClass {
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vorbis_enc_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VORBIS_PARSE</NAME>
#define GST_TYPE_VORBIS_PARSE \
  (gst_vorbis_parse_get_type())
</MACRO>
<MACRO>
<NAME>GST_VORBIS_PARSE</NAME>
#define GST_VORBIS_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VORBIS_PARSE,GstVorbisParse))
</MACRO>
<MACRO>
<NAME>GST_VORBIS_PARSE_CLASS</NAME>
#define GST_VORBIS_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VORBIS_PARSE,GstVorbisParseClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VORBIS_PARSE</NAME>
#define GST_IS_VORBIS_PARSE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VORBIS_PARSE))
</MACRO>
<MACRO>
<NAME>GST_IS_VORBIS_PARSE_CLASS</NAME>
#define GST_IS_VORBIS_PARSE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VORBIS_PARSE))
</MACRO>
<STRUCT>
<NAME>GstVorbisParse</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVorbisParseClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVorbisParse</NAME>
struct _GstVorbisParse {
  GstElement            element;

  GstPad *              sinkpad;
  GstPad *              srcpad;

  guint                 packetno;
  gboolean              streamheader_sent;
  GList *               streamheader;

  GQueue *		event_queue;
  GQueue *		buffer_queue;

  vorbis_info		vi;
  vorbis_comment	vc;

  gint64		prev_granulepos;
  gint32		prev_blocksize;
  guint32		sample_rate;
};
</STRUCT>
<STRUCT>
<NAME>GstVorbisParseClass</NAME>
struct _GstVorbisParseClass {
  GstElementClass parent_class;

  /* virtual functions */
  GstFlowReturn  (*parse_packet) (GstVorbisParse * parse, GstBuffer * buf);
};
</STRUCT>
<FUNCTION>
<NAME>gst_vorbis_parse_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VORBIS_TAG</NAME>
#define GST_TYPE_VORBIS_TAG \
  (gst_vorbis_tag_get_type())
</MACRO>
<MACRO>
<NAME>GST_VORBIS_TAG</NAME>
#define GST_VORBIS_TAG(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VORBIS_TAG,GstVorbisTag))
</MACRO>
<MACRO>
<NAME>GST_VORBIS_TAG_CLASS</NAME>
#define GST_VORBIS_TAG_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VORBIS_TAG,GstVorbisTagClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VORBIS_TAG</NAME>
#define GST_IS_VORBIS_TAG(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VORBIS_TAG))
</MACRO>
<MACRO>
<NAME>GST_IS_VORBIS_TAG_CLASS</NAME>
#define GST_IS_VORBIS_TAG_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VORBIS_TAG))
</MACRO>
<STRUCT>
<NAME>GstVorbisTag</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVorbisTagClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVorbisTag</NAME>
struct _GstVorbisTag {
  GstVorbisParse parse;
};
</STRUCT>
<STRUCT>
<NAME>GstVorbisTagClass</NAME>
struct _GstVorbisTagClass {
  GstVorbisParseClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_vorbis_tag_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_ADDER</NAME>
#define GST_TYPE_ADDER            (gst_adder_get_type())
</MACRO>
<MACRO>
<NAME>GST_ADDER</NAME>
#define GST_ADDER(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ADDER,GstAdder))
</MACRO>
<MACRO>
<NAME>GST_IS_ADDER</NAME>
#define GST_IS_ADDER(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ADDER))
</MACRO>
<MACRO>
<NAME>GST_ADDER_CLASS</NAME>
#define GST_ADDER_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass) ,GST_TYPE_ADDER,GstAdderClass))
</MACRO>
<MACRO>
<NAME>GST_IS_ADDER_CLASS</NAME>
#define GST_IS_ADDER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass) ,GST_TYPE_ADDER))
</MACRO>
<MACRO>
<NAME>GST_ADDER_GET_CLASS</NAME>
#define GST_ADDER_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS((obj) ,GST_TYPE_ADDER,GstAdderClass))
</MACRO>
<STRUCT>
<NAME>GstAdder</NAME>
</STRUCT>
<STRUCT>
<NAME>GstAdderClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstAdderInputChannel</NAME>
</STRUCT>
<ENUM>
<NAME>GstAdderFormat</NAME>
typedef enum {
  GST_ADDER_FORMAT_UNSET,
  GST_ADDER_FORMAT_INT,
  GST_ADDER_FORMAT_FLOAT
} GstAdderFormat;
</ENUM>
<USER_FUNCTION>
<NAME>GstAdderFunction</NAME>
<RETURNS>void </RETURNS>
gpointer out, gpointer in, guint size
</USER_FUNCTION>
<STRUCT>
<NAME>GstAdder</NAME>
struct _GstAdder {
  GstElement      element;

  GstPad         *srcpad;
  GstCollectPads *collect;
  /* pad counter, used for creating unique request pads */
  gint            padcount;

  /* the next are valid for both int and float */
  GstAdderFormat  format;
  gint            rate;
  gint            channels;
  gint            width;
  gint            endianness;
  int             sample_size;

  /* the next are valid only for format == GST_ADDER_FORMAT_INT */
  gint            depth;
  gboolean        is_signed;

  /* number of bytes per sample, actually width/8 * channels */
  gint            bps;

  /* function to add samples */
  GstAdderFunction func;

  /* counters to keep track of timestamps */
  gint64          timestamp;
  gint64          offset;

  /* sink event handling */
  GstPadEventFunction  collect_event;
  GstSegment      segment;
  gboolean        segment_pending;
  guint64         segment_start, segment_end;
  gdouble         segment_rate;
  /* src event handling */
  gboolean        flush_stop_pending;
  
  /* target caps */
  GstCaps *filter_caps;

  /* Pending inline events */
  GList *pending_events;
};
</STRUCT>
<STRUCT>
<NAME>GstAdderClass</NAME>
struct _GstAdderClass {
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_adder_get_type</NAME>
<RETURNS>GType    </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_CAT_DEFAULT</NAME>
#define GST_CAT_DEFAULT (audio_convert_debug)
</MACRO>
<ENUM>
<NAME>GstAudioConvertDithering</NAME>
typedef enum
{
  DITHER_NONE = 0,
  DITHER_RPDF,
  DITHER_TPDF,
  DITHER_TPDF_HF
} GstAudioConvertDithering;
</ENUM>
<ENUM>
<NAME>GstAudioConvertNoiseShaping</NAME>
typedef enum
{
  NOISE_SHAPING_NONE = 0,
  NOISE_SHAPING_ERROR_FEEDBACK,
  NOISE_SHAPING_SIMPLE,
  NOISE_SHAPING_MEDIUM,
  NOISE_SHAPING_HIGH
} GstAudioConvertNoiseShaping;
</ENUM>
<STRUCT>
<NAME>AudioConvertCtx</NAME>
</STRUCT>
<STRUCT>
<NAME>AudioConvertFmt</NAME>
</STRUCT>
<STRUCT>
<NAME>AudioConvertFmt</NAME>
struct _AudioConvertFmt
{
  /* general caps */
  gboolean is_int;
  gint endianness;
  gint width;
  gint rate;
  gint channels;
  GstAudioChannelPosition *pos;
  gboolean unpositioned_layout;

  /* int audio caps */
  gboolean sign;
  gint depth;

  gint unit_size;
};
</STRUCT>
<USER_FUNCTION>
<NAME>AudioConvertUnpack</NAME>
<RETURNS>void </RETURNS>
gpointer src, gpointer dst, gint scale,
    gint count
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>AudioConvertPack</NAME>
<RETURNS>void </RETURNS>
gpointer src, gpointer dst, gint scale,
    gint count
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>AudioConvertMix</NAME>
<RETURNS>void </RETURNS>
AudioConvertCtx *, gpointer, gpointer, gint
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>AudioConvertQuantize</NAME>
<RETURNS>void </RETURNS>
AudioConvertCtx * ctx, gpointer src,
    gpointer dst, gint count
</USER_FUNCTION>
<STRUCT>
<NAME>AudioConvertCtx</NAME>
struct _AudioConvertCtx
{
  AudioConvertFmt in;
  AudioConvertFmt out;

  AudioConvertUnpack unpack;
  AudioConvertPack pack;

  /* channel conversion matrix, m[in_channels][out_channels].
   * If identity matrix, passthrough applies. */
  gfloat **matrix;
  /* temp storage for channelmix */
  gpointer tmp;

  gboolean in_default;
  gboolean mix_passthrough;
  gboolean out_default;

  gpointer tmpbuf;
  gint tmpbufsize;

  gint in_scale;
  gint out_scale;

  AudioConvertMix channel_mix;

  AudioConvertQuantize quantize;

  GstAudioConvertDithering dither;
  GstAudioConvertNoiseShaping ns;
  /* last random number generated per channel for hifreq TPDF dither */
  gpointer last_random;
  /* contains the past quantization errors, error[out_channels][count] */
  gdouble *error_buf;
};
</STRUCT>
<FUNCTION>
<NAME>audio_convert_clean_fmt</NAME>
<RETURNS>gboolean </RETURNS>
AudioConvertFmt * fmt 
</FUNCTION>
<FUNCTION>
<NAME>audio_convert_prepare_context</NAME>
<RETURNS>gboolean </RETURNS>
AudioConvertCtx * ctx, AudioConvertFmt * in, AudioConvertFmt * out, GstAudioConvertDithering dither, GstAudioConvertNoiseShaping ns 
</FUNCTION>
<FUNCTION>
<NAME>audio_convert_get_sizes</NAME>
<RETURNS>gboolean </RETURNS>
AudioConvertCtx * ctx, gint samples, gint * srcsize, gint * dstsize 
</FUNCTION>
<FUNCTION>
<NAME>audio_convert_clean_context</NAME>
<RETURNS>gboolean </RETURNS>
AudioConvertCtx * ctx 
</FUNCTION>
<FUNCTION>
<NAME>audio_convert_convert</NAME>
<RETURNS>gboolean </RETURNS>
AudioConvertCtx * ctx, gpointer src, gpointer dst, gint samples, gboolean src_writable 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUDIO_CONVERT</NAME>
#define GST_TYPE_AUDIO_CONVERT            (gst_audio_convert_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_CONVERT</NAME>
#define GST_AUDIO_CONVERT(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_CONVERT,GstAudioConvert))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_CONVERT_CLASS</NAME>
#define GST_AUDIO_CONVERT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AUDIO_CONVERT,GstAudioConvertClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_CONVERT</NAME>
#define GST_IS_AUDIO_CONVERT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_CONVERT))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_CONVERT_CLASS</NAME>
#define GST_IS_AUDIO_CONVERT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AUDIO_CONVERT))
</MACRO>
<STRUCT>
<NAME>GstAudioConvert</NAME>
</STRUCT>
<STRUCT>
<NAME>GstAudioConvertClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstAudioConvert</NAME>
struct _GstAudioConvert
{
  GstBaseTransform element;

  AudioConvertCtx ctx;

  GstAudioConvertDithering dither;
  GstAudioConvertNoiseShaping ns;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioConvertClass</NAME>
struct _GstAudioConvertClass
{
  GstBaseTransformClass parent_class;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_AUDIO_TEST_SRC</NAME>
#define GST_TYPE_AUDIO_TEST_SRC \
  (gst_audio_test_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_TEST_SRC</NAME>
#define GST_AUDIO_TEST_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_TEST_SRC,GstAudioTestSrc))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_TEST_SRC_CLASS</NAME>
#define GST_AUDIO_TEST_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AUDIO_TEST_SRC,GstAudioTestSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_TEST_SRC</NAME>
#define GST_IS_AUDIO_TEST_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_TEST_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_TEST_SRC_CLASS</NAME>
#define GST_IS_AUDIO_TEST_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AUDIO_TEST_SRC))
</MACRO>
<ENUM>
<NAME>GstAudioTestSrcWave</NAME>
typedef enum {
  GST_AUDIO_TEST_SRC_WAVE_SINE,
  GST_AUDIO_TEST_SRC_WAVE_SQUARE,
  GST_AUDIO_TEST_SRC_WAVE_SAW,
  GST_AUDIO_TEST_SRC_WAVE_TRIANGLE,
  GST_AUDIO_TEST_SRC_WAVE_SILENCE,
  GST_AUDIO_TEST_SRC_WAVE_WHITE_NOISE,
  GST_AUDIO_TEST_SRC_WAVE_PINK_NOISE,
  GST_AUDIO_TEST_SRC_WAVE_SINE_TAB,
  GST_AUDIO_TEST_SRC_WAVE_TICKS,
  GST_AUDIO_TEST_SRC_WAVE_GAUSSIAN_WHITE_NOISE
} GstAudioTestSrcWave; 
</ENUM>
<MACRO>
<NAME>PINK_MAX_RANDOM_ROWS</NAME>
#define PINK_MAX_RANDOM_ROWS   (30)
</MACRO>
<MACRO>
<NAME>PINK_RANDOM_BITS</NAME>
#define PINK_RANDOM_BITS       (16)
</MACRO>
<MACRO>
<NAME>PINK_RANDOM_SHIFT</NAME>
#define PINK_RANDOM_SHIFT      ((sizeof(long)*8)-PINK_RANDOM_BITS)
</MACRO>
<STRUCT>
<NAME>GstPinkNoise</NAME>
typedef struct {
  glong      rows[PINK_MAX_RANDOM_ROWS];
  glong      running_sum;   /* Used to optimize summing of generators. */
  gint       index;         /* Incremented each sample. */
  gint       index_mask;    /* Index wrapped by ANDing with this mask. */
  gdouble    scalar;        /* Used to scale within range of -1.0 to +1.0 */
} GstPinkNoise;
</STRUCT>
<ENUM>
<NAME>GstAudioTestSrcFormat</NAME>
typedef enum {
  GST_AUDIO_TEST_SRC_FORMAT_NONE = -1,
  GST_AUDIO_TEST_SRC_FORMAT_S16 = 0,
  GST_AUDIO_TEST_SRC_FORMAT_S32,
  GST_AUDIO_TEST_SRC_FORMAT_F32,
  GST_AUDIO_TEST_SRC_FORMAT_F64
} GstAudioTestSrcFormat;
</ENUM>
<STRUCT>
<NAME>GstAudioTestSrc</NAME>
</STRUCT>
<STRUCT>
<NAME>GstAudioTestSrcClass</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>ProcessFunc</NAME>
<RETURNS>void </RETURNS>
GstAudioTestSrc*, guint8 *
</USER_FUNCTION>
<STRUCT>
<NAME>GstAudioTestSrc</NAME>
struct _GstAudioTestSrc {
  GstBaseSrc parent;

  ProcessFunc process;

  /* parameters */
  GstAudioTestSrcWave wave;
  gdouble volume;
  gdouble freq;
    
  /* audio parameters */
  gint channels;
  gint samplerate;
  gint samples_per_buffer;
  gint sample_size;
  GstAudioTestSrcFormat format;
  
  /*< private >*/
  gboolean tags_pushed;			/* send tags just once ? */
  GstClockTimeDiff timestamp_offset;    /* base offset */
  GstClockTime next_time;               /* next timestamp */
  gint64 next_sample;                   /* next sample to send */
  gint64 next_byte;                     /* next byte to send */
  gint64 sample_stop;
  gboolean check_seek_stop;
  gboolean eos_reached;
  gint generate_samples_per_buffer;	/* used to generate a partial buffer */
  gboolean can_activate_pull;
  gboolean reverse;                  /* play backwards */
  
  /* waveform specific context data */
  gdouble accumulator;			/* phase angle */
  GstPinkNoise pink;
  gdouble wave_table[1024];
};
</STRUCT>
<STRUCT>
<NAME>GstAudioTestSrcClass</NAME>
struct _GstAudioTestSrcClass {
  GstBaseSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_audio_test_src_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_FFMPEGCSP</NAME>
#define GST_TYPE_FFMPEGCSP 	      (gst_ffmpegcsp_get_type())
</MACRO>
<MACRO>
<NAME>GST_FFMPEGCSP</NAME>
#define GST_FFMPEGCSP(obj) 	      (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_FFMPEGCSP,GstFFMpegCsp))
</MACRO>
<MACRO>
<NAME>GST_FFMPEGCSP_CLASS</NAME>
#define GST_FFMPEGCSP_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_FFMPEGCSP,GstFFMpegCspClass))
</MACRO>
<MACRO>
<NAME>GST_IS_FFMPEGCSP</NAME>
#define GST_IS_FFMPEGCSP(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_FFMPEGCSP))
</MACRO>
<MACRO>
<NAME>GST_IS_FFMPEGCSP_CLASS</NAME>
#define GST_IS_FFMPEGCSP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_FFMPEGCSP))
</MACRO>
<STRUCT>
<NAME>GstFFMpegCsp</NAME>
</STRUCT>
<STRUCT>
<NAME>GstFFMpegCspClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstFFMpegCsp</NAME>
struct _GstFFMpegCsp {
  GstVideoFilter element;

  gint width, height;
  gint in_stride, out_stride;
  gboolean interlaced;
  gfloat fps;
  enum PixelFormat from_pixfmt, to_pixfmt;
  AVPicture from_frame, to_frame;
  AVPaletteControl *palette;
};
</STRUCT>
<STRUCT>
<NAME>GstFFMpegCspClass</NAME>
struct _GstFFMpegCspClass
{
  GstVideoFilterClass parent_class;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_GDP_DEPAY</NAME>
#define GST_TYPE_GDP_DEPAY \
  (gst_gdp_depay_get_type())
</MACRO>
<MACRO>
<NAME>GST_GDP_DEPAY</NAME>
#define GST_GDP_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GDP_DEPAY,GstGDPDepay))
</MACRO>
<MACRO>
<NAME>GST_GDP_DEPAY_CLASS</NAME>
#define GST_GDP_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GDP_DEPAY,GstGDPDepayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GDP_DEPAY</NAME>
#define GST_IS_GDP_DEPAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GDP_DEPAY))
</MACRO>
<MACRO>
<NAME>GST_IS_GDP_DEPAY_CLASS</NAME>
#define GST_IS_GDP_DEPAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GDP_DEPAY))
</MACRO>
<ENUM>
<NAME>GstGDPDepayState</NAME>
typedef enum {
  GST_GDP_DEPAY_STATE_HEADER = 0,
  GST_GDP_DEPAY_STATE_PAYLOAD,
  GST_GDP_DEPAY_STATE_BUFFER,
  GST_GDP_DEPAY_STATE_CAPS,
  GST_GDP_DEPAY_STATE_EVENT,
} GstGDPDepayState;
</ENUM>
<STRUCT>
<NAME>GstGDPDepay</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGDPDepayClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGDPDepay</NAME>
struct _GstGDPDepay
{
  GstElement element;
  GstPad *sinkpad;
  GstPad *srcpad;

  GstAdapter *adapter;
  GstGDPDepayState state;
  GstCaps *caps;

  guint8 *header;
  guint32 payload_length;
  GstDPPayloadType payload_type;
};
</STRUCT>
<STRUCT>
<NAME>GstGDPDepayClass</NAME>
struct _GstGDPDepayClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gdp_depay_plugin_init</NAME>
<RETURNS>gboolean </RETURNS>
GstPlugin * plugin 
</FUNCTION>
<FUNCTION>
<NAME>gst_gdp_depay_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GDP_PAY</NAME>
#define GST_TYPE_GDP_PAY \
  (gst_gdp_pay_get_type())
</MACRO>
<MACRO>
<NAME>GST_GDP_PAY</NAME>
#define GST_GDP_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_GDP_PAY,GstGDPPay))
</MACRO>
<MACRO>
<NAME>GST_GDP_PAY_CLASS</NAME>
#define GST_GDP_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_GDP_PAY,GstGDPPayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_GDP_PAY</NAME>
#define GST_IS_GDP_PAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_GDP_PAY))
</MACRO>
<MACRO>
<NAME>GST_IS_GDP_PAY_CLASS</NAME>
#define GST_IS_GDP_PAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_GDP_PAY))
</MACRO>
<STRUCT>
<NAME>GstGDPPay</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGDPPayClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstGDPPay</NAME>
struct _GstGDPPay
{
  GstElement element;

  GstPad *sinkpad;
  GstPad *srcpad;

  GstCaps *caps; /* incoming caps */

  GstBuffer *caps_buf;
  GstBuffer *new_segment_buf;
  GstBuffer *tag_buf;

  gboolean sent_streamheader; /* TRUE after the first streamheaders are sent */
  GList *queue; /* list of queued buffers before streamheaders are sent */
  guint64 offset;

  gboolean crc_header;
  gboolean crc_payload;
  GstDPHeaderFlag header_flag;
  GstDPVersion version;
  GstDPPacketizer *packetizer;
};
</STRUCT>
<STRUCT>
<NAME>GstGDPPayClass</NAME>
struct _GstGDPPayClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_gdp_pay_plugin_init</NAME>
<RETURNS>gboolean </RETURNS>
GstPlugin * plugin 
</FUNCTION>
<FUNCTION>
<NAME>gst_gdp_pay_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<ENUM>
<NAME>GstAutoplugSelectResult</NAME>
typedef enum {
  GST_AUTOPLUG_SELECT_TRY,
  GST_AUTOPLUG_SELECT_EXPOSE,
  GST_AUTOPLUG_SELECT_SKIP
} GstAutoplugSelectResult;
</ENUM>
<MACRO>
<NAME>GST_TYPE_AUTOPLUG_SELECT_RESULT</NAME>
#define GST_TYPE_AUTOPLUG_SELECT_RESULT (gst_autoplug_select_result_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_autoplug_select_result_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<ENUM>
<NAME>GstPlayFlags</NAME>
typedef enum {
  GST_PLAY_FLAG_VIDEO         = (1 << 0),
  GST_PLAY_FLAG_AUDIO         = (1 << 1),
  GST_PLAY_FLAG_TEXT          = (1 << 2),
  GST_PLAY_FLAG_VIS           = (1 << 3),
  GST_PLAY_FLAG_SOFT_VOLUME   = (1 << 4),
  GST_PLAY_FLAG_NATIVE_AUDIO  = (1 << 5),
  GST_PLAY_FLAG_NATIVE_VIDEO  = (1 << 6),
  GST_PLAY_FLAG_DOWNLOAD      = (1 << 7),
  GST_PLAY_FLAG_BUFFERING     = (1 << 8),
  GST_PLAY_FLAG_DEINTERLACE   = (1 << 9)
} GstPlayFlags;
</ENUM>
<MACRO>
<NAME>GST_TYPE_PLAY_FLAGS</NAME>
#define GST_TYPE_PLAY_FLAGS (gst_play_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_play_flags_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SUBTITLE_OVERLAY</NAME>
#define GST_TYPE_SUBTITLE_OVERLAY \
  (gst_subtitle_overlay_get_type())
</MACRO>
<MACRO>
<NAME>GST_SUBTITLE_OVERLAY</NAME>
#define GST_SUBTITLE_OVERLAY(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_SUBTITLE_OVERLAY, GstSubtitleOverlay))
</MACRO>
<MACRO>
<NAME>GST_SUBTITLE_OVERLAY_CAST</NAME>
#define GST_SUBTITLE_OVERLAY_CAST(obj) \
  ((GstSubtitleOverlay *) obj)
</MACRO>
<MACRO>
<NAME>GST_SUBTITLE_OVERLAY_CLASS</NAME>
#define GST_SUBTITLE_OVERLAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_SUBTITLE_OVERLAY, GstSubtitleOverlayClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SUBTITLE_OVERLAY</NAME>
#define GST_IS_SUBTITLE_OVERLAY(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_SUBTITLE_OVERLAY))
</MACRO>
<MACRO>
<NAME>GST_IS_SUBTITLE_OVERLAY_CLASS</NAME>
#define GST_IS_SUBTITLE_OVERLAY_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_SUBTITLE_OVERLAY))
</MACRO>
<MACRO>
<NAME>GST_SUBTITLE_OVERLAY_LOCK</NAME>
#define GST_SUBTITLE_OVERLAY_LOCK(obj) G_STMT_START {                   \
    GST_LOG_OBJECT (obj,                                                \
                    "locking from thread %p",                           \
                    g_thread_self ());                                  \
    g_mutex_lock (GST_SUBTITLE_OVERLAY_CAST(obj)->lock);                \
    GST_LOG_OBJECT (obj,                                                \
                    "locked from thread %p",                            \
                    g_thread_self ());                                  \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_SUBTITLE_OVERLAY_UNLOCK</NAME>
#define GST_SUBTITLE_OVERLAY_UNLOCK(obj) G_STMT_START {                 \
    GST_LOG_OBJECT (obj,                                                \
                    "unlocking from thread %p",                         \
                    g_thread_self ());                                  \
    g_mutex_unlock (GST_SUBTITLE_OVERLAY_CAST(obj)->lock);              \
} G_STMT_END
</MACRO>
<STRUCT>
<NAME>GstSubtitleOverlay</NAME>
</STRUCT>
<STRUCT>
<NAME>GstSubtitleOverlayClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstSubtitleOverlay</NAME>
struct _GstSubtitleOverlay
{
  GstBin parent;

  gboolean silent;
  gchar *font_desc;
  gchar *encoding;

  /* < private > */
  gboolean do_async;

  GstPad *srcpad;
  GstPadEventFunction src_proxy_event;
  GstPadChainFunction src_proxy_chain;
  gboolean downstream_chain_error;

  GstPad *video_sinkpad;
  GstPad *video_block_pad;
  GstPadSetCapsFunction video_sink_setcaps;
  GstPadEventFunction video_sink_event;
  GstPadChainFunction video_sink_chain;
  gboolean video_sink_blocked;
  GstSegment video_segment;
  gint fps_n, fps_d;

  GstPad *subtitle_sinkpad;
  GstPad *subtitle_block_pad;
  GstPadLinkFunction subtitle_sink_link;
  GstPadUnlinkFunction subtitle_sink_unlink;
  GstPadEventFunction subtitle_sink_event;
  GstPadChainFunction subtitle_sink_chain;
  GstPadSetCapsFunction subtitle_sink_setcaps;
  gboolean subtitle_sink_blocked;
  GstSegment subtitle_segment;
  gboolean subtitle_flush;
  gboolean subtitle_error;

  GMutex *factories_lock;
  GList *factories;
  guint32 factories_cookie;
  GstCaps *factory_caps;

  GMutex *lock;
  GstCaps *subcaps;

  GstElement *passthrough_identity;

  GstElement *pre_colorspace;
  GstElement *post_colorspace;

  GstElement *parser;
  GstElement *overlay;

  GstElement *renderer;

  const gchar *silent_property;
  gboolean silent_property_invert;
};
</STRUCT>
<STRUCT>
<NAME>GstSubtitleOverlayClass</NAME>
struct _GstSubtitleOverlayClass
{
  GstBinClass parent;
};
</STRUCT>
<FUNCTION>
<NAME>gst_subtitle_overlay_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>gst_subtitle_overlay_plugin_init</NAME>
<RETURNS>gboolean </RETURNS>
GstPlugin * plugin 
</FUNCTION>
<FUNCTION>
<NAME>gst_subtitle_overlay_create_factory_caps</NAME>
<RETURNS>GstCaps *</RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_AUDIO_RATE</NAME>
#define GST_TYPE_AUDIO_RATE \
  (gst_audio_rate_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_RATE</NAME>
#define GST_AUDIO_RATE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_RATE,GstAudioRate))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_RATE_CLASS</NAME>
#define GST_AUDIO_RATE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AUDIO_RATE,GstAudioRate))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_RATE</NAME>
#define GST_IS_AUDIO_RATE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_RATE))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_RATE_CLASS</NAME>
#define GST_IS_AUDIO_RATE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AUDIO_RATE))
</MACRO>
<STRUCT>
<NAME>GstAudioRate</NAME>
</STRUCT>
<STRUCT>
<NAME>GstAudioRateClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstAudioRate</NAME>
struct _GstAudioRate
{
  GstElement element;

  GstPad *sinkpad, *srcpad;

  /* audio format */
  gint bytes_per_sample;
  gint rate;

  /* stats */
  guint64 in, out, add, drop;
  gboolean silent;
  guint64 tolerance;
  gboolean skip_to_first;

  /* audio state */
  guint64 next_offset;
  guint64 next_ts;

  gboolean discont;

  gboolean new_segment;
  /* we accept all formats on the sink */
  GstSegment sink_segment;
  /* we output TIME format on the src */
  GstSegment src_segment;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioRateClass</NAME>
struct _GstAudioRateClass
{
  GstElementClass parent_class;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_AUDIO_RESAMPLE</NAME>
#define GST_TYPE_AUDIO_RESAMPLE \
  (gst_audio_resample_get_type())
</MACRO>
<MACRO>
<NAME>GST_AUDIO_RESAMPLE</NAME>
#define GST_AUDIO_RESAMPLE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_AUDIO_RESAMPLE,GstAudioResample))
</MACRO>
<MACRO>
<NAME>GST_AUDIO_RESAMPLE_CLASS</NAME>
#define GST_AUDIO_RESAMPLE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_AUDIO_RESAMPLE,GstAudioResampleClass))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_RESAMPLE</NAME>
#define GST_IS_AUDIO_RESAMPLE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_AUDIO_RESAMPLE))
</MACRO>
<MACRO>
<NAME>GST_IS_AUDIO_RESAMPLE_CLASS</NAME>
#define GST_IS_AUDIO_RESAMPLE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_AUDIO_RESAMPLE))
</MACRO>
<STRUCT>
<NAME>GstAudioResample</NAME>
</STRUCT>
<STRUCT>
<NAME>GstAudioResampleClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstAudioResample</NAME>
struct _GstAudioResample {
  GstBaseTransform element;

  /* <private> */

  GstCaps *srccaps, *sinkcaps;

  gboolean need_discont;

  GstClockTime t0;
  guint64 in_offset0;
  guint64 out_offset0;
  guint64 next_in_offset;
  guint64 next_out_offset;
  
  gint channels;
  gint inrate;
  gint outrate;
  gint quality;
  gint width;
  gboolean fp;

  guint8 *tmp_in;
  guint tmp_in_size;

  guint8 *tmp_out;
  guint tmp_out_size;

  SpeexResamplerState *state;
  const SpeexResampleFuncs *funcs;
};
</STRUCT>
<STRUCT>
<NAME>GstAudioResampleClass</NAME>
struct _GstAudioResampleClass {
  GstBaseTransformClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_audio_resample_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MULTI_FD_SINK</NAME>
#define GST_TYPE_MULTI_FD_SINK \
  (gst_multi_fd_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_MULTI_FD_SINK</NAME>
#define GST_MULTI_FD_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_MULTI_FD_SINK,GstMultiFdSink))
</MACRO>
<MACRO>
<NAME>GST_MULTI_FD_SINK_CLASS</NAME>
#define GST_MULTI_FD_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_MULTI_FD_SINK,GstMultiFdSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_MULTI_FD_SINK</NAME>
#define GST_IS_MULTI_FD_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_MULTI_FD_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_MULTI_FD_SINK_CLASS</NAME>
#define GST_IS_MULTI_FD_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_MULTI_FD_SINK))
</MACRO>
<MACRO>
<NAME>GST_MULTI_FD_SINK_GET_CLASS</NAME>
#define GST_MULTI_FD_SINK_GET_CLASS(klass) \
  (G_TYPE_INSTANCE_GET_CLASS ((klass), GST_TYPE_MULTI_FD_SINK, GstMultiFdSinkClass))
</MACRO>
<STRUCT>
<NAME>GstMultiFdSink</NAME>
</STRUCT>
<STRUCT>
<NAME>GstMultiFdSinkClass</NAME>
</STRUCT>
<ENUM>
<NAME>GstMultiFdSinkFlags</NAME>
typedef enum {
  GST_MULTI_FD_SINK_OPEN             = (GST_ELEMENT_FLAG_LAST << 0),

  GST_MULTI_FD_SINK_FLAG_LAST        = (GST_ELEMENT_FLAG_LAST << 2)
} GstMultiFdSinkFlags;
</ENUM>
<ENUM>
<NAME>GstRecoverPolicy</NAME>
typedef enum
{
  GST_RECOVER_POLICY_NONE,
  GST_RECOVER_POLICY_RESYNC_LATEST,
  GST_RECOVER_POLICY_RESYNC_SOFT_LIMIT,
  GST_RECOVER_POLICY_RESYNC_KEYFRAME
} GstRecoverPolicy;
</ENUM>
<ENUM>
<NAME>GstSyncMethod</NAME>
typedef enum
{
  GST_SYNC_METHOD_LATEST,
  GST_SYNC_METHOD_NEXT_KEYFRAME,
  GST_SYNC_METHOD_LATEST_KEYFRAME,
  GST_SYNC_METHOD_BURST,
  GST_SYNC_METHOD_BURST_KEYFRAME,
  GST_SYNC_METHOD_BURST_WITH_KEYFRAME
} GstSyncMethod;
</ENUM>
<ENUM>
<NAME>GstTCPUnitType</NAME>
typedef enum
{
  GST_TCP_UNIT_TYPE_UNDEFINED,
  GST_TCP_UNIT_TYPE_BUFFERS,
  GST_TCP_UNIT_TYPE_TIME,
  GST_TCP_UNIT_TYPE_BYTES
} GstTCPUnitType;
</ENUM>
<ENUM>
<NAME>GstClientStatus</NAME>
typedef enum
{
  GST_CLIENT_STATUS_OK          = 0,
  GST_CLIENT_STATUS_CLOSED      = 1,
  GST_CLIENT_STATUS_REMOVED     = 2,
  GST_CLIENT_STATUS_SLOW        = 3,
  GST_CLIENT_STATUS_ERROR       = 4,
  GST_CLIENT_STATUS_DUPLICATE   = 5,
  GST_CLIENT_STATUS_FLUSHING    = 6
} GstClientStatus;
</ENUM>
<STRUCT>
<NAME>GstTCPClient</NAME>
typedef struct {
  GstPollFD fd;

  gint bufpos;                  /* position of this client in the global queue */
  gint flushcount;              /* the remaining number of buffers to flush out or -1 if the 
                                   client is not flushing. */

  GstClientStatus status;
  gboolean is_socket;

  GSList *sending;              /* the buffers we need to send */
  gint bufoffset;               /* offset in the first buffer */

  gboolean discont;

  GstTCPProtocol protocol;

  gboolean caps_sent;
  gboolean new_connection;

  gboolean currently_removing;

  /* method to sync client when connecting */
  GstSyncMethod sync_method;
  GstTCPUnitType   burst_min_unit;
  guint64       burst_min_value;
  GstTCPUnitType   burst_max_unit;
  guint64       burst_max_value;

  GstCaps *caps;                /* caps of last queued buffer */

  /* stats */
  guint64 bytes_sent;
  guint64 connect_time;
  guint64 disconnect_time;
  guint64 last_activity_time;
  guint64 dropped_buffers;
  guint64 avg_queue_size;
} GstTCPClient;
</STRUCT>
<MACRO>
<NAME>CLIENTS_LOCK_INIT</NAME>
#define CLIENTS_LOCK_INIT(fdsink)       (g_static_rec_mutex_init(&fdsink->clientslock))
</MACRO>
<MACRO>
<NAME>CLIENTS_LOCK_FREE</NAME>
#define CLIENTS_LOCK_FREE(fdsink)       (g_static_rec_mutex_free(&fdsink->clientslock))
</MACRO>
<MACRO>
<NAME>CLIENTS_LOCK</NAME>
#define CLIENTS_LOCK(fdsink)            (g_static_rec_mutex_lock(&fdsink->clientslock))
</MACRO>
<MACRO>
<NAME>CLIENTS_UNLOCK</NAME>
#define CLIENTS_UNLOCK(fdsink)          (g_static_rec_mutex_unlock(&fdsink->clientslock))
</MACRO>
<STRUCT>
<NAME>GstMultiFdSink</NAME>
struct _GstMultiFdSink {
  GstBaseSink element;

  /*< private >*/
  guint64 bytes_to_serve; /* how much bytes we must serve */
  guint64 bytes_served; /* how much bytes have we served */

  GStaticRecMutex clientslock;  /* lock to protect the clients list */
  GList *clients;       /* list of clients we are serving */
  GHashTable *fd_hash;  /* index on fd to client */
  guint clients_cookie; /* Cookie to detect changes to the clients list */

  gint mode;
  GstPoll *fdset;

  GSList *streamheader; /* GSList of GstBuffers to use as streamheader */
  gboolean previous_buffer_in_caps;

  GstTCPProtocol protocol;
  guint mtu;
  gint qos_dscp;
  gboolean handle_read;

  GArray *bufqueue;     /* global queue of buffers */

  gboolean running;     /* the thread state */
  GThread *thread;      /* the sender thread */

  /* these values are used to check if a client is reading fast
   * enough and to control receovery */
  GstTCPUnitType unit_type;/* the type of the units */
  gint64 units_max;       /* max units to queue for a client */
  gint64 units_soft_max;  /* max units a client can lag before recovery starts */
  GstRecoverPolicy recover_policy;
  GstClockTime timeout; /* max amount of nanoseconds to remain idle */

  GstSyncMethod def_sync_method;    /* what method to use for connecting clients */
  GstTCPUnitType   def_burst_unit;
  guint64       def_burst_value;

  /* these values are used to control the amount of data
   * kept in the queues. It allows clients to perform a burst
   * on connect. */
  gint   bytes_min;	/* min number of bytes to queue */
  gint64 time_min;	/* min time to queue */
  gint   buffers_min;   /* min number of buffers to queue */

  gboolean resend_streamheader; /* resend streamheader if it changes */

  /* stats */
  gint buffers_queued;  /* number of queued buffers */
  gint bytes_queued;    /* number of queued bytes */
  gint time_queued;     /* number of queued time */

  guint8 header_flags;
};
</STRUCT>
<STRUCT>
<NAME>GstMultiFdSinkClass</NAME>
struct _GstMultiFdSinkClass {
  GstBaseSinkClass parent_class;

  /* element methods */
  void          (*add)          (GstMultiFdSink *sink, int fd);
  void          (*add_full)     (GstMultiFdSink *sink, int fd, GstSyncMethod sync,
		                 GstTCPUnitType format, guint64 value, 
				 GstTCPUnitType max_unit, guint64 max_value);
  void          (*remove)       (GstMultiFdSink *sink, int fd);
  void          (*remove_flush) (GstMultiFdSink *sink, int fd);
  void          (*clear)        (GstMultiFdSink *sink);
  GValueArray*  (*get_stats)    (GstMultiFdSink *sink, int fd);

  /* vtable */
  gboolean (*init)   (GstMultiFdSink *sink);
  gboolean (*wait)   (GstMultiFdSink *sink, GstPoll *set);
  gboolean (*close)  (GstMultiFdSink *sink);
  void (*removed) (GstMultiFdSink *sink, int fd);

  /* signals */
  void (*client_added) (GstElement *element, gint fd);
  void (*client_removed) (GstElement *element, gint fd, GstClientStatus status);
  void (*client_fd_removed) (GstElement *element, gint fd);
};
</STRUCT>
<FUNCTION>
<NAME>gst_multi_fd_sink_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>gst_multi_fd_sink_add</NAME>
<RETURNS>void          </RETURNS>
GstMultiFdSink *sink, int fd 
</FUNCTION>
<FUNCTION>
<NAME>gst_multi_fd_sink_add_full</NAME>
<RETURNS>void          </RETURNS>
GstMultiFdSink *sink, int fd, GstSyncMethod sync, GstTCPUnitType min_unit, guint64 min_value, GstTCPUnitType max_unit, guint64 max_value 
</FUNCTION>
<FUNCTION>
<NAME>gst_multi_fd_sink_remove</NAME>
<RETURNS>void          </RETURNS>
GstMultiFdSink *sink, int fd 
</FUNCTION>
<FUNCTION>
<NAME>gst_multi_fd_sink_remove_flush</NAME>
<RETURNS>void          </RETURNS>
GstMultiFdSink *sink, int fd 
</FUNCTION>
<FUNCTION>
<NAME>gst_multi_fd_sink_clear</NAME>
<RETURNS>void          </RETURNS>
GstMultiFdSink *sink 
</FUNCTION>
<FUNCTION>
<NAME>gst_multi_fd_sink_get_stats</NAME>
<RETURNS>GValueArray*</RETURNS>
GstMultiFdSink *sink, int fd 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TCP_CLIENT_SRC</NAME>
#define GST_TYPE_TCP_CLIENT_SRC \
  (gst_tcp_client_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_TCP_CLIENT_SRC</NAME>
#define GST_TCP_CLIENT_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_TCP_CLIENT_SRC,GstTCPClientSrc))
</MACRO>
<MACRO>
<NAME>GST_TCP_CLIENT_SRC_CLASS</NAME>
#define GST_TCP_CLIENT_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_TCP_CLIENT_SRC,GstTCPClientSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_TCP_CLIENT_SRC</NAME>
#define GST_IS_TCP_CLIENT_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_TCP_CLIENT_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_TCP_CLIENT_SRC_CLASS</NAME>
#define GST_IS_TCP_CLIENT_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_TCP_CLIENT_SRC))
</MACRO>
<STRUCT>
<NAME>GstTCPClientSrc</NAME>
</STRUCT>
<STRUCT>
<NAME>GstTCPClientSrcClass</NAME>
</STRUCT>
<ENUM>
<NAME>GstTCPClientSrcFlags</NAME>
typedef enum {
  GST_TCP_CLIENT_SRC_OPEN       = (GST_ELEMENT_FLAG_LAST << 0),

  GST_TCP_CLIENT_SRC_FLAG_LAST  = (GST_ELEMENT_FLAG_LAST << 2)
} GstTCPClientSrcFlags;
</ENUM>
<STRUCT>
<NAME>GstTCPClientSrc</NAME>
struct _GstTCPClientSrc {
  GstPushSrc element;

  /* server information */
  int port;
  gchar *host;
  struct sockaddr_in server_sin;

  /* socket */
  GstPollFD sock_fd;
  GstPoll *fdset;

  GstTCPProtocol protocol; /* protocol used for reading data */
  gboolean caps_received;      /* if we have received caps yet */
  GstCaps *caps;
};
</STRUCT>
<STRUCT>
<NAME>GstTCPClientSrcClass</NAME>
struct _GstTCPClientSrcClass {
  GstPushSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_tcp_client_src_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TCP_CLIENT_SINK</NAME>
#define GST_TYPE_TCP_CLIENT_SINK \
  (gst_tcp_client_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_TCP_CLIENT_SINK</NAME>
#define GST_TCP_CLIENT_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_TCP_CLIENT_SINK,GstTCPClientSink))
</MACRO>
<MACRO>
<NAME>GST_TCP_CLIENT_SINK_CLASS</NAME>
#define GST_TCP_CLIENT_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_TCP_CLIENT_SINK,GstTCPClientSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_TCP_CLIENT_SINK</NAME>
#define GST_IS_TCP_CLIENT_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_TCP_CLIENT_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_TCP_CLIENT_SINK_CLASS</NAME>
#define GST_IS_TCP_CLIENT_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_TCP_CLIENT_SINK))
</MACRO>
<STRUCT>
<NAME>GstTCPClientSink</NAME>
</STRUCT>
<STRUCT>
<NAME>GstTCPClientSinkClass</NAME>
</STRUCT>
<ENUM>
<NAME>GstTCPClientSinkFlags</NAME>
typedef enum {
  GST_TCP_CLIENT_SINK_OPEN             = (GST_ELEMENT_FLAG_LAST << 0),

  GST_TCP_CLIENT_SINK_FLAG_LAST        = (GST_ELEMENT_FLAG_LAST << 2),
} GstTCPClientSinkFlags;
</ENUM>
<STRUCT>
<NAME>GstTCPClientSink</NAME>
struct _GstTCPClientSink {
  GstBaseSink element;

  /* server information */
  int port;
  gchar *host;
  struct sockaddr_in server_sin;

  /* socket */
  GstPollFD sock_fd;

  size_t data_written; /* how much bytes have we written ? */
  GstTCPProtocol protocol; /* used with the protocol enum */
  gboolean caps_sent; /* whether or not we sent caps already */
};
</STRUCT>
<STRUCT>
<NAME>GstTCPClientSinkClass</NAME>
struct _GstTCPClientSinkClass {
  GstBaseSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_tcp_client_sink_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TCP_SERVER_SRC</NAME>
#define GST_TYPE_TCP_SERVER_SRC \
  (gst_tcp_server_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_TCP_SERVER_SRC</NAME>
#define GST_TCP_SERVER_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_TCP_SERVER_SRC,GstTCPServerSrc))
</MACRO>
<MACRO>
<NAME>GST_TCP_SERVER_SRC_CLASS</NAME>
#define GST_TCP_SERVER_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_TCP_SERVER_SRC,GstTCPServerSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_TCP_SERVER_SRC</NAME>
#define GST_IS_TCP_SERVER_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_TCP_SERVER_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_TCP_SERVER_SRC_CLASS</NAME>
#define GST_IS_TCP_SERVER_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_TCP_SERVER_SRC))
</MACRO>
<STRUCT>
<NAME>GstTCPServerSrc</NAME>
</STRUCT>
<STRUCT>
<NAME>GstTCPServerSrcClass</NAME>
</STRUCT>
<ENUM>
<NAME>GstTCPServerSrcFlags</NAME>
typedef enum {
  GST_TCP_SERVER_SRC_OPEN       = (GST_ELEMENT_FLAG_LAST << 0),

  GST_TCP_SERVER_SRC_FLAG_LAST  = (GST_ELEMENT_FLAG_LAST << 2)
} GstTCPServerSrcFlags;
</ENUM>
<STRUCT>
<NAME>GstTCPServerSrc</NAME>
struct _GstTCPServerSrc {
  GstPushSrc element;

  /* server information */
  int server_port;
  gchar *host;
  struct sockaddr_in server_sin;
  GstPollFD server_sock_fd;

  /* client information */
  struct sockaddr_in client_sin;
  socklen_t client_sin_len;
  GstPollFD client_sock_fd;

  GstPoll *fdset;

  GstTCPProtocol protocol; /* protocol used for reading data */
  gboolean caps_received;      /* if we have received caps yet */
};
</STRUCT>
<STRUCT>
<NAME>GstTCPServerSrcClass</NAME>
struct _GstTCPServerSrcClass {
  GstPushSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_tcp_server_src_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TCP_SERVER_SINK</NAME>
#define GST_TYPE_TCP_SERVER_SINK \
  (gst_tcp_server_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_TCP_SERVER_SINK</NAME>
#define GST_TCP_SERVER_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_TCP_SERVER_SINK,GstTCPServerSink))
</MACRO>
<MACRO>
<NAME>GST_TCP_SERVER_SINK_CLASS</NAME>
#define GST_TCP_SERVER_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_TCP_SERVER_SINK,GstTCPServerSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_TCP_SERVER_SINK</NAME>
#define GST_IS_TCP_SERVER_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_TCP_SERVER_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_TCP_SERVER_SINK_CLASS</NAME>
#define GST_IS_TCP_SERVER_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_TCP_SERVER_SINK))
</MACRO>
<STRUCT>
<NAME>GstTCPServerSink</NAME>
</STRUCT>
<STRUCT>
<NAME>GstTCPServerSinkClass</NAME>
</STRUCT>
<ENUM>
<NAME>GstTCPServerSinkFlags</NAME>
typedef enum {
  GST_TCP_SERVER_SINK_OPEN             = (GST_ELEMENT_FLAG_LAST << 0),

  GST_TCP_SERVER_SINK_FLAG_LAST        = (GST_ELEMENT_FLAG_LAST << 2)
} GstTCPServerSinkFlags;
</ENUM>
<STRUCT>
<NAME>GstTCPServerSink</NAME>
struct _GstTCPServerSink {
  GstMultiFdSink element;

  /* server information */
  int server_port;
  gchar *host;
  struct sockaddr_in server_sin;

  /* socket */
  GstPollFD server_sock;
};
</STRUCT>
<STRUCT>
<NAME>GstTCPServerSinkClass</NAME>
struct _GstTCPServerSinkClass {
  GstMultiFdSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_tcp_server_sink_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>gst_tcp_protocol_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TCP_PROTOCOL</NAME>
#define GST_TYPE_TCP_PROTOCOL (gst_tcp_protocol_get_type())
</MACRO>
<MACRO>
<NAME>TCP_HIGHEST_PORT</NAME>
#define TCP_HIGHEST_PORT        65535
</MACRO>
<MACRO>
<NAME>TCP_DEFAULT_HOST</NAME>
#define TCP_DEFAULT_HOST        "localhost"
</MACRO>
<MACRO>
<NAME>TCP_DEFAULT_PORT</NAME>
#define TCP_DEFAULT_PORT        4953
</MACRO>
<ENUM>
<NAME>GstTCPProtocol</NAME>
typedef enum
{
  GST_TCP_PROTOCOL_NONE,
  GST_TCP_PROTOCOL_GDP
} GstTCPProtocol;
</ENUM>
<FUNCTION>
<NAME>gst_tcp_host_to_ip</NAME>
<RETURNS>gchar *</RETURNS>
GstElement *element, const gchar *host 
</FUNCTION>
<FUNCTION>
<NAME>gst_tcp_socket_write</NAME>
<RETURNS>gint </RETURNS>
int socket, const void *buf, size_t count 
</FUNCTION>
<FUNCTION>
<NAME>gst_tcp_socket_close</NAME>
<RETURNS>void </RETURNS>
GstPollFD *socket 
</FUNCTION>
<FUNCTION>
<NAME>gst_tcp_read_buffer</NAME>
<RETURNS>GstFlowReturn </RETURNS>
GstElement * this, int socket, GstPoll * fdset, GstBuffer **buf 
</FUNCTION>
<FUNCTION>
<NAME>gst_tcp_gdp_read_buffer</NAME>
<RETURNS>GstFlowReturn </RETURNS>
GstElement * this, int socket, GstPoll * fdset, GstBuffer **buf 
</FUNCTION>
<FUNCTION>
<NAME>gst_tcp_gdp_read_caps</NAME>
<RETURNS>GstFlowReturn </RETURNS>
GstElement * this, int socket, GstPoll * fdset, GstCaps **caps 
</FUNCTION>
<FUNCTION>
<NAME>gst_tcp_gdp_read_event</NAME>
<RETURNS>GstEvent *</RETURNS>
GstElement *elem, int socket, GstPoll * fdset 
</FUNCTION>
<FUNCTION>
<NAME>gst_tcp_gdp_write_buffer</NAME>
<RETURNS>gboolean </RETURNS>
GstElement *elem, int socket, GstBuffer *buffer, gboolean fatal, const gchar *host, int port 
</FUNCTION>
<FUNCTION>
<NAME>gst_tcp_gdp_write_event</NAME>
<RETURNS>gboolean </RETURNS>
GstElement *elem, int socket, GstEvent *event, gboolean fatal, const gchar *host, int port 
</FUNCTION>
<FUNCTION>
<NAME>gst_tcp_gdp_write_caps</NAME>
<RETURNS>gboolean </RETURNS>
GstElement *elem, int socket, const GstCaps *caps, gboolean fatal, const gchar *host, int port 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VIDEO_RATE</NAME>
#define GST_TYPE_VIDEO_RATE \
  (gst_video_rate_get_type())
</MACRO>
<MACRO>
<NAME>GST_VIDEO_RATE</NAME>
#define GST_VIDEO_RATE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VIDEO_RATE,GstVideoRate))
</MACRO>
<MACRO>
<NAME>GST_VIDEO_RATE_CLASS</NAME>
#define GST_VIDEO_RATE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VIDEO_RATE,GstVideoRateClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_RATE</NAME>
#define GST_IS_VIDEO_RATE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VIDEO_RATE))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_RATE_CLASS</NAME>
#define GST_IS_VIDEO_RATE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VIDEO_RATE))
</MACRO>
<STRUCT>
<NAME>GstVideoRate</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVideoRateClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVideoRate</NAME>
struct _GstVideoRate
{
  GstElement element;

  GstPad *sinkpad, *srcpad;

  /* video state */
  gint from_rate_numerator, from_rate_denominator;
  gint to_rate_numerator, to_rate_denominator;
  guint64 next_ts;              /* Timestamp of next buffer to output */
  GstBuffer *prevbuf;
  guint64 prev_ts;              /* Previous buffer timestamp */
  guint64 segment_out;          /* in-segment counting */
  gboolean discont;
  guint64 last_ts;              /* Timestamp of last input buffer */

  /* segment handling */
  GstSegment segment;

  /* properties */
  guint64 in, out, dup, drop;
  gboolean silent;
  gdouble new_pref;
  gboolean skip_to_first;
};
</STRUCT>
<STRUCT>
<NAME>GstVideoRateClass</NAME>
struct _GstVideoRateClass
{
  GstElementClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_video_rate_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_CAT_DEFAULT</NAME>
#define GST_CAT_DEFAULT video_scale_debug
</MACRO>
<MACRO>
<NAME>GST_TYPE_VIDEO_SCALE</NAME>
#define GST_TYPE_VIDEO_SCALE \
  (gst_video_scale_get_type())
</MACRO>
<MACRO>
<NAME>GST_VIDEO_SCALE</NAME>
#define GST_VIDEO_SCALE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VIDEO_SCALE,GstVideoScale))
</MACRO>
<MACRO>
<NAME>GST_VIDEO_SCALE_CLASS</NAME>
#define GST_VIDEO_SCALE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VIDEO_SCALE,GstVideoScaleClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_SCALE</NAME>
#define GST_IS_VIDEO_SCALE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VIDEO_SCALE))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_SCALE_CLASS</NAME>
#define GST_IS_VIDEO_SCALE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VIDEO_SCALE))
</MACRO>
<ENUM>
<NAME>GstVideoScaleMethod</NAME>
typedef enum {
  GST_VIDEO_SCALE_NEAREST,
  GST_VIDEO_SCALE_BILINEAR,
  GST_VIDEO_SCALE_4TAP
} GstVideoScaleMethod;
</ENUM>
<STRUCT>
<NAME>GstVideoScale</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVideoScaleClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVideoScale</NAME>
struct _GstVideoScale {
  GstVideoFilter element;

  GstVideoScaleMethod method;
  gboolean add_borders;

  /* negotiated stuff */
  GstVideoFormat format;
  gint to_width;
  gint to_height;
  gint from_width;
  gint from_height;
  guint src_size;
  guint dest_size;

  gint borders_h;
  gint borders_w;

  /*< private >*/
  guint8 *tmp_buf;
};
</STRUCT>
<STRUCT>
<NAME>GstVideoScaleClass</NAME>
struct _GstVideoScaleClass {
  GstVideoFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_video_scale_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VIDEO_TEST_SRC</NAME>
#define GST_TYPE_VIDEO_TEST_SRC \
  (gst_video_test_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_VIDEO_TEST_SRC</NAME>
#define GST_VIDEO_TEST_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VIDEO_TEST_SRC,GstVideoTestSrc))
</MACRO>
<MACRO>
<NAME>GST_VIDEO_TEST_SRC_CLASS</NAME>
#define GST_VIDEO_TEST_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VIDEO_TEST_SRC,GstVideoTestSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_TEST_SRC</NAME>
#define GST_IS_VIDEO_TEST_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VIDEO_TEST_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_VIDEO_TEST_SRC_CLASS</NAME>
#define GST_IS_VIDEO_TEST_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VIDEO_TEST_SRC))
</MACRO>
<ENUM>
<NAME>GstVideoTestSrcPattern</NAME>
typedef enum {
  GST_VIDEO_TEST_SRC_SMPTE,
  GST_VIDEO_TEST_SRC_SNOW,
  GST_VIDEO_TEST_SRC_BLACK,
  GST_VIDEO_TEST_SRC_WHITE,
  GST_VIDEO_TEST_SRC_RED,
  GST_VIDEO_TEST_SRC_GREEN,
  GST_VIDEO_TEST_SRC_BLUE,
  GST_VIDEO_TEST_SRC_CHECKERS1,
  GST_VIDEO_TEST_SRC_CHECKERS2,
  GST_VIDEO_TEST_SRC_CHECKERS4,
  GST_VIDEO_TEST_SRC_CHECKERS8,
  GST_VIDEO_TEST_SRC_CIRCULAR,
  GST_VIDEO_TEST_SRC_BLINK,
  GST_VIDEO_TEST_SRC_SMPTE75,
  GST_VIDEO_TEST_SRC_ZONE_PLATE,
  GST_VIDEO_TEST_SRC_GAMUT,
  GST_VIDEO_TEST_SRC_CHROMA_ZONE_PLATE
} GstVideoTestSrcPattern;
</ENUM>
<ENUM>
<NAME>GstVideoTestSrcColorSpec</NAME>
typedef enum {
  GST_VIDEO_TEST_SRC_BT601,
  GST_VIDEO_TEST_SRC_BT709
} GstVideoTestSrcColorSpec;
</ENUM>
<STRUCT>
<NAME>GstVideoTestSrc</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVideoTestSrcClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVideoTestSrc</NAME>
struct _GstVideoTestSrc {
  GstPushSrc element;

  /*< private >*/

  /* type of output */
  GstVideoTestSrcPattern pattern_type;

  /* Color spec of output */
  GstVideoTestSrcColorSpec color_spec;

  /* video state */
  char *format_name;
  gint width;
  gint height;
  struct fourcc_list_struct *fourcc;
  gint bpp;
  gint rate_numerator;
  gint rate_denominator;

  /* private */
  gint64 timestamp_offset;              /* base offset */
  GstClockTime running_time;            /* total running time */
  gint64 n_frames;                      /* total frames sent */
  gboolean peer_alloc;

  /* zoneplate */
  gint k0;
  gint kx;
  gint ky;
  gint kt;
  gint kxt;
  gint kyt;
  gint kxy;
  gint kx2;
  gint ky2;
  gint kt2;
  gint xoffset;
  gint yoffset;
  
  void (*make_image) (GstVideoTestSrc *v, unsigned char *dest, int w, int h);
};
</STRUCT>
<STRUCT>
<NAME>GstVideoTestSrcClass</NAME>
struct _GstVideoTestSrcClass {
  GstPushSrcClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_video_test_src_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_VOLUME</NAME>
#define GST_TYPE_VOLUME \
  (gst_volume_get_type())
</MACRO>
<MACRO>
<NAME>GST_VOLUME</NAME>
#define GST_VOLUME(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_VOLUME,GstVolume))
</MACRO>
<MACRO>
<NAME>GST_VOLUME_CLASS</NAME>
#define GST_VOLUME_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_VOLUME,GstVolumeClass))
</MACRO>
<MACRO>
<NAME>GST_IS_VOLUME</NAME>
#define GST_IS_VOLUME(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_VOLUME))
</MACRO>
<MACRO>
<NAME>GST_IS_VOLUME_CLASS</NAME>
#define GST_IS_VOLUME_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_VOLUME))
</MACRO>
<STRUCT>
<NAME>GstVolume</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVolumeClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstVolume</NAME>
struct _GstVolume {
  GstAudioFilter element;

  void (*process)(GstVolume*, gpointer, guint);
  void (*process_controlled)(GstVolume*, gpointer, gdouble *, guint, guint);

  gboolean mute;
  gfloat volume;

  gboolean current_mute;
  gfloat current_volume;

  gint   current_vol_i32;
  gint   current_vol_i24; /* the _i(nt) values get synchronized with the */
  gint   current_vol_i16; /* the _i(nt) values get synchronized with the */
  gint   current_vol_i8;   /* the _i(nt) values get synchronized with the */
  
  GList *tracklist;
  gboolean negotiated;

  gboolean *mutes;
  guint mutes_count;
  gdouble *volumes;
  guint volumes_count;
};
</STRUCT>
<STRUCT>
<NAME>GstVolumeClass</NAME>
struct _GstVolumeClass {
  GstAudioFilterClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_volume_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_XIMAGESINK</NAME>
#define GST_TYPE_XIMAGESINK \
  (gst_ximagesink_get_type())
</MACRO>
<MACRO>
<NAME>GST_XIMAGESINK</NAME>
#define GST_XIMAGESINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_XIMAGESINK, GstXImageSink))
</MACRO>
<MACRO>
<NAME>GST_XIMAGESINK_CLASS</NAME>
#define GST_XIMAGESINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_XIMAGESINK, GstXImageSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_XIMAGESINK</NAME>
#define GST_IS_XIMAGESINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_XIMAGESINK))
</MACRO>
<MACRO>
<NAME>GST_IS_XIMAGESINK_CLASS</NAME>
#define GST_IS_XIMAGESINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_XIMAGESINK))
</MACRO>
<STRUCT>
<NAME>GstXContext</NAME>
</STRUCT>
<STRUCT>
<NAME>GstXWindow</NAME>
</STRUCT>
<STRUCT>
<NAME>GstXImageBuffer</NAME>
</STRUCT>
<STRUCT>
<NAME>GstXImageBufferClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstXImageSink</NAME>
</STRUCT>
<STRUCT>
<NAME>GstXImageSinkClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstXContext</NAME>
struct _GstXContext
{
  Display *disp;

  Screen *screen;
  gint screen_num;

  Visual *visual;

  Window root;

  gulong white, black;

  gint depth;
  gint bpp;
  gint endianness;

  gint width, height;
  gint widthmm, heightmm;
  GValue *par;                  /* calculated pixel aspect ratio */

  gboolean use_xshm;

  GstCaps *caps;
  GstCaps *last_caps;
};
</STRUCT>
<STRUCT>
<NAME>GstXWindow</NAME>
struct _GstXWindow
{
  Window win;
  gint width, height;
  gboolean internal;
  GC gc;
};
</STRUCT>
<STRUCT>
<NAME>GstXImageBuffer</NAME>
struct _GstXImageBuffer
{
  GstBuffer buffer;

  /* Reference to the ximagesink we belong to */
  GstXImageSink *ximagesink;

  XImage *ximage;

#ifdef HAVE_XSHM
  XShmSegmentInfo SHMInfo;
#endif                          /* HAVE_XSHM */

  gint width, height;
  size_t size;
};
</STRUCT>
<STRUCT>
<NAME>GstXImageSink</NAME>
struct _GstXImageSink
{
  /* Our element stuff */
  GstVideoSink videosink;

  char *display_name;

  GstXContext *xcontext;
  GstXWindow *xwindow;
  GstXImageBuffer *ximage;
  GstXImageBuffer *cur_image;

  GThread *event_thread;
  gboolean running;

  /* Framerate numerator and denominator */
  gint fps_n;
  gint fps_d;

  GMutex *x_lock;
  GMutex *flow_lock;

  /* object-set pixel aspect ratio */
  GValue *par;

  GMutex *pool_lock;
  GSList *buffer_pool;

  gboolean synchronous;
  gboolean keep_aspect;
  gboolean handle_events;
  gboolean handle_expose;
  gboolean draw_border;

  /* stream metadata */
  gchar *media_title;
};
</STRUCT>
<STRUCT>
<NAME>GstXImageSinkClass</NAME>
struct _GstXImageSinkClass
{
  GstVideoSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_ximagesink_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_XVIMAGESINK</NAME>
#define GST_TYPE_XVIMAGESINK \
  (gst_xvimagesink_get_type())
</MACRO>
<MACRO>
<NAME>GST_XVIMAGESINK</NAME>
#define GST_XVIMAGESINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj), GST_TYPE_XVIMAGESINK, GstXvImageSink))
</MACRO>
<MACRO>
<NAME>GST_XVIMAGESINK_CLASS</NAME>
#define GST_XVIMAGESINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass), GST_TYPE_XVIMAGESINK, GstXvImageSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_XVIMAGESINK</NAME>
#define GST_IS_XVIMAGESINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj), GST_TYPE_XVIMAGESINK))
</MACRO>
<MACRO>
<NAME>GST_IS_XVIMAGESINK_CLASS</NAME>
#define GST_IS_XVIMAGESINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass), GST_TYPE_XVIMAGESINK))
</MACRO>
<STRUCT>
<NAME>GstXContext</NAME>
</STRUCT>
<STRUCT>
<NAME>GstXWindow</NAME>
</STRUCT>
<STRUCT>
<NAME>GstXvImageFormat</NAME>
</STRUCT>
<STRUCT>
<NAME>GstXvImageBuffer</NAME>
</STRUCT>
<STRUCT>
<NAME>GstXvImageBufferClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstXvImageSink</NAME>
</STRUCT>
<STRUCT>
<NAME>GstXvImageSinkClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstXContext</NAME>
struct _GstXContext {
  Display *disp;

  Screen *screen;
  gint screen_num;

  Visual *visual;

  Window root;

  gulong white, black;

  gint depth;
  gint bpp;
  gint endianness;

  gint width, height;
  gint widthmm, heightmm;
  GValue *par;                  /* calculated pixel aspect ratio */

  gboolean use_xshm;

  XvPortID xv_port_id;
  guint nb_adaptors;
  gchar ** adaptors;
  gint im_format;

  GList *formats_list;
  GList *channels_list;

  GstCaps *caps;

  /* Optimisation storage for buffer_alloc return */
  GstCaps *last_caps;
  gint last_format;
  gint last_width;
  gint last_height;
};
</STRUCT>
<STRUCT>
<NAME>GstXWindow</NAME>
struct _GstXWindow {
  Window win;
  gint width, height;
  gboolean internal;
  GC gc;
};
</STRUCT>
<STRUCT>
<NAME>GstXvImageFormat</NAME>
struct _GstXvImageFormat {
  gint format;
  GstCaps *caps;
};
</STRUCT>
<STRUCT>
<NAME>GstXvImageBuffer</NAME>
struct _GstXvImageBuffer {
  GstBuffer   buffer;

  /* Reference to the xvimagesink we belong to */
  GstXvImageSink *xvimagesink;

  XvImage *xvimage;

#ifdef HAVE_XSHM
  XShmSegmentInfo SHMInfo;
#endif /* HAVE_XSHM */

  gint width, height, im_format;
  size_t size;
};
</STRUCT>
<STRUCT>
<NAME>GstXvImageSink</NAME>
struct _GstXvImageSink {
  /* Our element stuff */
  GstVideoSink videosink;

  char *display_name;
  guint adaptor_no;

  GstXContext *xcontext;
  GstXWindow *xwindow;
  GstXvImageBuffer *xvimage;
  GstXvImageBuffer *cur_image;

  GThread *event_thread;
  gboolean running;

  gint fps_n;
  gint fps_d;

  GMutex *x_lock;
  GMutex *flow_lock;

  /* object-set pixel aspect ratio */
  GValue *par;

  GMutex *pool_lock;
  gboolean pool_invalid;
  GSList *image_pool;

  gboolean synchronous;
  gboolean double_buffer;
  gboolean keep_aspect;
  gboolean redraw_border;
  gboolean handle_events;
  gboolean handle_expose;

  gint brightness;
  gint contrast;
  gint hue;
  gint saturation;
  gboolean cb_changed;

  /* size of incoming video, used as the size for XvImage */
  guint video_width, video_height;

  /* display sizes, used for clipping the image */
  gint disp_x, disp_y;
  gint disp_width, disp_height;

  /* port attributes */
  gboolean autopaint_colorkey;
  gint colorkey;
  
  gboolean draw_borders;
  
  /* port features */
  gboolean have_autopaint_colorkey;
  gboolean have_colorkey;
  gboolean have_double_buffer;
  
  /* stream metadata */
  gchar *media_title;

  /* target video rectagle */
  GstVideoRectangle render_rect;
  gboolean have_render_rect;
};
</STRUCT>
<STRUCT>
<NAME>GstXvImageSinkClass</NAME>
struct _GstXvImageSinkClass {
  GstVideoSinkClass parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_xvimagesink_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_APP_SRC</NAME>
#define GST_TYPE_APP_SRC \
  (gst_app_src_get_type())
</MACRO>
<MACRO>
<NAME>GST_APP_SRC</NAME>
#define GST_APP_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_APP_SRC,GstAppSrc))
</MACRO>
<MACRO>
<NAME>GST_APP_SRC_CLASS</NAME>
#define GST_APP_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_APP_SRC,GstAppSrcClass))
</MACRO>
<MACRO>
<NAME>GST_IS_APP_SRC</NAME>
#define GST_IS_APP_SRC(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_APP_SRC))
</MACRO>
<MACRO>
<NAME>GST_IS_APP_SRC_CLASS</NAME>
#define GST_IS_APP_SRC_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_APP_SRC))
</MACRO>
<MACRO>
<NAME>GST_APP_SRC_CAST</NAME>
#define GST_APP_SRC_CAST(obj) \
  ((GstAppSrc*)(obj))
</MACRO>
<STRUCT>
<NAME>GstAppSrc</NAME>
</STRUCT>
<STRUCT>
<NAME>GstAppSrcClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstAppSrcPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GstAppSrcCallbacks</NAME>
typedef struct {
  void      (*need_data)    (GstAppSrc *src, guint length, gpointer user_data);
  void      (*enough_data)  (GstAppSrc *src, gpointer user_data);
  gboolean  (*seek_data)    (GstAppSrc *src, guint64 offset, gpointer user_data);

  /*< private >*/
  gpointer     _gst_reserved[GST_PADDING];
} GstAppSrcCallbacks;
</STRUCT>
<ENUM>
<NAME>GstAppStreamType</NAME>
typedef enum
{
  GST_APP_STREAM_TYPE_STREAM,
  GST_APP_STREAM_TYPE_SEEKABLE,
  GST_APP_STREAM_TYPE_RANDOM_ACCESS
} GstAppStreamType;
</ENUM>
<STRUCT>
<NAME>GstAppSrc</NAME>
struct _GstAppSrc
{
  GstBaseSrc basesrc;

  /*< private >*/
  GstAppSrcPrivate *priv;

  /*< private >*/
  gpointer     _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstAppSrcClass</NAME>
struct _GstAppSrcClass
{
  GstBaseSrcClass basesrc_class;

  /* signals */
  void          (*need_data)       (GstAppSrc *src, guint length);
  void          (*enough_data)     (GstAppSrc *src);
  gboolean      (*seek_data)       (GstAppSrc *src, guint64 offset);

  /* actions */
  GstFlowReturn (*push_buffer)     (GstAppSrc *src, GstBuffer *buffer);
  GstFlowReturn (*end_of_stream)   (GstAppSrc *src);

  /*< private >*/
  gpointer     _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_app_src_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_src_set_caps</NAME>
<RETURNS>void             </RETURNS>
GstAppSrc *appsrc, const GstCaps *caps 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_src_get_caps</NAME>
<RETURNS>GstCaps*</RETURNS>
GstAppSrc *appsrc 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_src_set_size</NAME>
<RETURNS>void             </RETURNS>
GstAppSrc *appsrc, gint64 size 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_src_get_size</NAME>
<RETURNS>gint64           </RETURNS>
GstAppSrc *appsrc 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_src_set_stream_type</NAME>
<RETURNS>void             </RETURNS>
GstAppSrc *appsrc, GstAppStreamType type 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_src_get_stream_type</NAME>
<RETURNS>GstAppStreamType </RETURNS>
GstAppSrc *appsrc 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_src_set_max_bytes</NAME>
<RETURNS>void             </RETURNS>
GstAppSrc *appsrc, guint64 max 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_src_get_max_bytes</NAME>
<RETURNS>guint64          </RETURNS>
GstAppSrc *appsrc 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_src_set_latency</NAME>
<RETURNS>void             </RETURNS>
GstAppSrc *appsrc, guint64 min, guint64 max 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_src_get_latency</NAME>
<RETURNS>void             </RETURNS>
GstAppSrc *appsrc, guint64 *min, guint64 *max 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_src_set_emit_signals</NAME>
<RETURNS>void             </RETURNS>
GstAppSrc *appsrc, gboolean emit 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_src_get_emit_signals</NAME>
<RETURNS>gboolean         </RETURNS>
GstAppSrc *appsrc 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_src_push_buffer</NAME>
<RETURNS>GstFlowReturn    </RETURNS>
GstAppSrc *appsrc, GstBuffer *buffer 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_src_end_of_stream</NAME>
<RETURNS>GstFlowReturn    </RETURNS>
GstAppSrc *appsrc 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_src_set_callbacks</NAME>
<RETURNS>void             </RETURNS>
GstAppSrc * appsrc, GstAppSrcCallbacks *callbacks, gpointer user_data, GDestroyNotify notify 
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_APP_SINK</NAME>
#define GST_TYPE_APP_SINK \
  (gst_app_sink_get_type())
</MACRO>
<MACRO>
<NAME>GST_APP_SINK</NAME>
#define GST_APP_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_APP_SINK,GstAppSink))
</MACRO>
<MACRO>
<NAME>GST_APP_SINK_CLASS</NAME>
#define GST_APP_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_APP_SINK,GstAppSinkClass))
</MACRO>
<MACRO>
<NAME>GST_IS_APP_SINK</NAME>
#define GST_IS_APP_SINK(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_APP_SINK))
</MACRO>
<MACRO>
<NAME>GST_IS_APP_SINK_CLASS</NAME>
#define GST_IS_APP_SINK_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_APP_SINK))
</MACRO>
<MACRO>
<NAME>GST_APP_SINK_CAST</NAME>
#define GST_APP_SINK_CAST(obj) \
  ((GstAppSink*)(obj))
</MACRO>
<STRUCT>
<NAME>GstAppSink</NAME>
</STRUCT>
<STRUCT>
<NAME>GstAppSinkClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstAppSinkPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GstAppSinkCallbacks</NAME>
typedef struct {
  void          (*eos)              (GstAppSink *sink, gpointer user_data);
  GstFlowReturn (*new_preroll)      (GstAppSink *sink, gpointer user_data);
  GstFlowReturn (*new_buffer)       (GstAppSink *sink, gpointer user_data);
  GstFlowReturn (*new_buffer_list)  (GstAppSink *sink, gpointer user_data);

  /*< private >*/
  gpointer     _gst_reserved[GST_PADDING - 1];
} GstAppSinkCallbacks;
</STRUCT>
<STRUCT>
<NAME>GstAppSink</NAME>
struct _GstAppSink
{
  GstBaseSink basesink;

  /*< private >*/
  GstAppSinkPrivate *priv;

  /*< private >*/
  gpointer     _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstAppSinkClass</NAME>
struct _GstAppSinkClass
{
  GstBaseSinkClass basesink_class;

  /* signals */
  void        (*eos)          (GstAppSink *sink);
  void        (*new_preroll)  (GstAppSink *sink);
  void        (*new_buffer)   (GstAppSink *sink);

  /* actions */
  GstBuffer     * (*pull_preroll)      (GstAppSink *sink);
  GstBuffer     * (*pull_buffer)       (GstAppSink *sink);

  /* ABI added */
  GstBufferList * (*new_buffer_list)   (GstAppSink *sink);
  GstBufferList * (*pull_buffer_list)  (GstAppSink *sink);

  /*< private >*/
  gpointer     _gst_reserved[GST_PADDING - 2];
};
</STRUCT>
<FUNCTION>
<NAME>gst_app_sink_get_type</NAME>
<RETURNS>GType </RETURNS>
void 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_sink_set_caps</NAME>
<RETURNS>void            </RETURNS>
GstAppSink *appsink, const GstCaps *caps 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_sink_get_caps</NAME>
<RETURNS>GstCaps *</RETURNS>
GstAppSink *appsink 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_sink_is_eos</NAME>
<RETURNS>gboolean        </RETURNS>
GstAppSink *appsink 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_sink_set_emit_signals</NAME>
<RETURNS>void            </RETURNS>
GstAppSink *appsink, gboolean emit 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_sink_get_emit_signals</NAME>
<RETURNS>gboolean        </RETURNS>
GstAppSink *appsink 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_sink_set_max_buffers</NAME>
<RETURNS>void            </RETURNS>
GstAppSink *appsink, guint max 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_sink_get_max_buffers</NAME>
<RETURNS>guint           </RETURNS>
GstAppSink *appsink 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_sink_set_drop</NAME>
<RETURNS>void            </RETURNS>
GstAppSink *appsink, gboolean drop 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_sink_get_drop</NAME>
<RETURNS>gboolean        </RETURNS>
GstAppSink *appsink 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_sink_pull_preroll</NAME>
<RETURNS>GstBuffer *</RETURNS>
GstAppSink *appsink 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_sink_pull_buffer</NAME>
<RETURNS>GstBuffer *</RETURNS>
GstAppSink *appsink 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_sink_pull_buffer_list</NAME>
<RETURNS>GstBufferList *</RETURNS>
GstAppSink *appsink 
</FUNCTION>
<FUNCTION>
<NAME>gst_app_sink_set_callbacks</NAME>
<RETURNS>void            </RETURNS>
GstAppSink * appsink, GstAppSinkCallbacks *callbacks, gpointer user_data, GDestroyNotify notify 
</FUNCTION>
